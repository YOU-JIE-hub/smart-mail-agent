================================================================================
BEGIN FILE  src_lowcov/src/send_with_attachment.py  (4189 bytes)
TAGS: legacy_candidate=no | sys_path_hack=no | duplicate_basename=no
--------------------------------------------------------------------------------
     1: #!/usr/bin/env python3
     2: # 檔案位置：src/send_with_attachment.py
     3: # 模組用途：寄送 Email（支援 HTML 內文、附件、錯誤處理、環境參數與 log 紀錄）
     4: import argparse
     5: import os
     6: import smtplib
     7: import traceback
     8: from email.mime.application import MIMEApplication
     9: from email.mime.multipart import MIMEMultipart
    10: from email.mime.text import MIMEText
    11: from pathlib import Path
    12: 
    13: from dotenv import load_dotenv
    14: from reportlab.pdfgen import canvas
    15: 
    16: from utils.logger import logger
    17: 
    18: # 強制指定 .env 位置
    19: load_dotenv(dotenv_path=Path(__file__).resolve().parents[1] / ".env")
    20: 
    21: # === SMTP 設定參數（需於 .env 中設定）===
    22: SMTP_USER = os.getenv("SMTP_USER")
    23: SMTP_PASS = os.getenv("SMTP_PASS")
    24: SMTP_HOST = os.getenv("SMTP_HOST", "smtp.gmail.com")
    25: SMTP_PORT = int(os.getenv("SMTP_PORT", 465))
    26: SMTP_FROM = os.getenv("SMTP_FROM", f"Smart-Mail-Agent <{SMTP_USER}>")
    27: REPLY_TO = os.getenv("REPLY_TO", SMTP_USER)
    28: 
    29: 
    30: # === 驗證 SMTP 參數 ===
    31: def validate_smtp_config():
    32:     missing = []
    33:     for key in ["SMTP_USER", "SMTP_PASS", "SMTP_HOST", "SMTP_PORT"]:
    34:         if not os.getenv(key):
    35:             missing.append(key)
    36:     if missing:
    37:         raise ValueError(f"[SMTP] 設定錯誤，缺少欄位：{', '.join(missing)}")
    38: 
    39: 
    40: # === 自動產 PDF（若不存在）===
    41: def generate_sample_pdf(filepath: str):
    42:     try:
    43:         c = canvas.Canvas(filepath)
    44:         c.drawString(100, 750, "這是一封測試郵件的附件 PDF")
    45:         c.save()
    46:         logger.info("[SMTP] 已產生測試 PDF：%s", filepath)
    47:     except Exception as e:
    48:         logger.error("[SMTP] PDF 建立失敗：%s", e)
    49: 
    50: 
    51: # === 主寄信函式 ===
    52: def send_email_with_attachment(
    53:     recipient: str,
    54:     subject: str,
    55:     body_html: str = None,
    56:     body_text: str = None,
    57:     attachment_path: str = None,
    58: ) -> bool:
    59:     try:
    60:         validate_smtp_config()
    61:     except Exception as e:
    62:         logger.error("[SMTP] 設定錯誤：%s", e)
    63:         return False
    64: 
    65:     msg = MIMEMultipart()
    66:     msg["From"] = SMTP_FROM
    67:     msg["To"] = recipient
    68:     msg["Subject"] = subject or "(No Subject)"
    69:     msg["Reply-To"] = REPLY_TO
    70: 
    71:     if body_text:
    72:         msg.attach(MIMEText(body_text, "plain", "utf-8"))
    73:     if body_html:
    74:         msg.attach(MIMEText(body_html, "html", "utf-8"))
    75: 
    76:     if attachment_path:
    77:         if not os.path.exists(attachment_path) and "sample.pdf" in attachment_path:
    78:             generate_sample_pdf(attachment_path)
    79:         if os.path.exists(attachment_path):
    80:             try:
    81:                 with open(attachment_path, "rb") as f:
    82:                     part = MIMEApplication(f.read(), Name=os.path.basename(attachment_path))
    83:                     part["Content-Disposition"] = f'attachment; filename="{os.path.basename(attachment_path)}"'
    84:                     msg.attach(part)
    85:                 logger.debug("[SMTP] 附件已加入：%s", attachment_path)
    86:             except Exception as e:
    87:                 logger.warning("[SMTP] 附件載入失敗：%s", e)
    88:         else:
    89:             logger.error("[SMTP] 找不到附件：%s", attachment_path)
    90:             return False
    91: 
    92:     try:
    93:         with smtplib.SMTP_SSL(SMTP_HOST, SMTP_PORT) as server:
    94:             server.login(SMTP_USER, SMTP_PASS)
    95:             server.send_message(msg)
    96:         logger.info("[SMTP] 信件已寄出：%s → %s", subject, recipient)
    97:         return True
    98: 
    99:     except Exception as e:
   100:         logger.error("[SMTP] 寄信失敗：%s", e)
   101:         logger.debug(traceback.format_exc())
   102:         return False
   103: 
   104: 
   105: # === CLI 執行介面 ===
   106: def main():
   107:     parser = argparse.ArgumentParser(description="寄送 Email，支援 HTML 內文與附件")
   108:     parser.add_argument("--to", required=True, help="收件者 Email")
   109:     parser.add_argument("--subject", required=True, help="郵件主旨")
   110:     parser.add_argument("--body", required=True, help="HTML 內文")
   111:     parser.add_argument("--file", required=True, help="附件檔案路徑")
   112: 
   113:     args = parser.parse_args()
   114: 
   115:     result = send_email_with_attachment(recipient=args.to, subject=args.subject, body_html=args.body, attachment_path=args.file)
   116: 
   117:     if result:
   118:         print("郵件已成功寄出")
   119:     else:
   120:         print("郵件寄出失敗")
   121: 
   122: 
   123: if __name__ == "__main__":
   124:     main()
--------------------------------------------------------------------------------
END FILE    src_lowcov/src/send_with_attachment.py
================================================================================
================================================================================
BEGIN FILE  src_lowcov/src/smart_mail_agent/__main__.py  (434 bytes)
TAGS: legacy_candidate=no | sys_path_hack=no | duplicate_basename=no
--------------------------------------------------------------------------------
     1: #!/usr/bin/env python3
     2: # 檔案位置: src/smart_mail_agent/__main__.py
     3: """
     4: 主進入點：轉呼叫現有專案的 src.run_action_handler 以維持相容。
     5: """
     6: 
     7: import subprocess
     8: import sys
     9: 
    10: 
    11: def main(argv=None) -> int:
    12:     argv = list(sys.argv[1:] if argv is None else argv)
    13:     cmd = [sys.executable, "-m", "src.run_action_handler", *argv]
    14:     return subprocess.call(cmd)
    15: 
    16: 
    17: if __name__ == "__main__":
    18:     raise SystemExit(main())
--------------------------------------------------------------------------------
END FILE    src_lowcov/src/smart_mail_agent/__main__.py
================================================================================
================================================================================
BEGIN FILE  src_lowcov/src/smart_mail_agent/actions/complaint.py  (2183 bytes)
TAGS: legacy_candidate=no | sys_path_hack=no | duplicate_basename=no
--------------------------------------------------------------------------------
     1: from __future__ import annotations
     2: 
     3: import json
     4: import sys
     5: 
     6: #!/usr/bin/env python3
     7: # 檔案位置：src/actions/complaint.py
     8: # 模組用途：處理投訴；計算嚴重度並輸出 SLA_eta / priority / next_step
     9: import uuid
    10: from typing import Any
    11: 
    12: ACTION_NAME = "complaint"
    13: 
    14: HIGH_KW = [
    15:     "無法使用",
    16:     "系統當機",
    17:     "down",
    18:     "資料外洩",
    19:     "資安",
    20:     "違法",
    21:     "詐騙",
    22:     "嚴重",
    23:     "停機",
    24:     "崩潰",
    25:     "災難",
    26:     "退款失敗",
    27:     "威脅",
    28:     "主管機關",
    29: ]
    30: MED_KW = ["錯誤", "bug", "延遲", "慢", "異常", "問題", "不穩", "失敗"]
    31: LOW_KW = ["建議", "希望", "改善", "回饋", "詢問"]
    32: 
    33: 
    34: def _severity(text: str) -> str:
    35:     t = text.lower()
    36:     if any(k.lower() in t for k in HIGH_KW):
    37:         return "high"
    38:     if any(k.lower() in t for k in MED_KW):
    39:         return "med"
    40:     return "low"
    41: 
    42: 
    43: def _sla_priority(severity: str) -> tuple[str, str]:
    44:     if severity == "high":
    45:         return ("4h", "P1")
    46:     if severity == "med":
    47:         return ("1d", "P2")
    48:     return ("3d", "P3")
    49: 
    50: 
    51: def execute(request: dict[str, Any], context: dict[str, Any] | None = None) -> dict[str, Any]:
    52:     subject = str(request.get("subject") or "")
    53:     body = str(request.get("body") or "")
    54:     sev = _severity(subject + "\n" + body)
    55:     sla, pri = _sla_priority(sev)
    56:     req_id = (request.get("meta") or {}).get("request_id") or uuid.uuid4().hex[:12]
    57: 
    58:     meta = dict(request.get("meta") or {})
    59:     meta.update(
    60:         {
    61:             "severity": sev,
    62:             "SLA_eta": sla,
    63:             "priority": pri,
    64:             "request_id": req_id,
    65:             "next_step": "建立工單並通知負責窗口",
    66:         }
    67:     )
    68: 
    69:     return {
    70:         "action_name": ACTION_NAME,
    71:         "subject": "[自動回覆] 客訴已受理",
    72:         "body": f"我們已收到您的反映並建立處理流程。嚴重度：{sev}，優先級：{pri}，SLA：{sla}",
    73:         "attachments": request.get("attachments") or [],
    74:         "meta": meta,
    75:     }
    76: 
    77: 
    78: handle = execute
    79: run = execute
    80: 
    81: if __name__ == "__main__":
    82:     import json
    83:     import sys
    84: 
    85:     payload = json.loads(sys.stdin.read() or "{}")
    86:     print(json.dumps(execute(payload), ensure_ascii=False))
--------------------------------------------------------------------------------
END FILE    src_lowcov/src/smart_mail_agent/actions/complaint.py
================================================================================
================================================================================
BEGIN FILE  src_lowcov/src/smart_mail_agent/actions/sales_inquiry.py  (6377 bytes)
TAGS: legacy_candidate=no | sys_path_hack=no | duplicate_basename=no
--------------------------------------------------------------------------------
     1: from __future__ import annotations
     2: 
     3: import json
     4: 
     5: #!/usr/bin/env python3
     6: # 檔案位置：src/actions/sales_inquiry.py
     7: # 模組用途：處理商務詢問；抽取關鍵欄位並以模板產出需求彙整 .md 附件；補充 meta.next_step
     8: import re
     9: import sys
    10: import uuid
    11: from datetime import datetime
    12: from pathlib import Path
    13: from typing import Any
    14: 
    15: try:
    16:     from jinja2 import Environment, FileSystemLoader, select_autoescape
    17: except Exception:
    18:     Environment = None  # type: ignore
    19: 
    20: ACTION_NAME = "sales_inquiry"
    21: 
    22: 
    23: def _ensure_dir(p: Path) -> None:
    24:     p.parent.mkdir(parents=True, exist_ok=True)
    25: 
    26: 
    27: def _load_template_env() -> Environment | None:
    28:     """
    29:     嘗試從 templates/ 與 src/templates/ 建立 Jinja2 環境
    30:     """
    31:     if Environment is None:
    32:         return None
    33:     search_paths: list[str] = []
    34:     for d in ("templates", "src/templates"):
    35:         if Path(d).is_dir():
    36:             search_paths.append(d)
    37:     if not search_paths:
    38:         return None
    39:     return Environment(
    40:         loader=FileSystemLoader(search_paths),
    41:         autoescape=select_autoescape(enabled_extensions=("j2", "html", "md")),
    42:         enable_async=False,
    43:     )
    44: 
    45: 
    46: # 規則式抽取：公司、數量、截止、預算、關鍵詞
    47: RE_COMPANY = re.compile(r"([A-Za-z\u4e00-\u9fa5][\w\u4e00-\u9fa5＆&\.-]{1,30})(?:股份有限公司|有限公司|公司)", re.I)
    48: RE_QUANTITY = re.compile(r"(\d{1,6})\s*(台|件|個|套|pcs?)", re.I)
    49: RE_BUDGET = re.compile(r"(?:NTD?|新台幣|\$)\s*([0-9][0-9,]{0,12})(?:\s*(萬|千|元|dollars?))?", re.I)
    50: RE_DATE1 = re.compile(r"(\d{4})[-/](\d{1,2})[-/](\d{1,2})")  # YYYY-MM-DD
    51: RE_DATE2 = re.compile(r"(\d{1,2})[月/](\d{1,2})[日]?", re.I)  # M月D日 or M/D
    52: RE_KEYWORDS = re.compile(r"[A-Za-z\u4e00-\u9fa5]{2,15}")
    53: 
    54: COMMON_STOP = {
    55:     "我們",
    56:     "你好",
    57:     "您好",
    58:     "謝謝",
    59:     "請問",
    60:     "協助",
    61:     "需要",
    62:     "希望",
    63:     "聯繫",
    64:     "安排",
    65:     "報價",
    66:     "需求",
    67:     "規格",
    68:     "提供",
    69: }
    70: 
    71: 
    72: def _extract_fields(subject: str, body: str, sender: str | None) -> dict[str, Any]:
    73:     text = f"{subject}\n{body}"
    74:     company = None
    75:     m = RE_COMPANY.search(text)
    76:     if m:
    77:         company = m.group(0)
    78: 
    79:     quantity = None
    80:     m = RE_QUANTITY.search(text)
    81:     if m:
    82:         quantity = f"{m.group(1)}{m.group(2)}"
    83: 
    84:     budget = None
    85:     m = RE_BUDGET.search(text)
    86:     if m:
    87:         money = m.group(1).replace(",", "")
    88:         unit = m.group(2) or "元"
    89:         budget = f"{money}{unit}"
    90: 
    91:     deadline = None
    92:     m = RE_DATE1.search(text)
    93:     if m:
    94:         yyyy, mm, dd = m.groups()
    95:         deadline = f"{yyyy}-{int(mm):02d}-{int(dd):02d}"
    96:     else:
    97:         m = RE_DATE2.search(text)
    98:         if m:
    99:             # 以當年補齊
   100:             year = datetime.now().year
   101:             mm, dd = m.groups()
   102:             deadline = f"{year}-{int(mm):02d}-{int(dd):02d}"
   103: 
   104:     kw_raw = [w for w in RE_KEYWORDS.findall(text) if w not in COMMON_STOP]
   105:     keywords = []
   106:     seen = set()
   107:     for w in kw_raw:
   108:         if w.lower() in seen:
   109:             continue
   110:         seen.add(w.lower())
   111:         keywords.append(w)
   112:         if len(keywords) >= 8:
   113:             break
   114: 
   115:     contact = None
   116:     if sender and "@" in sender:
   117:         contact = sender.split("@", 1)[0]
   118: 
   119:     summary = subject.strip()[:120]
   120: 
   121:     return {
   122:         "company": company,
   123:         "quantity": quantity,
   124:         "deadline": deadline,
   125:         "budget": budget,
   126:         "keywords": keywords,
   127:         "contact": contact,
   128:         "summary": summary,
   129:     }
   130: 
   131: 
   132: def _render_needs_md(context: dict[str, Any]) -> str:
   133:     env = _load_template_env()
   134:     if env:
   135:         try:
   136:             tpl = env.get_template("needs_summary.md.j2")
   137:             return tpl.render(**context)
   138:         except Exception:
   139:             pass
   140:     # 簡單回退
   141:     ks = ", ".join(context.get("keywords") or [])
   142:     return (
   143:         "# 商務需求彙整\n\n"
   144:         f"- 公司：{context.get('company') or '未明'}\n"
   145:         f"- 聯絡人：{context.get('contact') or '未明'}\n"
   146:         f"- 需求摘要：{context.get('summary') or '未提供'}\n\n"
   147:         "## 關鍵欄位\n"
   148:         f"- 數量：{context.get('quantity') or '未明'}\n"
   149:         f"- 截止：{context.get('deadline') or '未明'}\n"
   150:         f"- 預算：{context.get('budget') or '未明'}\n"
   151:         f"- 關鍵字：{ks or '無'}\n\n"
   152:         "## 建議下一步\n"
   153:         "1. 由業務與對方確認功能範圍與驗收標準\n"
   154:         "2. 安排需求澄清會議並產出會議紀要\n"
   155:         "3. 依會議結論繪製最小可行方案並給出時程與成本\n"
   156:     )
   157: 
   158: 
   159: def execute(request: dict[str, Any], context: dict[str, Any] | None = None) -> dict[str, Any]:
   160:     """
   161:     參數:
   162:         request: 輸入 JSON（subject/from/body/predicted_label/confidence/attachments）
   163:         context: 可選上下文
   164:     回傳:
   165:         ActionResult dict：含 .md 附件與 meta.next_step
   166:     """
   167:     subject = str(request.get("subject") or "").strip()
   168:     body = str(request.get("body") or "").strip()
   169:     sender = request.get("from")
   170: 
   171:     req_id = (request.get("meta") or {}).get("request_id") or uuid.uuid4().hex[:12]
   172:     fields = _extract_fields(subject, body, sender)
   173:     md_text = _render_needs_md(fields)
   174: 
   175:     out_dir = Path("data/output")
   176:     _ensure_dir(out_dir)
   177:     md_name = f"needs_summary_{req_id}.md"
   178:     md_path = out_dir / md_name
   179:     md_path.write_text(md_text, encoding="utf-8")
   180: 
   181:     attachments = request.get("attachments") or []
   182:     attachments = list(attachments)
   183:     try:
   184:         size = md_path.stat().st_size
   185:     except Exception:
   186:         size = len(md_text.encode("utf-8"))
   187: 
   188:     attachments.append({"filename": md_name, "size": size})
   189: 
   190:     meta = dict(request.get("meta") or {})
   191:     meta.update(
   192:         {
   193:             "next_step": "安排需求澄清會議並由業務跟進",
   194:             "confidence": request.get("confidence"),
   195:             "request_id": req_id,
   196:         }
   197:     )
   198: 
   199:     return {
   200:         "action_name": ACTION_NAME,
   201:         "subject": "[自動回覆] 商務詢問回覆",
   202:         "body": "您好，已收到您的商務需求，附件為彙整內容，將由業務與您聯繫確認細節。",
   203:         "attachments": attachments,
   204:         "meta": meta,
   205:     }
   206: 
   207: 
   208: # 兼容不同呼叫名稱
   209: handle = execute
   210: run = execute
   211: 
   212: if __name__ == "__main__":
   213:     import json
   214:     import sys
   215: 
   216:     payload = json.loads(sys.stdin.read() or "{}")
   217:     print(json.dumps(execute(payload), ensure_ascii=False))
--------------------------------------------------------------------------------
END FILE    src_lowcov/src/smart_mail_agent/actions/sales_inquiry.py
================================================================================
================================================================================
BEGIN FILE  src_lowcov/src/smart_mail_agent/cli_spamcheck.py  (1923 bytes)
TAGS: legacy_candidate=no | sys_path_hack=no | duplicate_basename=no
--------------------------------------------------------------------------------
     1: from __future__ import annotations
     2: 
     3: import argparse
     4: import json
     5: 
     6: 
     7: def _heuristic_spam_score(text: str) -> float:
     8:     if not text:
     9:         return 0.0
    10:     lowers = text.lower()
    11:     kws = [
    12:         "free",
    13:         "winner",
    14:         "bitcoin",
    15:         "viagra",
    16:         "casino",
    17:         "loan",
    18:         "credit",
    19:         "limited time",
    20:         "act now",
    21:         "click here",
    22:         "http://",
    23:         "https://",
    24:         "獎",
    25:         "中獎",
    26:         "免費",
    27:         "限時",
    28:         "點擊",
    29:         "投資",
    30:         "加密",
    31:         "博彩",
    32:     ]
    33:     score = 0.0
    34:     for k in kws:
    35:         if k in lowers:
    36:             score += 0.08
    37:     if "http://" in lowers or "https://" in lowers:
    38:         score += 0.10
    39:     return min(score, 0.99)
    40: 
    41: 
    42: def _classify(subject: str, content: str, sender: str | None = None) -> dict:
    43:     text = f"{subject}\n{content}\n{sender or ''}"
    44:     score = _heuristic_spam_score(text)
    45:     return {
    46:         "subject": subject,
    47:         "sender": sender,
    48:         "score": round(score, 2),
    49:         "is_spam": score >= 0.5,
    50:         "engine": "heuristic-v0",
    51:     }
    52: 
    53: 
    54: def main(argv: list[str] | None = None) -> int:
    55:     ap = argparse.ArgumentParser(
    56:         prog="sma-spamcheck",
    57:         description="垃圾信偵測（輕量 CLI 包裝器，可替換為正式 orchestrator）",
    58:     )
    59:     ap.add_argument("--subject", required=True)
    60:     ap.add_argument("--content", required=True)
    61:     ap.add_argument("--sender")
    62:     ap.add_argument("--json", action="store_true", help="輸出 JSON（預設為人讀格式）")
    63:     args = ap.parse_args(argv)
    64: 
    65:     res = _classify(args.subject, args.content, args.sender)
    66:     if args.json:
    67:         print(json.dumps(res, ensure_ascii=False))
    68:     else:
    69:         print(f"subject={res['subject']!r} sender={res['sender']!r} " f"is_spam={res['is_spam']} score={res['score']} engine={res['engine']}")
    70:     return 0
    71: 
    72: 
    73: if __name__ == "__main__":
    74:     raise SystemExit(main())
--------------------------------------------------------------------------------
END FILE    src_lowcov/src/smart_mail_agent/cli_spamcheck.py
================================================================================
================================================================================
BEGIN FILE  src_lowcov/src/smart_mail_agent/spam/feature_extractor.py  (1218 bytes)
TAGS: legacy_candidate=no | sys_path_hack=no | duplicate_basename=no
--------------------------------------------------------------------------------
     1: #!/usr/bin/env python3
     2: # 檔案位置：src/spam/feature_extractor.py
     3: # 模組用途：從原始 Email 字串中擷取關鍵特徵，用於垃圾郵件判斷（供 ML 模型使用）
     4: 
     5: import re
     6: from email import message_from_string
     7: 
     8: 
     9: def extract_features(raw_email: str) -> dict[str, int]:
    10:     """
    11:     從原始 Email 內文中抽取特徵向量，用於垃圾郵件偵測模型。
    12: 
    13:     參數:
    14:         raw_email (str): 原始 email 字串（含標頭與主體）
    15: 
    16:     回傳:
    17:         dict: 包含以下欄位的特徵向量：
    18:             - subject_len (int): 主旨長度
    19:             - num_urls (int): URL 出現次數
    20:             - has_attachment (int): 是否含非純文字附件（1/0）
    21:             - num_recipients (int): 收件人數量（To + Cc）
    22:     """
    23:     msg = message_from_string(raw_email)
    24: 
    25:     subject = msg.get("Subject", "") or ""
    26:     to_list = msg.get_all("To", []) or []
    27:     cc_list = msg.get_all("Cc", []) or []
    28: 
    29:     features = {
    30:         "subject_len": len(subject),
    31:         "num_urls": len(re.findall(r"https?://", raw_email)),
    32:         "has_attachment": int(msg.get_content_maintype() not in ["text", "multipart"]),
    33:         "num_recipients": len(to_list + cc_list),
    34:     }
    35: 
    36:     return features
--------------------------------------------------------------------------------
END FILE    src_lowcov/src/smart_mail_agent/spam/feature_extractor.py
================================================================================
================================================================================
BEGIN FILE  src_lowcov/src/smart_mail_agent/spam/ml_spam_classifier.py  (2529 bytes)
TAGS: legacy_candidate=no | sys_path_hack=no | duplicate_basename=no
--------------------------------------------------------------------------------
     1: #!/usr/bin/env python3
     2: # mypy: ignore-errors
     3: # 檔案位置：src/spam/ml_spam_classifier.py
     4: # 模組用途：使用 fine-tuned BERT 模型進行垃圾郵件分類預測
     5: 
     6: import torch
     7: from transformers import (
     8:     AutoModelForSequenceClassification,
     9:     AutoTokenizer,
    10:     TextClassificationPipeline,
    11: )
    12: 
    13: from utils.logger import logger
    14: 
    15: 
    16: def smart_truncate(text: str, max_chars: int = 1000) -> str:
    17:     """
    18:     對長文本進行三段式裁切：保留前段、中段、尾段內容，確保語意不中斷。
    19: 
    20:     :param text: 原始文本
    21:     :param max_chars: 限制總長度
    22:     :return: 裁切後文本
    23:     """
    24:     if len(text) <= max_chars:
    25:         return text
    26:     head = text[: int(max_chars * 0.4)]
    27:     mid_start = int(len(text) / 2 - max_chars * 0.15)
    28:     mid_end = int(len(text) / 2 + max_chars * 0.15)
    29:     middle = text[mid_start:mid_end]
    30:     tail = text[-int(max_chars * 0.3) :]
    31:     return head + "\n...\n" + middle + "\n...\n" + tail
    32: 
    33: 
    34: class SpamBertClassifier:
    35:     """
    36:     使用 HuggingFace Transformers 微調模型進行 spam/ham 分類
    37:     """
    38: 
    39:     def __init__(self, model_path: str):
    40:         device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
    41:         logger.info(f"[SpamBertClassifier] 載入 BERT 模型：{model_path}")
    42:         self.tokenizer = AutoTokenizer.from_pretrained(model_path)
    43:         self.model = AutoModelForSequenceClassification.from_pretrained(model_path).to(device)
    44:         self.pipeline = TextClassificationPipeline(
    45:             model=self.model,
    46:             tokenizer=self.tokenizer,
    47:             device=0 if device.type == "cuda" else -1,
    48:             top_k=None,
    49:         )
    50: 
    51:     def predict(self, subject: str, content: str) -> dict:
    52:         """
    53:         執行垃圾信預測分類
    54: 
    55:         :param subject: 信件主旨
    56:         :param content: 信件內容
    57:         :return: dict 包含 label 與 confidence
    58:         """
    59:         text = smart_truncate(f"{subject.strip()}\n{content.strip()}", max_chars=1000)
    60: 
    61:         try:
    62:             preds = self.pipeline(text)[0]
    63:             preds = sorted(preds, key=lambda x: x["score"], reverse=True)
    64:             pred_label = preds[0]["label"]
    65:             confidence = round(preds[0]["score"], 4)
    66:             logger.debug(f"[SpamBertClassifier] 預測結果：{pred_label} (信心值：{confidence})")
    67:             return {"label": pred_label, "confidence": confidence}
    68:         except Exception as e:
    69:             logger.error(f"[SpamBertClassifier] 預測失敗：{str(e)}")
    70:             return {"label": "unknown", "confidence": 0.0}
--------------------------------------------------------------------------------
END FILE    src_lowcov/src/smart_mail_agent/spam/ml_spam_classifier.py
================================================================================
================================================================================
BEGIN FILE  src_lowcov/src/smart_mail_agent/spam/pipeline.py  (503 bytes)
TAGS: legacy_candidate=no | sys_path_hack=no | duplicate_basename=no
--------------------------------------------------------------------------------
     1: from __future__ import annotations
     2: 
     3: from typing import Any
     4: 
     5: from .rules import label_email
     6: 
     7: 
     8: def analyze(email: dict[str, Any]) -> dict[str, Any]:
     9:     sender = email.get("sender", "") or ""
    10:     subject = email.get("subject", "") or ""
    11:     content = email.get("content", "") or ""
    12:     attachments = email.get("attachments") or []
    13:     label, score, reasons = label_email(sender, subject, content, attachments)
    14:     return {"label": label, "score": int(score), "reasons": list(reasons), "subject": subject}
--------------------------------------------------------------------------------
END FILE    src_lowcov/src/smart_mail_agent/spam/pipeline.py
================================================================================
================================================================================
BEGIN FILE  src_lowcov/src/smart_mail_agent/spam/rule_filter.py  (2643 bytes)
TAGS: legacy_candidate=no | sys_path_hack=no | duplicate_basename=no
--------------------------------------------------------------------------------
     1: #!/usr/bin/env python3
     2: # 檔案位置：src/spam/rule_filter.py
     3: # 模組用途：使用靜態規則（關鍵字、黑名單、樣式）偵測垃圾郵件內容
     4: 
     5: import re
     6: 
     7: from utils.logger import logger
     8: 
     9: 
    10: class RuleBasedSpamFilter:
    11:     """
    12:     規則式垃圾信過濾器：透過關鍵字、黑名單網域、常見連結樣式進行 spam 偵測。
    13:     """
    14: 
    15:     def __init__(self):
    16:         # 黑名單網域（若 email 內容包含此網址，視為 spam）
    17:         self.blacklist_domains = ["xxx.com", "freemoney.cn", "spamlink.net"]
    18: 
    19:         # 可疑 spam 關鍵字（不區分大小寫）
    20:         self.suspicious_keywords = [
    21:             "裸聊",
    22:             "中獎",
    23:             "限時優惠",
    24:             "點我加入",
    25:             "免費試用",
    26:             "現金回饋",
    27:             "賺錢",
    28:             "投資機會",
    29:             "line加好友",
    30:             "情色",
    31:             "財務自由",
    32:             "送你",
    33:             "簡單賺錢",
    34:         ]
    35: 
    36:         # 常見 spam 連結樣式（正規表達式）
    37:         self.patterns = [
    38:             re.compile(r"https?://[^\s]*\.xxx\.com", re.IGNORECASE),
    39:             re.compile(r"line\s*[:：]?\s*[\w\-]+", re.IGNORECASE),
    40:         ]
    41:         # [SMA] 強化高風險關鍵字
    42:         try:
    43:             self.keywords.extend(
    44:                 [
    45:                     "免費中獎",
    46:                     "中獎",
    47:                     "點此領獎",
    48:                     "領獎",
    49:                     "百萬",
    50:                     "點擊領取",
    51:                     "刷卡驗證",
    52:                     "帳號異常",
    53:                     "快速致富",
    54:                     "投資保證獲利",
    55:                 ]
    56:             )
    57:         except Exception:
    58:             pass
    59: 
    60:     def is_spam(self, text: str) -> bool:
    61:         """
    62:         判斷文字是否為垃圾信件內容。
    63: 
    64:         :param text: 信件主旨與內容合併後的純文字
    65:         :return: bool - 是否為 spam
    66:         """
    67:         text = text.lower()
    68:         logger.debug("[RuleBasedSpamFilter] 進行規則式 Spam 檢查")
    69: 
    70:         for kw in self.suspicious_keywords:
    71:             if kw in text:
    72:                 logger.info(f"[RuleBasedSpamFilter] 偵測關鍵字：{kw}")
    73:                 return True
    74: 
    75:         for domain in self.blacklist_domains:
    76:             if domain in text:
    77:                 logger.info(f"[RuleBasedSpamFilter] 偵測黑名單網址：{domain}")
    78:                 return True
    79: 
    80:         for pattern in self.patterns:
    81:             if pattern.search(text):
    82:                 logger.info(f"[RuleBasedSpamFilter] 偵測樣式：{pattern.pattern}")
    83:                 return True
    84: 
    85:         return False
--------------------------------------------------------------------------------
END FILE    src_lowcov/src/smart_mail_agent/spam/rule_filter.py
================================================================================
================================================================================
BEGIN FILE  src_lowcov/src/smart_mail_agent/spam/rules.py  (4321 bytes)
TAGS: legacy_candidate=no | sys_path_hack=no | duplicate_basename=no
--------------------------------------------------------------------------------
     1: from __future__ import annotations
     2: 
     3: import json
     4: import re
     5: from pathlib import Path
     6: from typing import Any
     7: 
     8: try:
     9:     import yaml  # type: ignore
    10: except Exception:
    11:     yaml = None
    12: 
    13: CONF_PATH = Path(__file__).resolve().parents[2] / "configs" / "spam_rules.yaml"
    14: _CACHE = {"mtime": None, "rules": None}
    15: 
    16: _URL_RE = re.compile(r"https?://[^\s)>\]]+", re.I)
    17: 
    18: 
    19: def _default_rules() -> dict[str, Any]:
    20:     # 與預設 YAML 對齊
    21:     return {
    22:         "keywords": {
    23:             "GET RICH QUICK": 6,
    24:             "FREE": 2,
    25:             "GIVEAWAY": 3,
    26:             "CRYPTO": 2,
    27:             "PASSWORD RESET": 2,
    28:             "VERIFY YOUR ACCOUNT": 3,
    29:             "URGENT": 2,
    30:         },
    31:         "suspicious_domains": ["bit.ly", "tinyurl.com", "goo.gl", "is.gd", "t.co"],
    32:         "suspicious_tlds": ["tk", "gq", "ml", "cf", "ga", "top"],
    33:         "bad_extensions": [".js", ".vbs", ".exe", ".bat", ".cmd", ".scr"],
    34:         "whitelist_domains": ["yourcompany.com", "example.com"],
    35:         "weights": {
    36:             "url_suspicious": 4,
    37:             "tld_suspicious": 3,
    38:             "attachment_executable": 5,
    39:             "sender_black": 5,
    40:         },
    41:         "thresholds": {"suspect": 4, "spam": 8},
    42:     }
    43: 
    44: 
    45: def _load_yaml_or_json(text: str) -> dict[str, Any]:
    46:     if yaml is not None:
    47:         try:
    48:             return yaml.safe_load(text) or {}
    49:         except Exception:
    50:             pass
    51:     # JSON 兼容
    52:     return json.loads(text)
    53: 
    54: 
    55: def load_rules(force: bool = False) -> dict[str, Any]:
    56:     """熱重載：檔案 mtime 變動即重新載入。"""
    57:     try:
    58:         mtime = CONF_PATH.stat().st_mtime
    59:         if force or _CACHE["rules"] is None or _CACHE["mtime"] != mtime:
    60:             data = _load_yaml_or_json(CONF_PATH.read_text(encoding="utf-8"))
    61:             if not isinstance(data, dict) or not data:
    62:                 data = _default_rules()
    63:             _CACHE["rules"] = data
    64:             _CACHE["mtime"] = mtime
    65:     except FileNotFoundError:
    66:         _CACHE["rules"] = _default_rules()
    67:         _CACHE["mtime"] = None
    68:     return _CACHE["rules"]  # type: ignore[return-value]
    69: 
    70: 
    71: def score_email(sender: str, subject: str, content: str, attachments: list[str]) -> tuple[int, list[str]]:
    72:     r = load_rules()
    73:     score = 0
    74:     reasons: list[str] = []
    75: 
    76:     sender = (sender or "").strip().lower()
    77:     subject_u = (subject or "").upper()
    78:     content_u = (content or "").upper()
    79: 
    80:     # 1) 白名單網域
    81:     domain = sender.split("@")[-1] if "@" in sender else sender
    82:     domain = (domain or "").lower()
    83:     if domain and any(domain.endswith(w) for w in r.get("whitelist_domains", [])):
    84:         # 白名單不直接歸 legit，仍然保留下方檢查（避免白名單被濫用）
    85:         pass
    86: 
    87:     # 2) 關鍵詞
    88:     kw = r.get("keywords", {})
    89:     for k, s in kw.items():
    90:         if k in subject_u or k in content_u:
    91:             score += int(s)
    92:             reasons.append(f"keyword:{k}")
    93: 
    94:     # 3) URL 可疑（網域、TLD）
    95:     w = r.get("weights", {})
    96:     u = _URL_RE.findall(content or "")
    97:     susp_domains = {d.lower() for d in r.get("suspicious_domains", [])}
    98:     susp_tlds = {t.lower() for t in r.get("suspicious_tlds", [])}
    99:     for url in u:
   100:         host = url.split("://", 1)[-1].split("/", 1)[0].lower()
   101:         if any(host == d or host.endswith("." + d) for d in susp_domains):
   102:             score += int(w.get("url_suspicious", 0))
   103:             reasons.append(f"url:{host}")
   104:         tld = host.rsplit(".", 1)[-1]
   105:         if tld in susp_tlds:
   106:             score += int(w.get("tld_suspicious", 0))
   107:             reasons.append(f"tld:.{tld}")
   108: 
   109:     # 4) 附件可執行
   110:     bad_exts = [e.lower() for e in r.get("bad_extensions", [])]
   111:     for a in attachments or []:
   112:         ext = a.lower().rsplit(".", 1)
   113:         ext = "." + ext[-1] if len(ext) == 2 else ""
   114:         if ext in bad_exts:
   115:             score += int(w.get("attachment_executable", 0))
   116:             reasons.append(f"attachment:{ext}")
   117: 
   118:     return score, reasons
   119: 
   120: 
   121: def label_email(sender: str, subject: str, content: str, attachments: list[str]) -> tuple[str, int, list[str]]:
   122:     r = load_rules()
   123:     score, reasons = score_email(sender, subject, content, attachments)
   124:     th = r.get("thresholds", {"suspect": 4, "spam": 8})
   125:     label = "spam" if score >= int(th.get("spam", 8)) else ("suspect" if score >= int(th.get("suspect", 4)) else "legit")
   126:     return label, score, reasons
--------------------------------------------------------------------------------
END FILE    src_lowcov/src/smart_mail_agent/spam/rules.py
================================================================================
================================================================================
BEGIN FILE  src_lowcov/src/smart_mail_agent/spam/spam_llm_filter.py  (2181 bytes)
TAGS: legacy_candidate=no | sys_path_hack=no | duplicate_basename=no
--------------------------------------------------------------------------------
     1: import os
     2: 
     3: #!/usr/bin/env python3
     4: # 檔案位置：src/spam/spam_llm_filter.py
     5: # 模組用途：使用 OpenAI GPT 模型判斷信件是否具詐騙/釣魚嫌疑（L2）
     6: from dotenv import load_dotenv
     7: from openai import OpenAI, OpenAIError
     8: 
     9: from utils.logger import logger
    10: 
    11: load_dotenv()
    12: 
    13: 
    14: class SpamLLMFilter:
    15:     """
    16:     使用 OpenAI GPT API 進行詐騙信判斷（L2 分層）
    17:     回傳是否可疑（bool）
    18:     """
    19: 
    20:     def __init__(self, model: str = "gpt-3.5-turbo", max_tokens: int = 256):
    21:         api_key = os.getenv("OPENAI_API_KEY")
    22:         if not api_key:
    23:             raise ValueError("[SpamLLMFilter] 缺少必要環境變數 OPENAI_API_KEY")
    24:         self.client = OpenAI(api_key=api_key)
    25:         self.model = model
    26:         self.max_tokens = max_tokens
    27: 
    28:     def is_suspicious(self, subject: str, content: str) -> bool:
    29:         """
    30:         呼叫 OpenAI 判斷是否為詐騙信件。
    31: 
    32:         :param subject: 信件主旨
    33:         :param content: 信件內容
    34:         :return: bool - 是否具可疑詐騙嫌疑
    35:         """
    36:         try:
    37:             full_text = f"主旨：{subject}\n內容：{content}".strip()
    38:             prompt = f"判斷以下郵件是否為詐騙信或社交工程釣魚信。\n如果你判斷為【正常信件】，請回：OK\n如果你判斷為【可能詐騙或釣魚】，請回：SUSPICIOUS\n\n{full_text}"
    39: 
    40:             response = self.client.chat.completions.create(
    41:                 model=self.model,
    42:                 messages=[
    43:                     {"role": "system", "content": "你是資安專家，負責分析詐騙信件。"},
    44:                     {"role": "user", "content": prompt},
    45:                 ],
    46:                 max_tokens=self.max_tokens,
    47:                 temperature=0.0,
    48:             )
    49: 
    50:             answer = response.choices[0].message.content.strip().upper()
    51:             logger.debug(f"[SpamLLMFilter] 判斷結果：{answer}")
    52:             return "SUSPICIOUS" in answer
    53: 
    54:         except OpenAIError as e:
    55:             logger.error(f"[SpamLLMFilter] OpenAI API 錯誤：{e}")
    56:         except Exception as e:
    57:             logger.error(f"[SpamLLMFilter] LLM 判斷失敗：{e}")
    58: 
    59:         return False  # fallback 預設為非可疑
--------------------------------------------------------------------------------
END FILE    src_lowcov/src/smart_mail_agent/spam/spam_llm_filter.py
================================================================================
================================================================================
BEGIN FILE  src_lowcov/src/smart_mail_agent/utils/config.py  (516 bytes)
TAGS: legacy_candidate=no | sys_path_hack=no | duplicate_basename=no
--------------------------------------------------------------------------------
     1: from __future__ import annotations
     2: 
     3: import os
     4: from dataclasses import dataclass
     5: 
     6: 
     7: @dataclass
     8: class Settings:
     9:     offline: bool = bool(int(os.getenv("OFFLINE", "1") in ("1", "true", "True")))
    10:     smtp_host: str = os.getenv("SMTP_HOST", "localhost")
    11:     smtp_port: int = int(os.getenv("SMTP_PORT", "25"))
    12:     imap_host: str = os.getenv("IMAP_HOST", "localhost")
    13:     request_timeout_s: int = int(os.getenv("REQUEST_TIMEOUT_S", "30"))
    14:     demo_language: str = os.getenv("DEMO_LANGUAGE", "zh-TW")
    15: 
    16: 
    17: SETTINGS = Settings()
--------------------------------------------------------------------------------
END FILE    src_lowcov/src/smart_mail_agent/utils/config.py
================================================================================
================================================================================
BEGIN FILE  src_lowcov/src/smart_mail_agent/utils/db_tools.py  (2319 bytes)
TAGS: legacy_candidate=no | sys_path_hack=no | duplicate_basename=no
--------------------------------------------------------------------------------
     1: #!/usr/bin/env python3
     2: # 檔案位置：src/utils/db_tools.py
     3: # 模組用途：用於查詢 SQLite 使用者資料表（get by email / get all）
     4: 
     5: import sqlite3
     6: 
     7: from utils.logger import logger
     8: 
     9: 
    10: def get_user_by_email(db_path: str, email: str) -> dict | None:
    11:     """
    12:     根據 email 查詢單一使用者資料
    13: 
    14:     :param db_path: 資料庫檔案路徑
    15:     :param email: 欲查詢的 Email
    16:     :return: dict 或 None，查無資料時回傳 None
    17:     """
    18:     try:
    19:         conn = sqlite3.connect(db_path)
    20:         cursor = conn.cursor()
    21:         cursor.execute(
    22:             """
    23:             SELECT id, email, name, phone, address
    24:             FROM users
    25:             WHERE email = ?
    26:         """,
    27:             (email,),
    28:         )
    29:         row = cursor.fetchone()
    30:         conn.close()
    31: 
    32:         if row:
    33:             logger.info(f"[DB] 查詢成功：{email}")
    34:             return {
    35:                 "id": row[0],
    36:                 "email": row[1],
    37:                 "name": row[2],
    38:                 "phone": row[3],
    39:                 "address": row[4],
    40:             }
    41:         else:
    42:             logger.warning(f"[DB] 查無資料：{email}")
    43:             return None
    44: 
    45:     except Exception as e:
    46:         logger.error(f"[DB] 查詢使用者失敗：{e}")
    47:         return None
    48: 
    49: 
    50: def get_all_users(db_path: str) -> list[dict]:
    51:     """
    52:     查詢所有使用者資料
    53: 
    54:     :param db_path: 資料庫檔案路徑
    55:     :return: list of dicts，包含所有使用者欄位
    56:     """
    57:     try:
    58:         conn = sqlite3.connect(db_path)
    59:         cursor = conn.cursor()
    60:         cursor.execute("SELECT id, email, name, phone, address FROM users")
    61:         rows = cursor.fetchall()
    62:         conn.close()
    63: 
    64:         logger.info(f"[DB] 成功查詢所有使用者，共 {len(rows)} 筆")
    65:         return [{"id": row[0], "email": row[1], "name": row[2], "phone": row[3], "address": row[4]} for row in rows]
    66:     except Exception as e:
    67:         logger.error(f"[DB] 查詢所有使用者失敗：{e}")
    68:         return []
    69: 
    70: 
    71: # CLI 測試入口
    72: if __name__ == "__main__":
    73:     db_path = "data/users.db"
    74: 
    75:     print("【查詢全部使用者】")
    76:     all_users = get_all_users(db_path)
    77:     for user in all_users:
    78:         print(user)
    79: 
    80:     print("\n【查詢單一使用者】")
    81:     user = get_user_by_email(db_path, "test@example.com")
    82:     print(user or "找不到對應使用者")
--------------------------------------------------------------------------------
END FILE    src_lowcov/src/smart_mail_agent/utils/db_tools.py
================================================================================
================================================================================
BEGIN FILE  src_lowcov/src/smart_mail_agent/utils/env.py  (358 bytes)
TAGS: legacy_candidate=no | sys_path_hack=no | duplicate_basename=no
--------------------------------------------------------------------------------
     1: from __future__ import annotations
     2: 
     3: import os
     4: 
     5: # -*- coding: utf-8 -*-
     6: 
     7: 
     8: def get_bool(keys, default=False):
     9:     if isinstance(keys, str):
    10:         keys = [keys]
    11:     for k in keys:
    12:         v = os.environ.get(k)
    13:         if v is None:
    14:             continue
    15:         s = str(v).strip().lower()
    16:         return s in ("1", "true", "yes", "y", "on")
    17:     return default
--------------------------------------------------------------------------------
END FILE    src_lowcov/src/smart_mail_agent/utils/env.py
================================================================================
================================================================================
BEGIN FILE  src_lowcov/src/smart_mail_agent/utils/errors.py  (311 bytes)
TAGS: legacy_candidate=no | sys_path_hack=no | duplicate_basename=no
--------------------------------------------------------------------------------
     1: from __future__ import annotations
     2: 
     3: 
     4: class UserInputError(Exception):
     5:     """Raised for invalid user input."""
     6: 
     7:     pass
     8: 
     9: 
    10: class ExternalServiceError(Exception):
    11:     """Raised when external services fail."""
    12: 
    13:     pass
    14: 
    15: 
    16: class InternalError(Exception):
    17:     """Raised for unexpected internal errors."""
    18: 
    19:     pass
--------------------------------------------------------------------------------
END FILE    src_lowcov/src/smart_mail_agent/utils/errors.py
================================================================================
================================================================================
BEGIN FILE  src_lowcov/src/smart_mail_agent/utils/font_check.py  (626 bytes)
TAGS: legacy_candidate=no | sys_path_hack=no | duplicate_basename=no
--------------------------------------------------------------------------------
     1: from __future__ import annotations
     2: 
     3: import os
     4: 
     5: #!/usr/bin/env python3
     6: from pathlib import Path
     7: 
     8: 
     9: def get_font_path(env_key: str = "FONT_PATH") -> str | None:
    10:     p = os.getenv(env_key, "").strip()
    11:     if not p:
    12:         return None
    13:     path = Path(p)
    14:     return str(path) if path.is_file() else None
    15: 
    16: 
    17: def ensure_font_available(logger=None) -> str | None:
    18:     fp = get_font_path()
    19:     if fp is None:
    20:         msg = "未找到中文字型 FONT_PATH，PDF 中文輸出可能失敗；請放置 assets/fonts/NotoSansTC-Regular.ttf 並更新 .env"
    21:         (logger.warning if logger else print)(msg)
    22:         return None
    23:     return fp
--------------------------------------------------------------------------------
END FILE    src_lowcov/src/smart_mail_agent/utils/font_check.py
================================================================================
================================================================================
BEGIN FILE  src_lowcov/src/smart_mail_agent/utils/fonts.py  (521 bytes)
TAGS: legacy_candidate=no | sys_path_hack=no | duplicate_basename=no
--------------------------------------------------------------------------------
     1: #!/usr/bin/env python3
     2: from __future__ import annotations
     3: 
     4: import os
     5: 
     6: # 檔案位置: src/smart_mail_agent/utils/fonts.py
     7: from pathlib import Path
     8: 
     9: PREFERRED = ("NotoSansTC-Regular.ttf",)
    10: 
    11: 
    12: def find_font(root: str | Path = ".") -> str | None:
    13:     env_font = os.getenv("FONT_PATH")
    14:     if env_font and Path(env_font).is_file():
    15:         return env_font
    16:     root = Path(root).resolve()
    17:     for name in PREFERRED:
    18:         p = root / "assets" / "fonts" / name
    19:         if p.is_file():
    20:             return str(p)
    21:     return None
--------------------------------------------------------------------------------
END FILE    src_lowcov/src/smart_mail_agent/utils/fonts.py
================================================================================
================================================================================
BEGIN FILE  src_lowcov/src/smart_mail_agent/utils/imap_folder_detector.py  (2435 bytes)
TAGS: legacy_candidate=yes | sys_path_hack=no | duplicate_basename=no
--------------------------------------------------------------------------------
     1: #!/usr/bin/env python3
     2: # 檔案位置：src/utils/imap_utils.py
     3: # 模組用途：偵測 Gmail 的 All Mail 資料夾名稱，支援不同語系與 IMAP 編碼
     4: import imaplib
     5: import os
     6: 
     7: 
     8: def _decode_imap_bytes(v: bytes | tuple[bytes, ...] | bytearray) -> str:
     9:     """統一處理 IMAP 回傳：可能為 bytes 或 (bytes, ...)。
    10:     盡力解碼，失敗則回傳 str(v)。"""
    11:     try:
    12:         if isinstance(v, (bytes, bytearray)):
    13:             return _decode_imap_bytes(v)
    14:         if isinstance(v, tuple) and v:
    15:             # 常見格式 (b'OK', [b'INBOX']) / (b'...', b'...')
    16:             first = v[0]
    17:             if isinstance(first, (bytes, bytearray)):
    18:                 return _decode_imap_bytes(first)
    19:         return str(v)
    20:     except Exception:
    21:         return str(v)
    22: 
    23: 
    24: import re
    25: 
    26: from dotenv import load_dotenv
    27: 
    28: from utils.logger import logger
    29: 
    30: load_dotenv()
    31: 
    32: 
    33: def detect_all_mail_folder() -> str:
    34:     """
    35:     自動偵測 Gmail 中的 All Mail 資料夾名稱，支援中英文、UTF7 編碼格式。
    36: 
    37:     若找不到，預設回傳 'INBOX' 作為 fallback。
    38: 
    39:     回傳:
    40:         str: Gmail 中的 All Mail 資料夾名稱（或 INBOX）
    41:     """
    42:     imap_host = os.getenv("IMAP_HOST")
    43:     imap_user = os.getenv("IMAP_USER")
    44:     imap_pass = os.getenv("IMAP_PASS")
    45: 
    46:     if not imap_host or not imap_user or not imap_pass:
    47:         logger.warning("[IMAP] 無法建立連線，環境變數缺漏，使用預設 INBOX")
    48:         return "INBOX"
    49: 
    50:     try:
    51:         with imaplib.IMAP4_SSL(imap_host) as imap:
    52:             imap.login(imap_user, imap_pass)
    53:             status, mailboxes = imap.list()
    54:             if status != "OK":
    55:                 logger.warning("[IMAP] 無法列出 Gmail 資料夾，使用預設 INBOX")
    56:                 return "INBOX"
    57: 
    58:             for line in mailboxes:
    59:                 parts = _decode_imap_bytes(line).split(' "/" ')
    60:                 if len(parts) != 2:
    61:                     continue
    62:                 _, name = parts
    63:                 if re.search(r"All Mail|所有郵件|&UWiQ6JD1TvY-", name, re.IGNORECASE):
    64:                     folder = name.strip().strip('"')
    65:                     logger.info(f"[IMAP] 偵測到 All Mail 資料夾：{folder}")
    66:                     return folder
    67: 
    68:             logger.warning("[IMAP] 找不到 All Mail，使用預設 INBOX")
    69:             return "INBOX"
    70: 
    71:     except Exception as e:
    72:         logger.warning(f"[IMAP] 連線失敗（fallback INBOX）：{e}")
    73:         return "INBOX"
--------------------------------------------------------------------------------
END FILE    src_lowcov/src/smart_mail_agent/utils/imap_folder_detector.py
================================================================================
================================================================================
BEGIN FILE  src_lowcov/src/smart_mail_agent/utils/imap_login.py  (670 bytes)
TAGS: legacy_candidate=no | sys_path_hack=no | duplicate_basename=no
--------------------------------------------------------------------------------
     1: from __future__ import annotations
     2: 
     3: import imaplib
     4: import os
     5: 
     6: from dotenv import load_dotenv
     7: 
     8: 
     9: def get_imap():
    10:     load_dotenv(dotenv_path=".env", override=True)
    11:     host = os.getenv("IMAP_HOST", "imap.gmail.com").strip()
    12:     user = os.getenv("IMAP_USER", "").strip()
    13:     pwd = os.getenv("IMAP_PASS", "").strip()
    14: 
    15:     if not user or not pwd:
    16:         raise RuntimeError(f"IMAP_USER/IMAP_PASS 缺失（user={bool(user)}, pass_len={len(pwd)})")
    17: 
    18:     # 開啟 debug 方便看到 LOGIN 是否為兩個參數
    19:     imaplib.Debug = int(os.getenv("IMAP_DEBUG", "0"))
    20:     imap = imaplib.IMAP4_SSL(host, 993)
    21:     imap.login(user, pwd)  # 這裡一定是兩個參數
    22:     return imap
--------------------------------------------------------------------------------
END FILE    src_lowcov/src/smart_mail_agent/utils/imap_login.py
================================================================================
================================================================================
BEGIN FILE  src_lowcov/src/smart_mail_agent/utils/jsonlog.py  (2691 bytes)
TAGS: legacy_candidate=no | sys_path_hack=no | duplicate_basename=no
--------------------------------------------------------------------------------
     1: from __future__ import annotations
     2: 
     3: import datetime as dt
     4: import json
     5: import os
     6: 
     7: #!/usr/bin/env python3
     8: from pathlib import Path
     9: from typing import Any
    10: 
    11: 
    12: def _log_dir() -> Path:
    13:     d = Path(os.getenv("SMA_LOG_DIR", "logs"))
    14:     d.mkdir(parents=True, exist_ok=True)
    15:     return d
    16: 
    17: 
    18: def _jsonable(x: Any):
    19:     try:
    20:         json.dumps(x)
    21:         return x
    22:     except Exception:
    23:         try:
    24:             return str(x)
    25:         except Exception:
    26:             return "<unserializable>"
    27: 
    28: 
    29: def _to_dict(obj: Any) -> dict[str, Any]:
    30:     if isinstance(obj, dict):
    31:         return obj
    32:     for attr in ("model_dump", "dict"):
    33:         fn = getattr(obj, attr, None)
    34:         if callable(fn):
    35:             try:
    36:                 return fn(by_alias=True) if attr == "model_dump" else fn()
    37:             except Exception:
    38:                 pass
    39:     return {"repr": repr(obj)}
    40: 
    41: 
    42: def log_event(result: Any, request: dict[str, Any] | None = None) -> str:
    43:     """Never-throw JSONL logger. Also sets result['logged_path'] when possible."""
    44:     try:
    45:         p = _log_dir() / f"sma-{dt.datetime.now():%Y%m%d}.jsonl"
    46:         rd = _to_dict(result)
    47:         row = {
    48:             "ts": dt.datetime.now().isoformat(timespec="seconds"),
    49:             "level": "INFO",
    50:             "action_name": rd.get("action_name"),
    51:             "ok": bool(rd.get("ok", True)),
    52:             "code": rd.get("code", "OK"),
    53:             "request_id": rd.get("request_id"),
    54:             "intent": rd.get("intent"),
    55:             "confidence": rd.get("confidence"),
    56:             "duration_ms": rd.get("duration_ms") or rd.get("spent_ms"),
    57:             "dry_run": rd.get("dry_run"),
    58:             "warnings": rd.get("warnings") or [],
    59:         }
    60:         if isinstance(request, dict):
    61:             row["req_subject"] = request.get("subject")
    62:             row["req_from"] = request.get("from")
    63:         with p.open("a", encoding="utf-8") as f:
    64:             f.write(json.dumps({k: _jsonable(v) for k, v in row.items()}, ensure_ascii=False) + "\n")
    65:         try:
    66:             if isinstance(result, dict):
    67:                 result["logged_path"] = str(p)
    68:         except Exception:
    69:             pass
    70:         return str(p)
    71:     except Exception as e:
    72:         try:
    73:             dbg = _log_dir() / "log_event_error.txt"
    74:             dbg.write_text(
    75:                 (dbg.read_text(encoding="utf-8") if dbg.exists() else "") + f"[{dt.datetime.now().isoformat(timespec='seconds')}] {type(e).__name__}: {e}\n",
    76:                 encoding="utf-8",
    77:             )
    78:         except Exception:
    79:             pass
    80:         try:
    81:             if isinstance(result, dict):
    82:                 result.setdefault("warnings", []).append("log_write_failed")
    83:         except Exception:
    84:             pass
    85:         return ""
--------------------------------------------------------------------------------
END FILE    src_lowcov/src/smart_mail_agent/utils/jsonlog.py
================================================================================
================================================================================
BEGIN FILE  src_lowcov/src/smart_mail_agent/utils/log_writer.py  (254 bytes)
TAGS: legacy_candidate=no | sys_path_hack=no | duplicate_basename=no
--------------------------------------------------------------------------------
     1: from __future__ import annotations
     2: 
     3: #!/usr/bin/env python3
     4: # 檔案位置：src/utils/log_writer.py
     5: # 模組用途：向後相容封裝（統一轉用 src.log_writer.log_to_db）
     6: from src.log_writer import log_to_db  # re-export
     7: 
     8: __all__ = ["log_to_db"]
--------------------------------------------------------------------------------
END FILE    src_lowcov/src/smart_mail_agent/utils/log_writer.py
================================================================================
================================================================================
BEGIN FILE  src_lowcov/src/smart_mail_agent/utils/logging_setup.py  (1326 bytes)
TAGS: legacy_candidate=no | sys_path_hack=no | duplicate_basename=no
--------------------------------------------------------------------------------
     1: from __future__ import annotations
     2: 
     3: import json
     4: import logging
     5: import os
     6: import sys
     7: import time
     8: 
     9: 
    10: class JsonFormatter(logging.Formatter):
    11:     def format(self, record: logging.LogRecord) -> str:
    12:         base = {
    13:             "level": record.levelname,
    14:             "name": record.name,
    15:             "msg": record.getMessage(),
    16:             "time": int(time.time() * 1000),
    17:         }
    18:         # 附加 extra
    19:         for k, v in getattr(record, "__dict__", {}).items():
    20:             if k not in base and k not in (
    21:                 "args",
    22:                 "exc_info",
    23:                 "exc_text",
    24:                 "stack_info",
    25:                 "msg",
    26:                 "message",
    27:             ):
    28:                 try:
    29:                     json.dumps({k: v})
    30:                     base[k] = v
    31:                 except Exception:
    32:                     pass
    33:         if record.exc_info:
    34:             base["exc_type"] = str(record.exc_info[0].__name__)
    35:         return json.dumps(base, ensure_ascii=False)
    36: 
    37: 
    38: def setup_logging(level: str | int = None) -> logging.Logger:
    39:     lvl = level or os.environ.get("LOG_LEVEL", "INFO")
    40:     logger = logging.getLogger("sma")
    41:     if not logger.handlers:
    42:         h = logging.StreamHandler(stream=sys.stdout)
    43:         h.setFormatter(JsonFormatter())
    44:         logger.addHandler(h)
    45:     logger.setLevel(lvl)
    46:     return logger
--------------------------------------------------------------------------------
END FILE    src_lowcov/src/smart_mail_agent/utils/logging_setup.py
================================================================================
================================================================================
BEGIN FILE  src_lowcov/src/smart_mail_agent/utils/pdf_generator.py  (2702 bytes)
TAGS: legacy_candidate=no | sys_path_hack=no | duplicate_basename=no
--------------------------------------------------------------------------------
     1: import os
     2: 
     3: #!/usr/bin/env python3
     4: # 檔案位置：src/utils/pdf_generator.py
     5: # 模組用途：產出異動紀錄 PDF，支援中文顯示與系統字型錯誤備援處理
     6: from datetime import datetime
     7: from pathlib import Path
     8: 
     9: from dotenv import load_dotenv
    10: from reportlab.lib.pagesizes import A4
    11: from reportlab.pdfbase import pdfmetrics
    12: from reportlab.pdfbase.ttfonts import TTFont
    13: from reportlab.pdfgen import canvas
    14: 
    15: from utils.logger import logger
    16: 
    17: load_dotenv()
    18: 
    19: # 讀取字型路徑
    20: FONT_PATH = os.getenv("QUOTE_FONT_PATH", "/usr/share/fonts/truetype/noto/NotoSansTC-Regular.otf")
    21: 
    22: try:
    23:     if not os.path.exists(FONT_PATH):
    24:         raise FileNotFoundError(f"找不到字型檔案：{FONT_PATH}")
    25:     pdfmetrics.registerFont(TTFont("NotoSansTC", FONT_PATH))
    26:     FONT_NAME = "NotoSansTC"
    27:     logger.info("[PDFGenerator] 載入字型成功：%s", FONT_PATH)
    28: except Exception as e:
    29:     FONT_NAME = "Helvetica"
    30:     logger.warning("[PDFGenerator] 使用預設字型 Helvetica，原因：%s", str(e))
    31: 
    32: 
    33: def generate_info_change_pdf(info_dict: dict, save_path: str):
    34:     """
    35:     根據使用者異動資訊產出正式 PDF 檔案
    36: 
    37:     :param info_dict: 異動欄位與新值的 dict
    38:     :param save_path: 儲存的 PDF 完整路徑
    39:     """
    40:     try:
    41:         Path(save_path).parent.mkdir(parents=True, exist_ok=True)
    42:         c = canvas.Canvas(save_path, pagesize=A4)
    43:         width, height = A4
    44: 
    45:         margin = 50
    46:         line_height = 24
    47:         y = height - margin
    48: 
    49:         # 標題
    50:         c.setFont(FONT_NAME, 18)
    51:         c.drawString(margin, y, "客戶資料異動紀錄")
    52:         y -= line_height * 2
    53: 
    54:         # 系統說明
    55:         c.setFont(FONT_NAME, 12)
    56:         c.drawString(margin, y, "以下為客戶主動申請之資料異動內容，已由 Smart-Mail-Agent 系統自動紀錄：")
    57:         y -= line_height * 2
    58: 
    59:         # 異動欄位列出
    60:         for key, value in info_dict.items():
    61:             if value.strip():
    62:                 c.drawString(margin, y, f"■ {key.strip()}：{value.strip()}")
    63:                 y -= line_height
    64: 
    65:         y -= line_height
    66: 
    67:         # 系統資訊
    68:         c.setFont(FONT_NAME, 11)
    69:         c.drawString(margin, y, f"異動提交時間：{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
    70:         y -= line_height
    71:         c.drawString(margin, y, "系統產出：Smart-Mail-Agent")
    72:         y -= line_height * 2
    73: 
    74:         # 備註
    75:         c.setFont(FONT_NAME, 10)
    76:         c.drawString(margin, y, "※ 此紀錄由系統自動產生，若資訊有誤請回覆本信通知更正。")
    77: 
    78:         c.save()
    79:         logger.info("[PDFGenerator] PDF 已產出：%s", save_path)
    80: 
    81:     except Exception as e:
    82:         logger.error("[PDFGenerator] PDF 產出失敗：%s", str(e))
--------------------------------------------------------------------------------
END FILE    src_lowcov/src/smart_mail_agent/utils/pdf_generator.py
================================================================================
================================================================================
BEGIN FILE  src_lowcov/src/smart_mail_agent/utils/pdf_safe.py  (4863 bytes)
TAGS: legacy_candidate=no | sys_path_hack=no | duplicate_basename=no
--------------------------------------------------------------------------------
     1: from __future__ import annotations
     2: 
     3: import datetime as dt
     4: from collections.abc import Sequence
     5: 
     6: # -*- coding: utf-8 -*-
     7: from pathlib import Path
     8: 
     9: 
    10: def _find_font(candidates: Sequence[str]) -> Path | None:
    11:     extra = [
    12:         "/usr/share/fonts/opentype/noto/NotoSansCJKTC-Regular.otf",
    13:         "/usr/share/fonts/opentype/noto/NotoSansCJK-Regular.ttc",
    14:         "/System/Library/Fonts/PingFang.ttc",
    15:         "/Library/Fonts/Songti.ttc",
    16:     ]
    17:     for c in list(candidates) + extra:
    18:         p = Path(c)
    19:         if p.exists():
    20:             return p
    21:     return None
    22: 
    23: 
    24: def _escape_pdf_text(s: str) -> str:
    25:     # 僅保證 PDF 語法合法；非 Latin-1 字元可能顯示成方框（不影響測試與檔案有效性）
    26:     s = s.replace("\\", "\\\\").replace("(", "\\(").replace(")", "\\)")
    27:     return "".join(ch if 32 <= ord(ch) <= 126 else "?" for ch in s)
    28: 
    29: 
    30: def _write_minimal_pdf(lines: list[str], out_path: Path) -> Path:
    31:     # 產生一份 *有效* 的極簡 PDF（1 頁，內建 Helvetica 字型）
    32:     # 版面：A4 (595 x 842 points)，字體 12pt，行距 14pt，自 (72, 800) 起逐行往下
    33:     header = b"%PDF-1.4\n%\xe2\xe3\xcf\xd3\n"
    34:     # 內容串
    35:     content_lines = ["BT", "/F1 12 Tf", "14 TL", "72 800 Td"]
    36:     for ln in lines:
    37:         content_lines.append(f"({_escape_pdf_text(ln)}) Tj")
    38:         content_lines.append("T*")
    39:     content_lines.append("ET")
    40:     content_str = "\n".join(content_lines) + "\n"
    41:     content_bytes = content_str.encode("latin-1")
    42: 
    43:     # 物件組裝
    44:     objs = []
    45: 
    46:     def add_obj(body: bytes) -> int:
    47:         offset = sum(len(x) for x in objs) + len(header)
    48:         objs.append(body)
    49:         return offset
    50: 
    51:     xref = []
    52:     # 1: Catalog
    53:     xref.append(add_obj(b"1 0 obj\n<< /Type /Catalog /Pages 2 0 R >>\nendobj\n"))
    54:     # 2: Pages
    55:     xref.append(add_obj(b"2 0 obj\n<< /Type /Pages /Kids [3 0 R] /Count 1 >>\nendobj\n"))
    56:     # 3: Page
    57:     xref.append(add_obj(b"3 0 obj\n<< /Type /Page /Parent 2 0 R /MediaBox [0 0 595 842] /Contents 4 0 R /Resources << /Font << /F1 5 0 R >> >> >>\nendobj\n"))
    58:     # 4: Contents (stream)
    59:     stream = b"4 0 obj\n<< /Length " + str(len(content_bytes)).encode("ascii") + b" >>\nstream\n" + content_bytes + b"endstream\nendobj\n"
    60:     xref.append(add_obj(stream))
    61:     # 5: Font
    62:     xref.append(add_obj(b"5 0 obj\n<< /Type /Font /Subtype /Type1 /BaseFont /Helvetica >>\nendobj\n"))
    63: 
    64:     # xref & trailer
    65:     xref_start = len(header) + sum(len(x) for x in objs)
    66:     xref_table = [b"xref\n0 6\n", b"0000000000 65535 f \n"]
    67:     for off in xref:
    68:         xref_table.append((f"{off:010d} 00000 n \n").encode("ascii"))
    69:     xref_bytes = b"".join(xref_table)
    70:     trailer = b"trailer\n<< /Size 6 /Root 1 0 R >>\nstartxref\n" + str(xref_start).encode("ascii") + b"\n%%EOF\n"
    71: 
    72:     out_path.parent.mkdir(parents=True, exist_ok=True)
    73:     with out_path.open("wb") as f:
    74:         f.write(header)
    75:         for o in objs:
    76:             f.write(o)
    77:         f.write(xref_bytes)
    78:         f.write(trailer)
    79:     return out_path
    80: 
    81: 
    82: def write_pdf_or_txt(
    83:     lines: list[str],
    84:     out_dir: Path = Path("data/output"),
    85:     basename: str = "attachment",
    86:     font_candidates: Sequence[str] | None = None,
    87: ) -> Path:
    88:     out_dir.mkdir(parents=True, exist_ok=True)
    89:     ts = dt.datetime.now().strftime("%Y%m%d_%H%M%S")
    90:     font_candidates = font_candidates or [
    91:         "assets/fonts/SourceHanSansTC-Regular.otf",
    92:         "assets/fonts/NotoSansTC-Regular.ttf",
    93:     ]
    94:     font_path = _find_font(font_candidates)
    95:     try:
    96:         from reportlab.lib.pagesizes import A4
    97:         from reportlab.lib.units import mm
    98:         from reportlab.pdfbase import pdfmetrics
    99:         from reportlab.pdfbase.ttfonts import TTFont
   100:         from reportlab.pdfgen import canvas
   101: 
   102:         pdf_path = out_dir / f"{basename}_{ts}.pdf"
   103:         c = canvas.Canvas(str(pdf_path), pagesize=A4)
   104: 
   105:         font_name = "Helvetica"
   106:         if font_path and font_path.suffix.lower() in {".ttf", ".otf"}:
   107:             try:
   108:                 pdfmetrics.registerFont(TTFont("CJK", str(font_path)))
   109:                 font_name = "CJK"
   110:             except Exception:
   111:                 pass
   112: 
   113:         c.setFont(font_name, 12)
   114:         width, height = A4
   115:         x, y = 20 * mm, height - 20 * mm
   116:         for line in lines:
   117:             c.drawString(x, y, line)
   118:             y -= 8 * mm
   119:             if y < 20 * mm:
   120:                 c.showPage()
   121:                 c.setFont(font_name, 12)
   122:                 y = height - 20 * mm
   123:         c.save()
   124:         return pdf_path
   125:     except Exception:
   126:         # 無 reportlab：用極簡 PDF 生成器寫出 .pdf
   127:         pdf_path = out_dir / f"{basename}_{ts}.pdf"
   128:         try:
   129:             return _write_minimal_pdf(lines, pdf_path)
   130:         except Exception:
   131:             # 極端狀況才降級 .txt
   132:             txt_path = out_dir / f"{basename}_{ts}.txt"
   133:             txt_path.write_text("\\n".join(lines), encoding="utf-8")
   134:             return txt_path
--------------------------------------------------------------------------------
END FILE    src_lowcov/src/smart_mail_agent/utils/pdf_safe.py
================================================================================
================================================================================
BEGIN FILE  src_lowcov/src/smart_mail_agent/utils/priority_evaluator.py  (2486 bytes)
TAGS: legacy_candidate=no | sys_path_hack=no | duplicate_basename=no
--------------------------------------------------------------------------------
     1: #!/usr/bin/env python3
     2: # 檔案位置：src/utils/priority_evaluator.py
     3: # 模組用途：根據主旨、內容、分類與信心分數，評估技術工單的優先等級
     4: 
     5: from typing import Literal
     6: 
     7: from utils.logger import logger
     8: 
     9: PriorityLevel = Literal["high", "medium", "low"]
    10: 
    11: # 高風險關鍵字（若命中則為 high 優先）
    12: HIGH_RISK_KEYWORDS = [
    13:     "系統故障",
    14:     "服務中斷",
    15:     "登入失敗",
    16:     "掛掉",
    17:     "嚴重錯誤",
    18:     "資料遺失",
    19:     "斷線",
    20:     "無法連線",
    21: ]
    22: 
    23: 
    24: def contains_critical_keywords(text: str) -> bool:
    25:     """
    26:     判斷文字中是否包含高風險關鍵字
    27: 
    28:     :param text: 主旨或內文組合文字（小寫）
    29:     :return: 是否命中關鍵字
    30:     """
    31:     return any(kw.lower() in text for kw in HIGH_RISK_KEYWORDS)
    32: 
    33: 
    34: def evaluate_priority(
    35:     subject: str,
    36:     content: str,
    37:     sender: str | None = None,
    38:     category: str | None = None,
    39:     confidence: float = 0.0,
    40: ) -> PriorityLevel:
    41:     """
    42:     根據分類與信心值評估工單優先順序
    43: 
    44:     規則：
    45:         - 命中高風險關鍵字 ➜ high
    46:         - 技術支援 + 信心 > 0.8 ➜ high
    47:         - 投訴與抱怨 ➜ medium
    48:         - 詢問流程 ➜ low
    49:         - 其他 ➜ 預設 medium
    50: 
    51:     :param subject: 信件主旨
    52:     :param content: 信件內文
    53:     :param sender: 寄件人（可選）
    54:     :param category: 分類標籤（可選）
    55:     :param confidence: 分類信心值（可選）
    56:     :return: 優先等級（high, medium, low）
    57:     """
    58:     try:
    59:         combined = f"{subject} {content}".lower()
    60: 
    61:         if contains_critical_keywords(combined):
    62:             logger.info("[priority_evaluator] 命中高風險詞 ➜ 優先等級：high")
    63:             return "high"
    64: 
    65:         if category == "請求技術支援" and confidence >= 0.8:
    66:             logger.info("[priority_evaluator] 技術支援 + 高信心 ➜ 優先等級：high")
    67:             return "high"
    68: 
    69:         if category == "投訴與抱怨":
    70:             logger.info("[priority_evaluator] 分類為投訴與抱怨 ➜ 優先等級：medium")
    71:             return "medium"
    72: 
    73:         if category == "詢問流程或規則":
    74:             logger.info("[priority_evaluator] 分類為詢問流程 ➜ 優先等級：low")
    75:             return "low"
    76: 
    77:         logger.info("[priority_evaluator] 未命中條件 ➜ 優先等級：medium")
    78:         return "medium"
    79: 
    80:     except Exception as e:
    81:         logger.error(f"[priority_evaluator] 優先順序判定失敗：{e}")
    82:         return "medium"
--------------------------------------------------------------------------------
END FILE    src_lowcov/src/smart_mail_agent/utils/priority_evaluator.py
================================================================================
================================================================================
BEGIN FILE  src_lowcov/src/smart_mail_agent/utils/rag_reply.py  (2384 bytes)
TAGS: legacy_candidate=no | sys_path_hack=no | duplicate_basename=no
--------------------------------------------------------------------------------
     1: import os
     2: 
     3: #!/usr/bin/env python3
     4: # 檔案位置：src/utils/rag_reply.py
     5: # 模組用途：使用 GPT 模型 + FAQ 知識庫進行回應生成（中文 Retrieval-Augmented Generation）
     6: from dotenv import load_dotenv
     7: from openai import OpenAI, OpenAIError
     8: 
     9: from utils.logger import logger
    10: 
    11: load_dotenv()
    12: 
    13: 
    14: def load_faq_knowledge(faq_path: str) -> str:
    15:     """
    16:     讀取 FAQ 知識庫文字內容
    17: 
    18:     :param faq_path: FAQ 文字檔案路徑
    19:     :return: FAQ 資料字串
    20:     """
    21:     if not os.path.exists(faq_path):
    22:         logger.warning(f"[rag_reply] 找不到 FAQ 檔案：{faq_path}")
    23:         return ""
    24: 
    25:     try:
    26:         with open(faq_path, encoding="utf-8") as f:
    27:             return f.read()
    28:     except Exception as e:
    29:         logger.error(f"[rag_reply] FAQ 讀取錯誤：{e}")
    30:         return ""
    31: 
    32: 
    33: def generate_rag_reply(query: str, faq_path: str, model: str = "gpt-3.5-turbo") -> str:
    34:     """
    35:     根據 FAQ 資料與提問內容產生回覆內容
    36: 
    37:     :param query: 使用者提出的問題
    38:     :param faq_path: FAQ 資料檔案路徑
    39:     :param model: 使用之 GPT 模型名稱
    40:     :return: 回覆文字
    41:     """
    42:     try:
    43:         faq = load_faq_knowledge(faq_path)
    44:         if not faq:
    45:             return "很抱歉，目前無法提供對應資料。"
    46: 
    47:         prompt = f"你是客服助理，請根據以下 FAQ 資訊與提問內容，提供簡潔清楚的回覆：\n\n【FAQ】\n{faq}\n\n【提問】\n{query}\n\n請以繁體中文回答，回覆不可重複 FAQ 原文，請使用簡明語氣說明即可。"
    48: 
    49:         client = OpenAI(api_key=os.getenv("OPENAI_API_KEY"))
    50:         response = client.chat.completions.create(
    51:             model=model,
    52:             messages=[
    53:                 {"role": "system", "content": "你是客服 AI 專員，回答使用者關於流程與規則的問題。"},
    54:                 {"role": "user", "content": prompt},
    55:             ],
    56:             max_tokens=400,
    57:             temperature=0.7,
    58:         )
    59: 
    60:         answer = response.choices[0].message.content.strip()
    61:         logger.info("[rag_reply] 回覆產生成功")
    62:         return answer
    63: 
    64:     except OpenAIError as e:
    65:         logger.error(f"[rag_reply] OpenAI 回應錯誤：{e}")
    66:         return "目前系統繁忙，請稍後再試。"
    67: 
    68:     except Exception as e:
    69:         logger.error(f"[rag_reply] 回覆產生異常：{e}")
    70:         return "處理過程發生錯誤，請稍後再試。"
--------------------------------------------------------------------------------
END FILE    src_lowcov/src/smart_mail_agent/utils/rag_reply.py
================================================================================
================================================================================
BEGIN FILE  src_lowcov/src/smart_mail_agent/utils/templater.py  (1128 bytes)
TAGS: legacy_candidate=no | sys_path_hack=no | duplicate_basename=no
--------------------------------------------------------------------------------
     1: from __future__ import annotations
     2: 
     3: #!/usr/bin/env python3
     4: from pathlib import Path
     5: 
     6: from jinja2 import Environment, FileSystemLoader, StrictUndefined
     7: 
     8: 
     9: def _template_dirs() -> list[str]:
    10:     here = Path(__file__).resolve()
    11:     roots = [
    12:         here.parents[2],  # repo root
    13:         here.parents[1],  # src/
    14:         Path.cwd(),
    15:     ]
    16:     dirs = []
    17:     for r in roots:
    18:         for p in [r / "templates", r / "src" / "templates", r / "src" / "src" / "templates"]:
    19:             if p.exists():
    20:                 dirs.append(str(p))
    21:     seen, out = set(), []
    22:     for d in dirs:
    23:         if d not in seen:
    24:             out.append(d)
    25:             seen.add(d)
    26:     return out
    27: 
    28: 
    29: _env: Environment | None = None
    30: 
    31: 
    32: def get_env() -> Environment:
    33:     global _env
    34:     if _env is None:
    35:         _env = Environment(
    36:             loader=FileSystemLoader(_template_dirs()),
    37:             undefined=StrictUndefined,
    38:             autoescape=False,
    39:             trim_blocks=True,
    40:             lstrip_blocks=True,
    41:         )
    42:     return _env
    43: 
    44: 
    45: def render(template_name: str, context: dict) -> str:
    46:     return get_env().get_template(template_name).render(**context)
--------------------------------------------------------------------------------
END FILE    src_lowcov/src/smart_mail_agent/utils/templater.py
================================================================================
================================================================================
BEGIN FILE  src_lowcov/src/smart_mail_agent/utils/tracing.py  (460 bytes)
TAGS: legacy_candidate=no | sys_path_hack=no | duplicate_basename=no
--------------------------------------------------------------------------------
     1: from __future__ import annotations
     2: 
     3: import json
     4: import time
     5: from pathlib import Path
     6: from typing import Any
     7: 
     8: 
     9: def trace_decision(root: Path, name: str, payload: dict[str, Any]) -> Path:
    10:     out_dir = root / "data" / "output" / "traces"
    11:     out_dir.mkdir(parents=True, exist_ok=True)
    12:     ts = time.strftime("%Y%m%d_%H%M%S")
    13:     p = out_dir / f"{ts}_{name}.json"
    14:     p.write_text(json.dumps(payload, ensure_ascii=False, indent=2), encoding="utf-8")
    15:     return p
--------------------------------------------------------------------------------
END FILE    src_lowcov/src/smart_mail_agent/utils/tracing.py
================================================================================
================================================================================
BEGIN FILE  src_lowcov/src/smart_mail_agent/utils/validators.py  (1369 bytes)
TAGS: legacy_candidate=no | sys_path_hack=no | duplicate_basename=no
--------------------------------------------------------------------------------
     1: from __future__ import annotations
     2: 
     3: import re
     4: from collections.abc import Iterable
     5: 
     6: try:
     7:     from email_validator import EmailNotValidError, validate_email  # provided by email-validator
     8: except Exception:
     9:     validate_email = None
    10:     EmailNotValidError = Exception
    11: 
    12: MAX_SUBJECT = 200
    13: MAX_CONTENT = 20000
    14: ATTACH_BAD_CHARS = re.compile(r'[<>:"/\\|?*\x00-\x1F]')
    15: 
    16: 
    17: def check_sender(sender: str) -> tuple[bool, str]:
    18:     if not sender or "@" not in sender:
    19:         return False, "sender_missing_or_invalid"
    20:     if validate_email:
    21:         try:
    22:             validate_email(sender, check_deliverability=False)
    23:         except EmailNotValidError:
    24:             return False, "sender_invalid_format"
    25:     return True, "OK"
    26: 
    27: 
    28: def check_subject(subject: str) -> tuple[bool, str]:
    29:     if not subject:
    30:         return False, "subject_missing"
    31:     if len(subject) > MAX_SUBJECT:
    32:         return False, "subject_too_long"
    33:     return True, "OK"
    34: 
    35: 
    36: def check_content(content: str) -> tuple[bool, str]:
    37:     if not content or not content.strip():
    38:         return False, "content_empty"
    39:     if len(content) > MAX_CONTENT:
    40:         return False, "content_too_long"
    41:     return True, "OK"
    42: 
    43: 
    44: def check_attachments(names: Iterable[str]) -> tuple[bool, str]:
    45:     for n in names or []:
    46:         if ATTACH_BAD_CHARS.search(n):
    47:             return False, "attachment_name_illegal_chars"
    48:     return True, "OK"
--------------------------------------------------------------------------------
END FILE    src_lowcov/src/smart_mail_agent/utils/validators.py
================================================================================
================================================================================
BEGIN FILE  src_lowcov/src/spam/feature_extractor.py  (280 bytes)
TAGS: legacy_candidate=no | sys_path_hack=no | duplicate_basename=no
--------------------------------------------------------------------------------
     1: # Auto-generated compat proxy: src/spam/feature_extractor.py
     2: from importlib import import_module as _imp
     3: 
     4: _mod = _imp("smart_mail_agent.spam.feature_extractor")
     5: # re-export public names
     6: for _k in dir(_mod):
     7:     if not _k.startswith("_"):
     8:         globals()[_k] = getattr(_mod, _k)
--------------------------------------------------------------------------------
END FILE    src_lowcov/src/spam/feature_extractor.py
================================================================================
================================================================================
BEGIN FILE  src_lowcov/src/spam/ml_spam_classifier.py  (282 bytes)
TAGS: legacy_candidate=no | sys_path_hack=no | duplicate_basename=no
--------------------------------------------------------------------------------
     1: # Auto-generated compat proxy: src/spam/ml_spam_classifier.py
     2: from importlib import import_module as _imp
     3: 
     4: _mod = _imp("smart_mail_agent.spam.ml_spam_classifier")
     5: # re-export public names
     6: for _k in dir(_mod):
     7:     if not _k.startswith("_"):
     8:         globals()[_k] = getattr(_mod, _k)
--------------------------------------------------------------------------------
END FILE    src_lowcov/src/spam/ml_spam_classifier.py
================================================================================
================================================================================
BEGIN FILE  src_lowcov/src/spam/rule_filter.py  (268 bytes)
TAGS: legacy_candidate=no | sys_path_hack=no | duplicate_basename=no
--------------------------------------------------------------------------------
     1: # Auto-generated compat proxy: src/spam/rule_filter.py
     2: from importlib import import_module as _imp
     3: 
     4: _mod = _imp("smart_mail_agent.spam.rule_filter")
     5: # re-export public names
     6: for _k in dir(_mod):
     7:     if not _k.startswith("_"):
     8:         globals()[_k] = getattr(_mod, _k)
--------------------------------------------------------------------------------
END FILE    src_lowcov/src/spam/rule_filter.py
================================================================================
================================================================================
BEGIN FILE  src_lowcov/src/spam/rules.py  (256 bytes)
TAGS: legacy_candidate=no | sys_path_hack=no | duplicate_basename=no
--------------------------------------------------------------------------------
     1: # Auto-generated compat proxy: src/spam/rules.py
     2: from importlib import import_module as _imp
     3: 
     4: _mod = _imp("smart_mail_agent.spam.rules")
     5: # re-export public names
     6: for _k in dir(_mod):
     7:     if not _k.startswith("_"):
     8:         globals()[_k] = getattr(_mod, _k)
--------------------------------------------------------------------------------
END FILE    src_lowcov/src/spam/rules.py
================================================================================
================================================================================
BEGIN FILE  src_lowcov/src/support_ticket.py  (5699 bytes)
TAGS: legacy_candidate=no | sys_path_hack=no | duplicate_basename=no
--------------------------------------------------------------------------------
     1: #!/usr/bin/env python3
     2: # 檔案位置：src/support_ticket.py
     3: # 模組用途：技術支援工單管理（建立 / 查詢 / 更新），自動標定優先等級
     4: 
     5: import argparse
     6: import sqlite3
     7: from datetime import datetime
     8: from pathlib import Path
     9: 
    10: from utils.logger import logger
    11: 
    12: try:
    13:     from utils.priority_evaluator import evaluate_priority
    14: except ImportError:
    15: 
    16:     def evaluate_priority(*args, **kwargs):
    17:         logger.warning("未載入 priority_evaluator 模組，預設優先等級為 normal")
    18:         return "normal"
    19: 
    20: 
    21: DB_PATH = "data/tickets.db"
    22: TABLE = "support_tickets"
    23: 
    24: 
    25: def init_db():
    26:     Path("data").mkdir(parents=True, exist_ok=True)
    27:     with sqlite3.connect(DB_PATH) as conn:
    28:         conn.execute(
    29:             f"""
    30:             CREATE TABLE IF NOT EXISTS {TABLE} (
    31:                 id INTEGER PRIMARY KEY AUTOINCREMENT,
    32:                 subject TEXT NOT NULL,
    33:                 content TEXT NOT NULL,
    34:                 summary TEXT,
    35:                 sender TEXT,
    36:                 category TEXT,
    37:                 confidence REAL,
    38:                 created_at TEXT,
    39:                 updated_at TEXT,
    40:                 status TEXT,
    41:                 priority TEXT
    42:             )
    43:         """
    44:         )
    45:         conn.commit()
    46: 
    47: 
    48: def create_ticket(subject, content, summary="", sender=None, category=None, confidence=None):
    49:     init_db()
    50:     subject = subject or "(未填寫)"
    51:     content = content or ""
    52:     summary = summary or ""
    53:     sender = sender or "unknown"
    54:     category = category or "未分類"
    55:     confidence = float(confidence or 0)
    56: 
    57:     try:
    58:         priority = evaluate_priority(subject, content, sender, category, confidence)
    59:     except Exception as e:
    60:         logger.warning("evaluate_priority 失敗，預設為 normal：%s", e)
    61:         priority = "normal"
    62: 
    63:     now = datetime.utcnow().isoformat()
    64:     with sqlite3.connect(DB_PATH) as conn:
    65:         conn.execute(
    66:             f"""
    67:             INSERT INTO {TABLE}
    68:             (subject, content, summary, sender, category, confidence,
    69:              created_at, updated_at, status, priority)
    70:             VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
    71:         """,
    72:             (
    73:                 subject,
    74:                 content,
    75:                 summary,
    76:                 sender,
    77:                 category,
    78:                 confidence,
    79:                 now,
    80:                 now,
    81:                 "pending",
    82:                 priority,
    83:             ),
    84:         )
    85:         conn.commit()
    86:     logger.info("工單建立成功 [%s] 優先級：%s", subject, priority)
    87: 
    88: 
    89: def list_tickets():
    90:     init_db()
    91:     with sqlite3.connect(DB_PATH) as conn:
    92:         rows = conn.execute(
    93:             f"""
    94:             SELECT id, subject, status, priority, created_at
    95:             FROM {TABLE}
    96:             ORDER BY id DESC
    97:         """
    98:         ).fetchall()
    99: 
   100:     if not rows:
   101:         print("目前尚無工單紀錄")
   102:         return
   103: 
   104:     print("\n=== 最新工單列表 ===")
   105:     for row in rows:
   106:         print(f"[#{row[0]}] [{row[2]}] [{row[3]}] {row[1]} @ {row[4]}")
   107: 
   108: 
   109: def show_ticket(ticket_id: int):
   110:     init_db()
   111:     with sqlite3.connect(DB_PATH) as conn:
   112:         row = conn.execute(f"SELECT * FROM {TABLE} WHERE id=?", (ticket_id,)).fetchone()
   113: 
   114:     if not row:
   115:         print(f"查無工單 ID={ticket_id}")
   116:         return
   117: 
   118:     print(
   119:         f"""
   120: --- 工單詳細內容 ---
   121: ID         : {row[0]}
   122: 主旨       : {row[1]}
   123: 內容       : {row[2]}
   124: 摘要       : {row[3]}
   125: 寄件者     : {row[4]}
   126: 分類       : {row[5]}
   127: 信心分數   : {row[6]:.2f}
   128: 建立時間   : {row[7]}
   129: 更新時間   : {row[8]}
   130: 狀態       : {row[9]}
   131: 優先順序   : {row[10]}
   132: """
   133:     )
   134: 
   135: 
   136: def update_ticket(ticket_id: int, status=None, summary=None):
   137:     updated_fields = []
   138:     now = datetime.utcnow().isoformat()
   139: 
   140:     with sqlite3.connect(DB_PATH) as conn:
   141:         if status:
   142:             conn.execute(f"UPDATE {TABLE} SET status=?, updated_at=? WHERE id=?", (status, now, ticket_id))
   143:             updated_fields.append("狀態")
   144:         if summary:
   145:             conn.execute(f"UPDATE {TABLE} SET summary=?, updated_at=? WHERE id=?", (summary, now, ticket_id))
   146:             updated_fields.append("摘要")
   147:         conn.commit()
   148: 
   149:     if updated_fields:
   150:         logger.info("工單 #%d 已更新欄位：%s", ticket_id, ", ".join(updated_fields))
   151:     else:
   152:         logger.warning("未指定更新欄位")
   153: 
   154: 
   155: def parse_args():
   156:     parser = argparse.ArgumentParser(description="技術支援工單管理 CLI 工具")
   157:     sub = parser.add_subparsers(dest="command", required=True)
   158: 
   159:     p_create = sub.add_parser("create", help="建立新工單")
   160:     p_create.add_argument("--subject", required=True)
   161:     p_create.add_argument("--content", required=True)
   162:     p_create.add_argument("--summary", default="")
   163:     p_create.add_argument("--sender")
   164:     p_create.add_argument("--category")
   165:     p_create.add_argument("--confidence", type=float)
   166: 
   167:     sub.add_parser("list", help="列出所有工單")
   168: 
   169:     p_show = sub.add_parser("show", help="查詢單一工單")
   170:     p_show.add_argument("--id", required=True, type=int)
   171: 
   172:     p_update = sub.add_parser("update", help="更新工單狀態 / 摘要")
   173:     p_update.add_argument("--id", required=True, type=int)
   174:     p_update.add_argument("--status", choices=["pending", "done"])
   175:     p_update.add_argument("--summary")
   176: 
   177:     return parser.parse_args()
   178: 
   179: 
   180: def main():
   181:     args = parse_args()
   182:     if args.command == "create":
   183:         create_ticket(args.subject, args.content, args.summary, args.sender, args.category, args.confidence)
   184:     elif args.command == "list":
   185:         list_tickets()
   186:     elif args.command == "show":
   187:         show_ticket(args.id)
   188:     elif args.command == "update":
   189:         update_ticket(args.id, args.status, args.summary)
   190: 
   191: 
   192: if __name__ == "__main__":
   193:     main()
--------------------------------------------------------------------------------
END FILE    src_lowcov/src/support_ticket.py
================================================================================
================================================================================
BEGIN FILE  src_lowcov/src/train_classifier.py  (1823 bytes)
TAGS: legacy_candidate=no | sys_path_hack=no | duplicate_basename=no
--------------------------------------------------------------------------------
     1: import json
     2: 
     3: from datasets import Dataset
     4: from transformers import (
     5:     AutoModelForSequenceClassification,
     6:     AutoTokenizer,
     7:     Trainer,
     8:     TrainingArguments,
     9: )
    10: 
    11: # 類別對應（順序需與原標籤一致）
    12: LABELS = ["請求技術支援", "申請修改資訊", "詢問流程或規則", "投訴與抱怨", "業務接洽或報價", "其他"]
    13: label2id = {label: i for i, label in enumerate(LABELS)}
    14: id2label = {i: label for i, label in enumerate(LABELS)}
    15: 
    16: # 路徑設定
    17: DATA_PATH = "data/train/emails_train.json"
    18: MODEL_OUT = "model/roberta-zh-checkpoint"
    19: PRETRAINED_MODEL = "bert-base-chinese"
    20: 
    21: # 載入資料
    22: with open(DATA_PATH, encoding="utf-8") as f:
    23:     raw_data = json.load(f)
    24: for row in raw_data:
    25:     row["label"] = label2id[row["label"]]
    26: 
    27: # 建立 Dataset
    28: dataset = Dataset.from_list(raw_data)
    29: 
    30: # 分詞器
    31: tokenizer = AutoTokenizer.from_pretrained(PRETRAINED_MODEL)
    32: 
    33: 
    34: def tokenize(batch):
    35:     return tokenizer(
    36:         batch["subject"] + "\n" + batch["content"],
    37:         truncation=True,
    38:         padding="max_length",
    39:         max_length=256,
    40:     )
    41: 
    42: 
    43: encoded_dataset = dataset.map(tokenize)
    44: 
    45: # 模型初始化
    46: model = AutoModelForSequenceClassification.from_pretrained(PRETRAINED_MODEL, num_labels=len(LABELS), label2id=label2id, id2label=id2label)
    47: 
    48: # 訓練參數
    49: args = TrainingArguments(
    50:     output_dir=MODEL_OUT,
    51:     per_device_train_batch_size=8,
    52:     learning_rate=2e-5,
    53:     num_train_epochs=5,
    54:     logging_dir="./logs",
    55:     logging_steps=10,
    56:     save_strategy="epoch",
    57:     report_to="none",
    58: )
    59: 
    60: # Trainer
    61: trainer = Trainer(model=model, args=args, train_dataset=encoded_dataset, tokenizer=tokenizer)
    62: 
    63: # 開始訓練
    64: trainer.train()  # type: ignore[attr-defined]
    65: 
    66: # 儲存模型與 tokenizer
    67: model.save_pretrained(MODEL_OUT)
    68: tokenizer.save_pretrained(MODEL_OUT)
    69: 
    70: print(f"模型已儲存至：{MODEL_OUT}")
--------------------------------------------------------------------------------
END FILE    src_lowcov/src/train_classifier.py
================================================================================
================================================================================
BEGIN FILE  src_lowcov/src/utils/jsonlog.py  (106 bytes)
TAGS: legacy_candidate=no | sys_path_hack=no | duplicate_basename=no
--------------------------------------------------------------------------------
     1: """Compatibility proxy to canonical implementation."""
     2: 
     3: from utils.jsonlog import log_event  # noqa: F401
--------------------------------------------------------------------------------
END FILE    src_lowcov/src/utils/jsonlog.py
================================================================================
================================================================================
BEGIN FILE  tests/conftest.py  (2319 bytes)
TAGS: legacy_candidate=no | sys_path_hack=no | duplicate_basename=no
--------------------------------------------------------------------------------
     1: #!/usr/bin/env python3
     2: # 檔案位置: tests/conftest.py
     3: # 模組用途: 測試全域設定與標記；提供 --online 旗標與 OFFLINE 環境參數整合
     4: # 兼容 pytest 8+，移除舊的 py.path 介面警告
     5: 
     6: from __future__ import annotations
     7: 
     8: import os
     9: from pathlib import Path
    10: 
    11: import pytest
    12: 
    13: 
    14: def pytest_addoption(parser: pytest.Parser) -> None:
    15:     """
    16:     新增 --online 旗標：顯式要求執行需要對外連線/SMTP 的測試。
    17:     預設值由 OFFLINE 環境變數推導（OFFLINE=0 代表允許 online）。
    18:     """
    19:     parser.addoption(
    20:         "--online",
    21:         action="store_true",
    22:         default=None,
    23:         help="run tests that require network/SMTP. Default derives from OFFLINE env.",
    24:     )
    25: 
    26: 
    27: def _should_run_online(config: pytest.Config) -> bool:
    28:     opt = config.getoption("--online")
    29:     if opt is not None:
    30:         return bool(opt)
    31:     offline_env = os.environ.get("OFFLINE", "1").strip().lower()
    32:     return offline_env in ("0", "false", "no")
    33: 
    34: 
    35: def pytest_configure(config: pytest.Config) -> None:
    36:     """
    37:     註冊標記並保存是否允許執行 online 測試的布林旗標於 config。
    38:     """
    39:     config.addinivalue_line("markers", "online: mark tests that require network/SMTP")
    40:     config._run_online = _should_run_online(config)  # type: ignore[attr-defined]
    41: 
    42: 
    43: def pytest_collection_modifyitems(config: pytest.Config, items: list[pytest.Item]) -> None:
    44:     """
    45:     若未允許 online，則跳過所有 @pytest.mark.online 的測試。
    46:     """
    47:     run_online = getattr(config, "_run_online", False)
    48:     skip_online = pytest.mark.skip(reason="skipping @online tests (use --online or OFFLINE=0)")
    49:     if not run_online:
    50:         for item in items:
    51:             if "online" in item.keywords:
    52:                 item.add_marker(skip_online)
    53: 
    54: 
    55: def pytest_ignore_collect(collection_path: Path, config: pytest.Config) -> bool:  # type: ignore[override]
    56:     """
    57:     以 pathlib.Path 介面判斷忽略目錄（pytest 8+）
    58:     在離線情境下忽略 tests/online 目錄（若存在），作為標記以外的保險。
    59:     """
    60:     run_online = getattr(config, "_run_online", False)
    61:     if not run_online:
    62:         try:
    63:             if any(part == "online" for part in collection_path.parts):
    64:                 return True
    65:         except Exception:
    66:             return False
    67:     return False
--------------------------------------------------------------------------------
END FILE    tests/conftest.py
================================================================================
================================================================================
BEGIN FILE  tests/contracts/conftest.py  (682 bytes)
TAGS: legacy_candidate=no | sys_path_hack=no | duplicate_basename=no
--------------------------------------------------------------------------------
     1: import os
     2: import subprocess
     3: import sys
     4: from pathlib import Path
     5: 
     6: import pytest
     7: 
     8: 
     9: @pytest.fixture(scope="session", autouse=True)
    10: def _ensure_matrix():
    11:     root = Path(__file__).resolve().parents[2]
    12:     src = root / "src"
    13:     env = os.environ.copy()
    14:     env.update({"OFFLINE": "1", "PYTHONPATH": str(src)})
    15:     msum = root / "data" / "output" / "matrix" / "matrix_summary.json"
    16:     if not msum.exists():
    17:         subprocess.run(
    18:             [sys.executable, str(root / "tools" / "run_actions_matrix.py")],
    19:             check=True,
    20:             cwd=str(root),
    21:             env=env,
    22:             text=True,
    23:         )
    24:     assert msum.exists(), "matrix_summary.json 不存在"
    25:     return msum
--------------------------------------------------------------------------------
END FILE    tests/contracts/conftest.py
================================================================================
================================================================================
BEGIN FILE  tests/contracts/test_action_result_contracts.py  (1528 bytes)
TAGS: legacy_candidate=no | sys_path_hack=no | duplicate_basename=no
--------------------------------------------------------------------------------
     1: from __future__ import annotations
     2: 
     3: import json
     4: from pathlib import Path
     5: 
     6: from src.sma_types import ActionResult, AttachmentMeta
     7: 
     8: ALLOWED_ACTIONS = {
     9:     "send_quote",
    10:     "reply_faq",
    11:     "reply_support",
    12:     "reply_general",
    13:     "reply_apology",
    14:     "sales",
    15:     "apply_info_change",
    16: }
    17: ALLOWED_CODES = {"OK", "INPUT_INVALID", "EXTERNAL_FAIL", "INTERNAL_ERROR"}
    18: 
    19: 
    20: def test_contracts_matrix_schema(_ensure_matrix):
    21:     root = Path(__file__).resolve().parents[2]
    22:     data = json.loads(
    23:         (root / "data" / "output" / "matrix" / "matrix_summary.json").read_text(encoding="utf-8")
    24:     )
    25:     cases = data.get("cases", [])
    26:     assert cases, "矩陣沒有案例"
    27: 
    28:     for c in cases:
    29:         assert c.get("action") in ALLOWED_ACTIONS
    30:         payload = {
    31:             "action": c["action"],
    32:             "ok": bool(c.get("ok", True)),
    33:             "code": c.get("code", "OK"),
    34:             "message": c.get("message", ""),
    35:             "output": c.get("output"),
    36:             "attachments": [
    37:                 (AttachmentMeta(path=a, exists=True).model_dump() if isinstance(a, str) else a)
    38:                 for a in (c.get("attachments") or [])
    39:             ],
    40:             "request_id": c.get("request_id"),
    41:             "spent_ms": c.get("spent_ms"),
    42:         }
    43:         ar = ActionResult(**payload)
    44:         assert ar.code in ALLOWED_CODES
    45:         for att in ar.attachments:
    46:             p = Path(att.path)
    47:             if not p.is_absolute():
    48:                 p = root / att.path
    49:             assert p.exists(), f"附件不存在：{att.path}"
--------------------------------------------------------------------------------
END FILE    tests/contracts/test_action_result_contracts.py
================================================================================
================================================================================
BEGIN FILE  tests/e2e/conftest.py  (330 bytes)
TAGS: legacy_candidate=no | sys_path_hack=no | duplicate_basename=no
--------------------------------------------------------------------------------
     1: import pathlib
     2: 
     3: import pytest
     4: 
     5: HERE = pathlib.Path(__file__).parent.resolve()
     6: 
     7: 
     8: def pytest_collection_modifyitems(session, config, items):
     9:     for item in items:
    10:         p = pathlib.Path(str(getattr(item, "fspath", ""))).resolve()
    11:         if p and (p == HERE or HERE in p.parents):
    12:             item.add_marker(pytest.mark.online)
--------------------------------------------------------------------------------
END FILE    tests/e2e/conftest.py
================================================================================
================================================================================
BEGIN FILE  tests/e2e/test_actions_matrix_ext.py  (1794 bytes)
TAGS: legacy_candidate=no | sys_path_hack=no | duplicate_basename=no
--------------------------------------------------------------------------------
     1: from pathlib import Path
     2: 
     3: 
     4: def _h(payload):
     5:     from action_handler import handle
     6: 
     7:     return handle(payload)
     8: 
     9: 
    10: def test_happy_paths():
    11:     cases = [
    12:         ("業務接洽或報價", "send_quote"),
    13:         ("請求技術支援", "reply_support"),
    14:         ("申請修改資訊", "apply_info_change"),
    15:         ("詢問流程或規則", "reply_faq"),
    16:         ("投訴與抱怨", "reply_apology"),
    17:         ("其他", "reply_general"),
    18:     ]
    19:     for label, expect in cases:
    20:         res = _h({"predicted_label": label, "subject": "S", "content": "C", "sender": "a@b.com"})
    21:         assert res.get("action") == expect
    22:         if expect == "send_quote":
    23:             atts = res.get("attachments") or []
    24:             assert len(atts) >= 1
    25:             p = Path(atts[0])
    26:             assert p.exists() and p.stat().st_size > 0
    27: 
    28: 
    29: def test_edge_cases():
    30:     res = _h({"predicted_label": "未定義分類", "subject": "?", "content": "?", "sender": "x@b.com"})
    31:     assert res.get("action") == "reply_general"
    32: 
    33:     res = _h({"predicted_label": "其他", "subject": "no sender", "content": "hello"})
    34:     assert res.get("action") == "reply_general"
    35: 
    36:     res = _h(
    37:         {
    38:             "predicted_label": "請求技術支援",
    39:             "subject": "",
    40:             "content": "錯誤代碼 123",
    41:             "sender": "n@b.com",
    42:         }
    43:     )
    44:     assert res.get("action") == "reply_support"
    45: 
    46:     res = _h(
    47:         {"predicted_label": "詢問流程或規則", "subject": "流程", "content": "", "sender": "n@b.com"}
    48:     )
    49:     assert res.get("action") == "reply_faq"
    50: 
    51:     res = _h(
    52:         {
    53:             "predicted_label": "申請修改資訊",
    54:             "subject": "更新",
    55:             "content": "您好",
    56:             "sender": "z@b.com",
    57:         }
    58:     )
    59:     assert res.get("action") == "apply_info_change"
--------------------------------------------------------------------------------
END FILE    tests/e2e/test_actions_matrix_ext.py
================================================================================
================================================================================
BEGIN FILE  tests/e2e/test_cli_flags.py  (1832 bytes)
TAGS: legacy_candidate=no | sys_path_hack=no | duplicate_basename=no
--------------------------------------------------------------------------------
     1: from __future__ import annotations
     2: 
     3: import json
     4: import os
     5: import subprocess
     6: import sys
     7: 
     8: 
     9: def _run_cli(inp, outp, *extra):
    10:     env = os.environ.copy()
    11:     env.setdefault("OFFLINE", "1")
    12:     cmd = [
    13:         sys.executable,
    14:         "-m",
    15:         "src.run_action_handler",
    16:         "--input",
    17:         str(inp),
    18:         "--output",
    19:         str(outp),
    20:         *extra,
    21:     ]
    22:     subprocess.run(cmd, check=True, env=env)
    23: 
    24: 
    25: def test_dry_run_flag(tmp_path):
    26:     i = tmp_path / "in.json"
    27:     o = tmp_path / "out.json"
    28:     i.write_text(
    29:         json.dumps(
    30:             {
    31:                 "subject": "請問服務內容？",
    32:                 "from": "a@b.c",
    33:                 "body": "想要了解細節",
    34:                 "predicted_label": "reply_faq",
    35:                 "confidence": 0.9,
    36:                 "attachments": [],
    37:             },
    38:             ensure_ascii=False,
    39:         ),
    40:         encoding="utf-8",
    41:     )
    42:     _run_cli(i, o, "--dry-run")
    43:     d = json.loads(o.read_text(encoding="utf-8"))
    44:     assert d.get("action_name") == "reply_faq"
    45:     assert d.get("dry_run") is True
    46: 
    47: 
    48: def test_simulate_pdf_failure(tmp_path):
    49:     i = tmp_path / "in.json"
    50:     o = tmp_path / "out.json"
    51:     i.write_text(
    52:         json.dumps(
    53:             {
    54:                 "subject": "請報價",
    55:                 "from": "a@b.c",
    56:                 "body": "我要報價",
    57:                 "predicted_label": "send_quote",
    58:                 "confidence": 0.9,
    59:                 "attachments": [],
    60:             },
    61:             ensure_ascii=False,
    62:         ),
    63:         encoding="utf-8",
    64:     )
    65:     _run_cli(i, o, "--simulate-failure", "pdf")
    66:     d = json.loads(o.read_text(encoding="utf-8"))
    67:     assert d.get("action_name") == "send_quote"
    68:     assert (
    69:         "simulated_pdf_failure" in "|".join(d.get("warnings", []))
    70:         or d.get("meta", {}).get("simulate_failure") == "pdf"
    71:     )
--------------------------------------------------------------------------------
END FILE    tests/e2e/test_cli_flags.py
================================================================================
================================================================================
BEGIN FILE  tests/e2e/test_cli_scripts.py  (846 bytes)
TAGS: legacy_candidate=no | sys_path_hack=no | duplicate_basename=no
--------------------------------------------------------------------------------
     1: from __future__ import annotations
     2: 
     3: import os
     4: import pathlib
     5: import subprocess
     6: import sys
     7: 
     8: import pytest
     9: 
    10: 
    11: def _try_help(path):
    12:     p = pathlib.Path(path)
    13:     if not p.exists():
    14:         pytest.skip(f"{path} not found")
    15:     env = os.environ.copy()
    16:     env["OFFLINE"] = "1"
    17:     try:
    18:         subprocess.run(
    19:             [sys.executable, path, "--help"],
    20:             check=True,
    21:             env=env,
    22:             capture_output=True,
    23:             timeout=15,
    24:         )
    25:     except Exception:
    26:         # 沒有 argparse 時，至少能執行不崩潰
    27:         subprocess.run([sys.executable, path], check=False, env=env, timeout=15)
    28: 
    29: 
    30: def test_cli_run_main_help():
    31:     _try_help("cli/run_main.py")
    32: 
    33: 
    34: def test_cli_run_classifier_help():
    35:     _try_help("cli/run_classifier.py")
    36: 
    37: 
    38: def test_cli_run_orchestrator_help():
    39:     _try_help("cli/run_orchestrator.py")
--------------------------------------------------------------------------------
END FILE    tests/e2e/test_cli_scripts.py
================================================================================
================================================================================
BEGIN FILE  tests/e2e/test_complaint_policy.py  (1343 bytes)
TAGS: legacy_candidate=no | sys_path_hack=no | duplicate_basename=no
--------------------------------------------------------------------------------
     1: import json
     2: import os
     3: import pathlib
     4: import subprocess
     5: import sys
     6: 
     7: ROOT = pathlib.Path(__file__).resolve().parents[2]
     8: PY = sys.executable
     9: 
    10: 
    11: def run_cli(payload: dict) -> dict:
    12:     in_p = ROOT / "data/output/in_c.json"
    13:     out_p = ROOT / "data/output/out_c.json"
    14:     in_p.parent.mkdir(parents=True, exist_ok=True)
    15:     in_p.write_text(json.dumps(payload, ensure_ascii=False), encoding="utf-8")
    16:     cmd = [PY, "-m", "src.run_action_handler", "--input", str(in_p), "--output", str(out_p)]
    17:     env = dict(os.environ)
    18:     env["OFFLINE"] = "1"
    19:     subprocess.run(cmd, cwd=str(ROOT), check=True, env=env)
    20:     return json.loads(out_p.read_text(encoding="utf-8"))
    21: 
    22: 
    23: def test_complaint_high_triggers_p1_and_cc():
    24:     payload = {
    25:         "subject": "系統當機導致客戶無法使用",
    26:         "from": "user@example.com",
    27:         "body": "目前服務 down，影響交易，請立即處理。",
    28:         "predicted_label": "complaint",
    29:         "confidence": 0.92,
    30:         "attachments": [],
    31:     }
    32:     out = run_cli(payload)
    33:     assert out["action_name"] == "complaint"
    34:     assert out["meta"]["priority"] == "P1"
    35:     assert out["meta"]["SLA_eta"] == "4h"
    36:     cc = (out["meta"].get("cc") or []) if isinstance(out["meta"], dict) else []
    37:     assert any(c in cc for c in ["qa@company.example", "ops@company.example"])
    38:     assert out["meta"].get("next_step")
--------------------------------------------------------------------------------
END FILE    tests/e2e/test_complaint_policy.py
================================================================================
================================================================================
BEGIN FILE  tests/e2e/test_label_routing_offline.py  (1888 bytes)
TAGS: legacy_candidate=no | sys_path_hack=no | duplicate_basename=no
--------------------------------------------------------------------------------
     1: from __future__ import annotations
     2: 
     3: import json
     4: import os
     5: import subprocess
     6: import sys
     7: from pathlib import Path
     8: 
     9: 
    10: def _run_cli(payload: dict, tmpdir: Path) -> dict:
    11:     i = tmpdir / "in.json"
    12:     o = tmpdir / "out.json"
    13:     i.write_text(json.dumps(payload, ensure_ascii=False), encoding="utf-8")
    14:     env = os.environ.copy()
    15:     env["OFFLINE"] = "1"
    16:     env["PYTHONPATH"] = str(Path("src").resolve())
    17:     cmd = [sys.executable, "-m", "src.run_action_handler", "--input", str(i), "--output", str(o)]
    18:     subprocess.run(cmd, check=True, env=env)
    19:     return json.loads(o.read_text(encoding="utf-8"))
    20: 
    21: 
    22: def test_label_send_quote(tmp_path: Path):
    23:     out = _run_cli(
    24:         {
    25:             "subject": "報價",
    26:             "from": "a@b.c",
    27:             "body": "請報價",
    28:             "predicted_label": "send_quote",
    29:             "confidence": 0.9,
    30:             "attachments": [],
    31:         },
    32:         tmp_path,
    33:     )
    34:     action = out.get("action_name") or out.get("action")
    35:     assert action == "send_quote"
    36: 
    37: 
    38: def test_label_reply_faq(tmp_path: Path):
    39:     out = _run_cli(
    40:         {
    41:             "subject": "FAQ",
    42:             "from": "a@b.c",
    43:             "body": "退貨流程?",
    44:             "predicted_label": "reply_faq",
    45:             "confidence": 0.9,
    46:             "attachments": [],
    47:         },
    48:         tmp_path,
    49:     )
    50:     action = out.get("action_name") or out.get("action")
    51:     assert action == "reply_faq"
    52:     subj = out.get("subject") or ""
    53:     assert subj.startswith("[自動回覆] ")
    54: 
    55: 
    56: def test_label_other_to_reply_general(tmp_path: Path):
    57:     out = _run_cli(
    58:         {
    59:             "subject": "其他",
    60:             "from": "a@b.c",
    61:             "body": "Hi",
    62:             "predicted_label": "other",
    63:             "confidence": 0.5,
    64:             "attachments": [],
    65:         },
    66:         tmp_path,
    67:     )
    68:     action = out.get("action_name") or out.get("action")
    69:     assert action == "reply_general"
--------------------------------------------------------------------------------
END FILE    tests/e2e/test_label_routing_offline.py
================================================================================
================================================================================
BEGIN FILE  tests/e2e/test_new_intents.py  (1936 bytes)
TAGS: legacy_candidate=no | sys_path_hack=no | duplicate_basename=no
--------------------------------------------------------------------------------
     1: from __future__ import annotations
     2: 
     3: import json
     4: import os
     5: import pathlib
     6: import subprocess
     7: import sys
     8: 
     9: 
    10: def _run_cli(inp, outp):
    11:     env = os.environ.copy()
    12:     env.setdefault("OFFLINE", "1")
    13:     cmd = [
    14:         sys.executable,
    15:         "-m",
    16:         "src.run_action_handler",
    17:         "--input",
    18:         str(inp),
    19:         "--output",
    20:         str(outp),
    21:     ]
    22:     subprocess.run(cmd, check=True, env=env)
    23: 
    24: 
    25: def test_sales_inquiry(tmp_path):
    26:     i = tmp_path / "in.json"
    27:     o = tmp_path / "out.json"
    28:     i.write_text(
    29:         json.dumps(
    30:             {
    31:                 "subject": "合作洽談",
    32:                 "from": "boss@example.com",
    33:                 "body": "想談合作與規格",
    34:                 "predicted_label": "sales_inquiry",
    35:                 "confidence": 0.9,
    36:                 "attachments": [],
    37:             },
    38:             ensure_ascii=False,
    39:         ),
    40:         encoding="utf-8",
    41:     )
    42:     _run_cli(i, o)
    43:     d = json.loads(o.read_text(encoding="utf-8"))
    44:     a = d.get("action_name") or d.get("action")
    45:     assert a == "sales_inquiry"
    46:     assert (d.get("subject") or "").startswith("[自動回覆]")
    47:     assert pathlib.Path("data/leads/leads.csv").exists()
    48: 
    49: 
    50: def test_complaint(tmp_path):
    51:     i = tmp_path / "in.json"
    52:     o = tmp_path / "out.json"
    53:     i.write_text(
    54:         json.dumps(
    55:             {
    56:                 "subject": "我要投訴",
    57:                 "from": "user@example.com",
    58:                 "body": "服務很差！退貨退款！",
    59:                 "predicted_label": "complaint",
    60:                 "confidence": 0.95,
    61:                 "attachments": [],
    62:             },
    63:             ensure_ascii=False,
    64:         ),
    65:         encoding="utf-8",
    66:     )
    67:     _run_cli(i, o)
    68:     d = json.loads(o.read_text(encoding="utf-8"))
    69:     a = d.get("action_name") or d.get("action")
    70:     assert a == "complaint"
    71:     assert (d.get("subject") or "").startswith("[自動回覆]")
    72:     assert pathlib.Path("data/complaints/log.csv").exists()
--------------------------------------------------------------------------------
END FILE    tests/e2e/test_new_intents.py
================================================================================
================================================================================
BEGIN FILE  tests/e2e/test_offline_suite.py  (2915 bytes)
TAGS: legacy_candidate=no | sys_path_hack=yes | duplicate_basename=no
--------------------------------------------------------------------------------
     1: import importlib
     2: import json
     3: import os
     4: import pathlib
     5: import subprocess
     6: import sys
     7: 
     8: ROOT = pathlib.Path(__file__).resolve().parents[2]  # 專案根目錄
     9: SRC_DIR = ROOT / "src"
    10: 
    11: 
    12: def _exists(p):
    13:     return pathlib.Path(p).exists()
    14: 
    15: 
    16: def _nonempty(p):
    17:     return _exists(p) and pathlib.Path(p).stat().st_size > 0
    18: 
    19: 
    20: def test_generate_quote_pdf(tmp_path):
    21:     """
    22:     符合你目前的簽名：
    23:       generate_pdf_quote(out_dir: Optional[path|str]=None, *, package: Optional[str]=None, client_name: Optional[str]=None) -> str
    24:     reportlab 缺/字型缺時，允許 .txt 保底。
    25:     """
    26:     os.environ["OFFLINE"] = "1"
    27:     # 確保能 import src.*
    28:     if str(SRC_DIR) not in sys.path:
    29:         sys.path.insert(0, str(SRC_DIR))
    30: 
    31:     mod = importlib.import_module(
    32:         "modules.quotation"
    33:         if (SRC_DIR / "modules" / "quotation.py").exists()
    34:         else "src.modules.quotation"
    35:     )
    36:     fn = getattr(mod, "generate_pdf_quote", None)
    37:     assert fn, "generate_pdf_quote missing"
    38: 
    39:     # 優先使用具名參數（符合你簽名），若舊行為只吃 out_dir 也能兼容
    40:     try:
    41:         rv = fn(out_dir=str(tmp_path), package="基礎", client_name="test@example.com")
    42:     except TypeError:
    43:         rv = fn(str(tmp_path))
    44: 
    45:     out_path = pathlib.Path(rv) if isinstance(rv, (str, pathlib.Path)) else tmp_path / "quote.pdf"
    46:     assert _nonempty(out_path), f"no output generated at {out_path}"
    47:     assert out_path.suffix in {".pdf", ".txt"}, f"unexpected suffix: {out_path.suffix}"
    48: 
    49: 
    50: def test_cli_smoke(tmp_path):
    51:     """
    52:     以 CLI 跑一趟 action handler（離線，不碰 API 金鑰）。
    53:     run_action_handler 內部用 'python -m action_handler'，
    54:     我們設定 PYTHONPATH=src，讓子程序找得到 action_handler。
    55:     """
    56:     env = os.environ.copy()
    57:     env["OFFLINE"] = "1"
    58:     # 讓子進程（python -m action_handler）找得到 src/*
    59:     env["PYTHONPATH"] = str(SRC_DIR)
    60: 
    61:     in_json = tmp_path / "in.json"
    62:     out_json = tmp_path / "out.json"
    63: 
    64:     # 提供最小可用 payload（action_handler 會自行決定動作）
    65:     payload = {
    66:         "subject": "請提供報價",
    67:         "from": "alice@example.com",
    68:         "body": "需要 quotation，請回覆細節與檔案",
    69:     }
    70:     in_json.write_text(json.dumps(payload, ensure_ascii=False), encoding="utf-8")
    71: 
    72:     # 用目前測試環境的 python 啟動 CLI（確保使用到 venv）
    73:     cmd = [
    74:         sys.executable,
    75:         "-m",
    76:         "src.run_action_handler",
    77:         "--input",
    78:         str(in_json),
    79:         "--output",
    80:         str(out_json),
    81:     ]
    82:     # 若你的包是以頂層 import（action_handler.py 在 src/），上面已設 PYTHONPATH，子程序會接手。
    83:     subprocess.check_call(cmd, env=env)
    84: 
    85:     assert _nonempty(out_json), "CLI did not produce output JSON"
    86:     # 能 parse 即可（內容格式依 action_handler 輸出，這裡不綁特定 schema）
    87:     json.loads(out_json.read_text(encoding="utf-8"))
--------------------------------------------------------------------------------
END FILE    tests/e2e/test_offline_suite.py
================================================================================
================================================================================
BEGIN FILE  tests/e2e/test_policy_expansion.py  (1480 bytes)
TAGS: legacy_candidate=no | sys_path_hack=no | duplicate_basename=no
--------------------------------------------------------------------------------
     1: import json
     2: import os
     3: import pathlib
     4: import subprocess
     5: import sys
     6: 
     7: ROOT = pathlib.Path(__file__).resolve().parents[2]
     8: PY = sys.executable
     9: 
    10: 
    11: def run_cli(payload: dict, name: str) -> dict:
    12:     in_p = ROOT / f"data/output/in_{name}.json"
    13:     out_p = ROOT / f"data/output/out_{name}.json"
    14:     in_p.parent.mkdir(parents=True, exist_ok=True)
    15:     in_p.write_text(json.dumps(payload, ensure_ascii=False), encoding="utf-8")
    16:     cmd = [PY, "-m", "src.run_action_handler", "--input", str(in_p), "--output", str(out_p)]
    17:     env = dict(os.environ)
    18:     env["OFFLINE"] = "1"
    19:     subprocess.run(cmd, cwd=str(ROOT), check=True, env=env)
    20:     return json.loads(out_p.read_text(encoding="utf-8"))
    21: 
    22: 
    23: def test_attachments_over_limit_requires_review():
    24:     payload = {
    25:         "subject": "一般詢問",
    26:         "from": "user@somewhere.com",
    27:         "body": "附件很多請協助查看。",
    28:         "predicted_label": "reply_faq",
    29:         "confidence": 0.9,
    30:         "attachments": [{"filename": "a.bin", "size": 6 * 1024 * 1024}],
    31:     }
    32:     out = run_cli(payload, "overlimit")
    33:     assert out["meta"].get("require_review") is True
    34: 
    35: 
    36: def test_sender_domain_whitelist_flag():
    37:     payload = {
    38:         "subject": "一般詢問",
    39:         "from": "alice@trusted.example",
    40:         "body": "這是白名單寄件者。",
    41:         "predicted_label": "reply_faq",
    42:         "confidence": 0.9,
    43:         "attachments": [],
    44:     }
    45:     out = run_cli(payload, "whitelist")
    46:     assert out["meta"].get("whitelisted") is True
--------------------------------------------------------------------------------
END FILE    tests/e2e/test_policy_expansion.py
================================================================================
================================================================================
BEGIN FILE  tests/e2e/test_runner.py  (764 bytes)
TAGS: legacy_candidate=no | sys_path_hack=no | duplicate_basename=no
--------------------------------------------------------------------------------
     1: import json
     2: import os
     3: import subprocess
     4: from pathlib import Path
     5: 
     6: ROOT = Path(__file__).resolve().parents[2]
     7: BIN = ROOT / "bin" / "smarun"
     8: OUT = ROOT / "data" / "output"
     9: 
    10: 
    11: def test_runner_outputs():
    12:     env = os.environ.copy()
    13:     env["OFFLINE"] = env.get("OFFLINE", "1")
    14:     env["PYTHONPATH"] = f"{ROOT}:{ROOT / 'src'}"
    15:     cp = subprocess.run([str(BIN)], cwd=str(ROOT), text=True, env=env)
    16:     assert cp.returncode == 0
    17:     outs = sorted(OUT.glob("out_*.json"))
    18:     assert len(outs) >= 2
    19:     with outs[0].open(encoding="utf-8") as fh:
    20:         data = json.load(fh)
    21:     # 放寬：頂層 logged_path 不一定有，但應至少有 meta 或 attachments 供後續流程使用
    22:     assert ("logged_path" in data) or ("meta" in data and isinstance(data["meta"], dict))
--------------------------------------------------------------------------------
END FILE    tests/e2e/test_runner.py
================================================================================
================================================================================
BEGIN FILE  tests/e2e/test_sales_and_complaint.py  (1673 bytes)
TAGS: legacy_candidate=no | sys_path_hack=no | duplicate_basename=no
--------------------------------------------------------------------------------
     1: #!/usr/bin/env python3
     2: from __future__ import annotations
     3: 
     4: import json
     5: import os
     6: import subprocess
     7: import sys
     8: from pathlib import Path
     9: 
    10: PY = sys.executable
    11: 
    12: 
    13: def run_cli(inp: dict, workdir: Path) -> dict:
    14:     in_p, out_p = workdir / "in.json", workdir / "out.json"
    15:     in_p.write_text(json.dumps(inp, ensure_ascii=False), encoding="utf-8")
    16:     env = os.environ.copy()
    17:     env.setdefault("SMA_OFFLINE", "1")
    18:     env.setdefault("SMA_DATA_DIR", str(workdir))
    19:     cmd = [
    20:         PY,
    21:         "-m",
    22:         "src.run_action_handler",
    23:         "--input",
    24:         str(in_p),
    25:         "--output",
    26:         str(out_p),
    27:         "--dry-run",
    28:     ]
    29:     subprocess.run(cmd, check=True, env=env)
    30:     return json.loads(out_p.read_text(encoding="utf-8"))
    31: 
    32: 
    33: def test_e2e_sales_inquiry(tmp_path):
    34:     res = run_cli(
    35:         {
    36:             "subject": "詢價",
    37:             "from": "alice@partner.co",
    38:             "body": "我們是XX股份有限公司，需要數量 50，預算 20000，期限 2025-09-01。",
    39:             "predicted_label": "sales_inquiry",
    40:             "confidence": 0.9,
    41:         },
    42:         tmp_path,
    43:     )
    44:     assert res["action_name"] == "sales_inquiry"
    45:     assert res["subject"].startswith("[自動回覆] ")
    46: 
    47: 
    48: def test_e2e_complaint_high(tmp_path):
    49:     res = run_cli(
    50:         {
    51:             "subject": "嚴重投訴",
    52:             "from": "bob@example.com",
    53:             "body": "產品無法使用而且非常惡劣，要求退款，否則投訴到主管機關。",
    54:             "predicted_label": "complaint",
    55:             "confidence": 0.8,
    56:         },
    57:         tmp_path,
    58:     )
    59:     assert res["action_name"] == "complaint"
    60:     assert res["meta"]["priority"] in {"P1", "P2", "P3"}
--------------------------------------------------------------------------------
END FILE    tests/e2e/test_sales_and_complaint.py
================================================================================
================================================================================
BEGIN FILE  tests/e2e/test_sales_inquiry_needs_summary.py  (1337 bytes)
TAGS: legacy_candidate=no | sys_path_hack=no | duplicate_basename=no
--------------------------------------------------------------------------------
     1: import json
     2: import os
     3: import pathlib
     4: import subprocess
     5: import sys
     6: 
     7: ROOT = pathlib.Path(__file__).resolve().parents[2]
     8: PY = sys.executable
     9: 
    10: 
    11: def run_cli(payload: dict) -> dict:
    12:     in_p = ROOT / "data/output/in_sales.json"
    13:     out_p = ROOT / "data/output/out_sales.json"
    14:     in_p.parent.mkdir(parents=True, exist_ok=True)
    15:     in_p.write_text(json.dumps(payload, ensure_ascii=False), encoding="utf-8")
    16:     cmd = [PY, "-m", "src.run_action_handler", "--input", str(in_p), "--output", str(out_p)]
    17:     env = dict(os.environ)
    18:     env["OFFLINE"] = "1"
    19:     subprocess.run(cmd, cwd=str(ROOT), check=True, env=env)
    20:     return json.loads(out_p.read_text(encoding="utf-8"))
    21: 
    22: 
    23: def test_sales_inquiry_generates_md_and_next_step():
    24:     payload = {
    25:         "subject": "合作報價與時程 2025-08-20",
    26:         "from": "alice@biz.com",
    27:         "body": "本公司偉大股份有限公司 需要 50 台 方案，預算 NTD 300,000，請於 2025/08/20 前回覆。",
    28:         "predicted_label": "sales_inquiry",
    29:         "confidence": 0.87,
    30:         "attachments": [],
    31:     }
    32:     out = run_cli(payload)
    33:     assert out["action_name"] == "sales_inquiry"
    34:     names = [a["filename"] for a in out.get("attachments", [])]
    35:     assert any(n.endswith(".md") and "needs_summary_" in n for n in names)
    36:     assert out["meta"].get("next_step"), "meta.next_step 應存在"
--------------------------------------------------------------------------------
END FILE    tests/e2e/test_sales_inquiry_needs_summary.py
================================================================================
================================================================================
BEGIN FILE  tests/e2e/test_send_quote_degrade.py  (926 bytes)
TAGS: legacy_candidate=no | sys_path_hack=no | duplicate_basename=no
--------------------------------------------------------------------------------
     1: import builtins
     2: from contextlib import contextmanager
     3: from pathlib import Path
     4: 
     5: 
     6: @contextmanager
     7: def break_reportlab_import():
     8:     real = builtins.__import__
     9: 
    10:     def fake(name, *a, **k):
    11:         if name.startswith("reportlab"):
    12:             raise ImportError("blocked reportlab for test")
    13:         return real(name, *a, **k)
    14: 
    15:     builtins.__import__ = fake
    16:     try:
    17:         yield
    18:     finally:
    19:         builtins.__import__ = real
    20: 
    21: 
    22: def test_send_quote_degrade():
    23:     from action_handler import handle
    24: 
    25:     with break_reportlab_import():
    26:         res = handle(
    27:             {
    28:                 "predicted_label": "業務接洽或報價",
    29:                 "subject": "需要報價",
    30:                 "content": "請評估交期",
    31:                 "sender": "buyer2@example.com",
    32:             }
    33:         )
    34:     atts = res.get("attachments") or []
    35:     assert len(atts) >= 1
    36:     p = Path(atts[0])
    37:     assert p.exists() and p.stat().st_size > 0
--------------------------------------------------------------------------------
END FILE    tests/e2e/test_send_quote_degrade.py
================================================================================
================================================================================
BEGIN FILE  tests/e2e/test_spam_pipeline.py  (1046 bytes)
TAGS: legacy_candidate=no | sys_path_hack=no | duplicate_basename=no
--------------------------------------------------------------------------------
     1: from __future__ import annotations
     2: 
     3: from src.spam.pipeline import analyze
     4: 
     5: 
     6: def test_ham_is_legit():
     7:     r = analyze(
     8:         {
     9:             "sender": "client@company.com",
    10:             "subject": "請協助報價",
    11:             "content": "請提供合約附件與付款條款",
    12:             "attachments": [],
    13:         }
    14:     )
    15:     assert r["label"] in ("legit", "suspect")
    16:     assert r["score"] < 0.50
    17: 
    18: 
    19: def test_obvious_spam():
    20:     r = analyze(
    21:         {
    22:             "sender": "promo@xxx.top",
    23:             "subject": "GET RICH QUICK!!!",
    24:             "content": "Free crypto giveaway: https://x.xyz/win?token=1",
    25:             "attachments": [],
    26:         }
    27:     )
    28:     assert r["label"] == "spam"
    29:     assert r["score"] >= 0.60
    30: 
    31: 
    32: def test_suspicious_attachment():
    33:     r = analyze(
    34:         {
    35:             "sender": "it@support.com",
    36:             "subject": "Password reset",
    37:             "content": "Please verify your login",
    38:             "attachments": ["reset.js"],
    39:         }
    40:     )
    41:     assert r["label"] in ("suspect", "spam")
    42:     assert r["score"] >= 0.45
--------------------------------------------------------------------------------
END FILE    tests/e2e/test_spam_pipeline.py
================================================================================
================================================================================
BEGIN FILE  tests/integration/test_email_end_to_end_offline.py  (2737 bytes)
TAGS: legacy_candidate=no | sys_path_hack=no | duplicate_basename=no
--------------------------------------------------------------------------------
     1: import json
     2: import types
     3: 
     4: import pytest
     5: 
     6: from smart_mail_agent.spam import rules
     7: from smart_mail_agent.spam.orchestrator_offline import orchestrate
     8: 
     9: 
    10: def _rule_via_rules_mapping(email):
    11:     # 用 mapping 介面，讓 orchestrator 能讀 'label'
    12:     res = rules.label_email(email)
    13:     return {"label": res["label"], "score": res.get("score", 0.0)}
    14: 
    15: 
    16: def test_legit_mapping_basic():
    17:     email = {
    18:         "sender": "client@company.com",
    19:         "subject": "請協助報價",
    20:         "content": "請提供合約附件與付款條款",
    21:         "attachments": [],
    22:     }
    23:     r = rules.label_email(email)  # mapping -> dict（normalized score）
    24:     assert r["label"] in ("legit", "suspect")
    25:     assert isinstance(r["scores"], dict) and "link_ratio" in r["scores"]
    26: 
    27: 
    28: def test_obvious_spam_many_links():
    29:     email = {
    30:         "sender": "promo@xxx.top",
    31:         "subject": "GET RICH QUICK!!!",
    32:         "content": ("點此 http://a.io x " * 20) + "end",
    33:         "attachments": [],
    34:     }
    35:     r = rules.label_email(email)
    36:     assert r["label"] == "spam"
    37:     assert r["score"] >= 0.60  # normalized
    38: 
    39: 
    40: def test_suspicious_attachment_score_and_label():
    41:     email = {
    42:         "sender": "it@support.com",
    43:         "subject": "Password reset",
    44:         "content": "Please verify your login",
    45:         "attachments": ["reset.js", "readme.txt"],
    46:     }
    47:     r = rules.label_email(email)
    48:     assert r["label"] in ("suspect", "spam")
    49:     assert r["score"] >= 0.45
    50: 
    51: 
    52: def test_orchestrate_rule_shortcut_and_model_paths():
    53:     # 規則直接命中 -> drop
    54:     def rule_true(_):
    55:         return True
    56: 
    57:     res = orchestrate("subj", rule_true, model=None, model_threshold=0.6)
    58:     assert res.is_spam is True and res.source == "rule" and res.action == "drop"
    59: 
    60:     # 模型高分 spam -> drop
    61:     def m_high(s, c):
    62:         return ("spam", 0.91)
    63: 
    64:     res = orchestrate("x", lambda _: False, m_high, model_threshold=0.6)
    65:     assert res.is_spam is True and res.source == "model" and res.action == "drop"
    66: 
    67:     # 模型等於門檻 -> review
    68:     def m_eq(s, c):
    69:         return ("spam", 0.6)
    70: 
    71:     res = orchestrate("x", lambda _: False, m_eq, model_threshold=0.6)
    72:     assert res.is_spam is True and res.is_borderline is True and res.action == "review"
    73: 
    74:     # 模型 ham -> route
    75:     def m_ham(s, c):
    76:         return ("ham", 0.2)
    77: 
    78:     res = orchestrate("x", lambda _: False, m_ham, model_threshold=0.6)
    79:     assert res.is_spam is False and res.action == "route_to_inbox"
    80: 
    81: 
    82: def test_orchestrate_model_crash_fallback():
    83:     def m_boom(_s, _c):
    84:         raise RuntimeError("model boom")
    85: 
    86:     res = orchestrate("x", lambda _: False, m_boom, model_threshold=0.6)
    87:     assert res.is_spam is False and res.source == "fallback"
    88:     assert hasattr(res, "extra") and "model_error" in res.extra
--------------------------------------------------------------------------------
END FILE    tests/integration/test_email_end_to_end_offline.py
================================================================================
================================================================================
BEGIN FILE  tests/integration/test_online_send_paths.py  (1611 bytes)
TAGS: legacy_candidate=no | sys_path_hack=no | duplicate_basename=no
--------------------------------------------------------------------------------
     1: from __future__ import annotations
     2: 
     3: import importlib
     4: import os
     5: import types
     6: 
     7: import pytest
     8: 
     9: oc = importlib.import_module("scripts.online_check")
    10: 
    11: 
    12: def _env_ok(monkeypatch):
    13:     monkeypatch.setenv("SMTP_USER", "u@example.com", prepend=False)
    14:     monkeypatch.setenv("SMTP_PASS", "x", prepend=False)
    15:     monkeypatch.setenv("SMTP_HOST", "smtp.example.com", prepend=False)
    16:     monkeypatch.setenv("SMTP_PORT", "465", prepend=False)
    17:     monkeypatch.setenv("REPLY_TO", "r@example.com", prepend=False)
    18: 
    19: 
    20: def test_missing_env_returns_2(monkeypatch):
    21:     for k in ["SMTP_USER", "SMTP_PASS", "SMTP_HOST", "SMTP_PORT", "REPLY_TO"]:
    22:         monkeypatch.delenv(k, raising=False)
    23:     assert oc.main() == 2
    24: 
    25: 
    26: def test_smtp_fail_returns_1(monkeypatch):
    27:     _env_ok(monkeypatch)
    28: 
    29:     class Dummy:
    30:         def __init__(self, *a, **kw):
    31:             pass
    32: 
    33:         def __enter__(self):
    34:             return self
    35: 
    36:         def __exit__(self, *exc):
    37:             return False
    38: 
    39:         def login(self, u, p):
    40:             pass
    41: 
    42:         def send_message(self, msg):
    43:             raise RuntimeError("network down")
    44: 
    45:     monkeypatch.setattr(oc.smtplib, "SMTP_SSL", Dummy)
    46:     assert oc.main() == 1
    47: 
    48: 
    49: def test_success_returns_0(monkeypatch):
    50:     _env_ok(monkeypatch)
    51: 
    52:     class Dummy:
    53:         def __init__(self, *a, **kw):
    54:             pass
    55: 
    56:         def __enter__(self):
    57:             return self
    58: 
    59:         def __exit__(self, *exc):
    60:             return False
    61: 
    62:         def login(self, u, p):
    63:             pass
    64: 
    65:         def send_message(self, msg):
    66:             return None
    67: 
    68:     monkeypatch.setattr(oc.smtplib, "SMTP_SSL", Dummy)
    69:     assert oc.main() == 0
--------------------------------------------------------------------------------
END FILE    tests/integration/test_online_send_paths.py
================================================================================
================================================================================
BEGIN FILE  tests/internal_smoke/test_import_all_internal.py  (753 bytes)
TAGS: legacy_candidate=no | sys_path_hack=no | duplicate_basename=no
--------------------------------------------------------------------------------
     1: from __future__ import annotations
     2: 
     3: import importlib
     4: import pkgutil
     5: from pathlib import Path
     6: 
     7: import pytest
     8: 
     9: PKG = "smart_mail_agent"
    10: BASE = Path("src") / PKG
    11: if not BASE.exists():
    12:     pytest.skip("internal package not found", allow_module_level=True)
    13: 
    14: SKIP_CONTAINS = (
    15:     ".spam.ml_spam_classifier",
    16:     ".features.spam.ml_spam_classifier",
    17:     ".features.spam.inference_classifier",
    18:     ".spam.pipeline",
    19:     ".spam.spam_llm_filter",
    20: )
    21: 
    22: mods: list[str] = []
    23: for finder in pkgutil.walk_packages([str(BASE)], prefix=f"{PKG}."):
    24:     name = finder.name
    25:     if any(x in name for x in SKIP_CONTAINS):
    26:         continue
    27:     mods.append(name)
    28: 
    29: 
    30: @pytest.mark.parametrize("mod", mods)
    31: def test_import_module(mod: str) -> None:
    32:     importlib.import_module(mod)
--------------------------------------------------------------------------------
END FILE    tests/internal_smoke/test_import_all_internal.py
================================================================================
================================================================================
BEGIN FILE  tests/policy/test_attachment_risks_extra.py  (1660 bytes)
TAGS: legacy_candidate=no | sys_path_hack=no | duplicate_basename=no
--------------------------------------------------------------------------------
     1: import json
     2: import pathlib
     3: import subprocess
     4: import sys
     5: import tempfile
     6: from pathlib import Path
     7: 
     8: ROOT = Path(__file__).resolve().parents[2]
     9: 
    10: 
    11: def _run_cli(payload: dict, *flags: str):
    12:     with tempfile.TemporaryDirectory() as td:
    13:         inp = pathlib.Path(td) / "in.json"
    14:         out = pathlib.Path(td) / "out.json"
    15:         inp.write_text(json.dumps(payload, ensure_ascii=False), encoding="utf-8")
    16:         cmd = [
    17:             sys.executable,
    18:             str(ROOT / "src" / "run_action_handler.py"),
    19:             "--input",
    20:             str(inp),
    21:             "--output",
    22:             str(out),
    23:             *flags,
    24:         ]
    25:         cp = subprocess.run(cmd, text=True)
    26:         assert cp.returncode == 0
    27:         return json.loads(out.read_text(encoding="utf-8"))
    28: 
    29: 
    30: def test_double_ext_and_long_name_and_mime_mismatch_trigger_review():
    31:     payload = {
    32:         "predicted_label": "reply_faq",
    33:         "from": "a@b.c",
    34:         "subject": "測試",
    35:         "body": "附件測試",
    36:         "attachments": [
    37:             {"filename": "invoice.pdf.exe", "mime": "application/x-msdownload"},
    38:             {"filename": "A" * 130 + ".pdf", "mime": "application/pdf"},
    39:             {"filename": "report.pdf", "mime": "application/octet-stream"},  # 與副檔名推測不符
    40:         ],
    41:     }
    42:     out = _run_cli(payload, "--dry-run")
    43:     m = out.get("meta") or {}
    44:     assert m.get("require_review") is True
    45:     risks = m.get("risks") or []
    46:     assert any("attach:double_ext" in r for r in risks)
    47:     assert any("attach:long_name" in r for r in risks)
    48:     assert any("attach:mime_mismatch" in r for r in risks)
    49:     cc = m.get("cc") or []
    50:     assert "support@company.example" in cc
--------------------------------------------------------------------------------
END FILE    tests/policy/test_attachment_risks_extra.py
================================================================================
================================================================================
BEGIN FILE  tests/policy/test_attachment_risks_matrix.py  (1578 bytes)
TAGS: legacy_candidate=no | sys_path_hack=no | duplicate_basename=no
--------------------------------------------------------------------------------
     1: import json
     2: import pathlib
     3: import subprocess
     4: import sys
     5: import tempfile
     6: from pathlib import Path
     7: 
     8: ROOT = Path(__file__).resolve().parents[2]
     9: 
    10: 
    11: def _run_cli(payload, *flags):
    12:     with tempfile.TemporaryDirectory() as td:
    13:         i = Path(td) / "in.json"
    14:         o = Path(td) / "out.json"
    15:         i.write_text(json.dumps(payload, ensure_ascii=False), encoding="utf-8")
    16:         r = subprocess.run(
    17:             [
    18:                 sys.executable,
    19:                 str(ROOT / "src" / "run_action_handler.py"),
    20:                 "--input",
    21:                 str(i),
    22:                 "--output",
    23:                 str(o),
    24:                 *flags,
    25:             ],
    26:             text=True,
    27:         )
    28:         assert r.returncode == 0
    29:         return json.loads(o.read_text(encoding="utf-8"))
    30: 
    31: 
    32: def test_mime_edge_cases_matrix():
    33:     payload = {
    34:         "predicted_label": "reply_faq",
    35:         "attachments": [
    36:             {"filename": "safe.pdf", "mime": "application/pdf"},
    37:             {"filename": "payroll.xlsm.exe", "mime": "application/x-msdownload"},
    38:             {"filename": "R" * 200 + ".pdf", "mime": "application/pdf"},
    39:             {"filename": "brief.pdf", "mime": "application/octet-stream"},
    40:         ],
    41:     }
    42:     out = _run_cli(payload, "--dry-run")
    43:     m = out.get("meta") or {}
    44:     risks = m.get("risks") or []
    45:     assert any("double_ext" in r for r in risks)
    46:     assert any("long_name" in r for r in risks)
    47:     assert any("mime_mismatch" in r for r in risks)
    48:     assert m.get("require_review") is True
    49:     # 需要安全副本
    50:     assert "support@company.example" in (m.get("cc") or [])
--------------------------------------------------------------------------------
END FILE    tests/policy/test_attachment_risks_matrix.py
================================================================================
================================================================================
BEGIN FILE  tests/portfolio/test_email_processor_utils.py  (492 bytes)
TAGS: legacy_candidate=no | sys_path_hack=no | duplicate_basename=no
--------------------------------------------------------------------------------
     1: import json
     2: import pathlib
     3: import tempfile
     4: 
     5: from src.email_processor import extract_fields, write_classification_result
     6: 
     7: 
     8: def test_extract_fields_various_keys():
     9:     data = {"title": "t", "body": "b", "from": "f"}
    10:     s, b, f = extract_fields(data)
    11:     assert (s, b, f) == ("t", "b", "f")
    12: 
    13: 
    14: def test_write_classification_result_writes_json(tmp_path):
    15:     p = tmp_path / "x.json"
    16:     write_classification_result({"a": 1}, str(p))
    17:     assert json.loads(p.read_text(encoding="utf-8"))["a"] == 1
--------------------------------------------------------------------------------
END FILE    tests/portfolio/test_email_processor_utils.py
================================================================================
================================================================================
BEGIN FILE  tests/portfolio/test_inference_classifier_fallback.py  (509 bytes)
TAGS: legacy_candidate=no | sys_path_hack=no | duplicate_basename=no
--------------------------------------------------------------------------------
     1: import src.inference_classifier as ic
     2: 
     3: 
     4: def test_smart_truncate_marks_ellipsis():
     5:     text = "A" * 3000
     6:     out = ic.smart_truncate(text, max_chars=1000)
     7:     assert "...\n" in out and len(out) < len(text)
     8: 
     9: 
    10: def test_classify_intent_returns_unknown_when_model_fail(monkeypatch):
    11:     monkeypatch.setattr(
    12:         ic, "load_model", lambda *a, **k: (_ for _ in ()).throw(RuntimeError("fail"))
    13:     )
    14:     ret = ic.classify_intent("s", "b")
    15:     assert ret["label"] in ("unknown", "UNK") and ret["confidence"] == 0.0
--------------------------------------------------------------------------------
END FILE    tests/portfolio/test_inference_classifier_fallback.py
================================================================================
