================================================================================
BEGIN FILE  .archive/cli/run_classifier.py  (1232 bytes)
TAGS: legacy_candidate=yes | sys_path_hack=yes | duplicate_basename=no
--------------------------------------------------------------------------------
     1: import argparse
     2: import json
     3: import os
     4: import sys
     5: 
     6: # 加入 src 模組路徑
     7: SRC_PATH = os.path.join(os.path.dirname(__file__), "src")
     8: if SRC_PATH not in sys.path:
     9:     sys.path.insert(0, SRC_PATH)
    10: 
    11: from classifier import IntentClassifier
    12: from utils.logger import logger
    13: 
    14: parser = argparse.ArgumentParser(description="六分類意圖分類模型推論器")
    15: parser.add_argument("--model", required=True, help="模型資料夾路徑")
    16: parser.add_argument("--input", required=True, help="輸入 JSON 郵件檔案（需含 subject / content）")
    17: args = parser.parse_args()
    18: 
    19: model_path = os.path.abspath(args.model)
    20: input_path = os.path.abspath(args.input)
    21: 
    22: if not os.path.isdir(model_path):
    23:     raise FileNotFoundError(f"模型路徑不存在：{model_path}")
    24: if not os.path.isfile(input_path):
    25:     raise FileNotFoundError(f"找不到輸入檔案：{input_path}")
    26: 
    27: with open(input_path, encoding="utf-8") as f:
    28:     mail = json.load(f)
    29: 
    30: subject = mail.get("subject", "")
    31: content = mail.get("content", mail.get("body", ""))
    32: 
    33: clf = IntentClassifier(model_path)
    34: result = clf.classify(subject, content)
    35: 
    36: logger.info("分類結果：%s", json.dumps(result, ensure_ascii=False, indent=2))
    37: print(json.dumps(result, ensure_ascii=False, indent=2))
--------------------------------------------------------------------------------
END FILE    .archive/cli/run_classifier.py
================================================================================
================================================================================
BEGIN FILE  .archive/cli/run_generate_spam_testcases.py  (1791 bytes)
TAGS: legacy_candidate=yes | sys_path_hack=no | duplicate_basename=no
--------------------------------------------------------------------------------
     1: #!/usr/bin/env python3
     2: # 檔案位置：cli/run_generate_spam_testcases.py
     3: # 模組用途：自動生成完整垃圾信過濾測試資料（涵蓋 rule / ml / llm / whitelist / 合法 / 錯誤）
     4: 
     5: import json
     6: import os
     7: from pathlib import Path
     8: 
     9: OUTPUT_DIR = "data/testdata/spam"
    10: 
    11: testcases = {
    12:     "spam_rule.json": {
    13:         "subject": "限時優惠送你",
    14:         "content": "裸聊加 LINE，投資機會免費賺錢",
    15:         "sender": "hacker@spamlink.net",
    16:     },
    17:     "spam_ml_high.json": {
    18:         "subject": "快速致富 100% 成功！",
    19:         "content": "點擊投資回報 10 倍，立即註冊！",
    20:         "sender": "promo@unknown.com",
    21:     },
    22:     "spam_ml_low_llm_spam.json": {
    23:         "subject": "Hi，有個計畫想和你聊聊",
    24:         "content": "可以跟你談談金融合作嗎？會有收益保證。",
    25:         "sender": "unclear@softpush.co",
    26:     },
    27:     "nonspam_whitelist.json": {
    28:         "subject": "系統維護完成通知",
    29:         "content": "您的帳戶維護已完成，歡迎使用。",
    30:         "sender": "admin@trusted.org",
    31:     },
    32:     "nonspam_legit.json": {
    33:         "subject": "詢問合約內容與付款時間",
    34:         "content": "請問 8 月的合約是否已匯款？附件已寄出。",
    35:         "sender": "client@business.com",
    36:     },
    37:     "edge_ml_unknown.json": {
    38:         "subject": "!!##!!",
    39:         "content": ".....",
    40:         "sender": "undefined@empty.ai",
    41:     },
    42: }
    43: 
    44: 
    45: def main():
    46:     Path(OUTPUT_DIR).mkdir(parents=True, exist_ok=True)
    47: 
    48:     for filename, data in testcases.items():
    49:         path = os.path.join(OUTPUT_DIR, filename)
    50:         with open(path, "w", encoding="utf-8") as f:
    51:             json.dump(data, f, indent=2, ensure_ascii=False)
    52:         print(f"[完成] 已建立測資：{path}")
    53: 
    54: 
    55: if __name__ == "__main__":
    56:     main()
--------------------------------------------------------------------------------
END FILE    .archive/cli/run_generate_spam_testcases.py
================================================================================
================================================================================
BEGIN FILE  .archive/cli/run_llm_filter.py  (975 bytes)
TAGS: legacy_candidate=yes | sys_path_hack=yes | duplicate_basename=no
--------------------------------------------------------------------------------
     1: import argparse
     2: import json
     3: import os
     4: import sys
     5: 
     6: # 加入 src 模組目錄，支援根目錄執行 CLI
     7: SRC_PATH = os.path.join(os.path.dirname(__file__), "src")
     8: if SRC_PATH not in sys.path:
     9:     sys.path.insert(0, SRC_PATH)
    10: 
    11: from spam.spam_llm_filter import SpamLLMFilter
    12: from utils.logger import logger
    13: 
    14: parser = argparse.ArgumentParser(description="執行 LLM 詐騙語意辨識")
    15: parser.add_argument("--input", required=True, help="輸入郵件 JSON 檔案")
    16: args = parser.parse_args()
    17: 
    18: input_path = os.path.abspath(args.input)
    19: if not os.path.isfile(input_path):
    20:     raise FileNotFoundError(f"找不到輸入檔案：{input_path}")
    21: 
    22: with open(input_path, encoding="utf-8") as f:
    23:     mail = json.load(f)
    24: 
    25: subject = mail.get("subject", "")
    26: content = mail.get("content", "")
    27: 
    28: filt = SpamLLMFilter()
    29: result = filt.is_suspicious(subject, content)
    30: 
    31: logger.info("LLM 判定：%s", "詐騙可疑" if result else "內容安全")
    32: print("詐騙可疑" if result else "內容安全")
--------------------------------------------------------------------------------
END FILE    .archive/cli/run_llm_filter.py
================================================================================
================================================================================
BEGIN FILE  .archive/cli/run_main.py  (1875 bytes)
TAGS: legacy_candidate=yes | sys_path_hack=yes | duplicate_basename=no
--------------------------------------------------------------------------------
     1: import argparse
     2: import json
     3: import os
     4: import sys
     5: 
     6: SRC_PATH = os.path.join(os.path.dirname(__file__), "src")
     7: if SRC_PATH not in sys.path:
     8:     sys.path.insert(0, SRC_PATH)
     9: 
    10: from classifier import IntentClassifier
    11: from spam.spam_filter_orchestrator import SpamFilterOrchestrator
    12: from utils.logger import logger
    13: 
    14: parser = argparse.ArgumentParser(description="郵件處理主流程")
    15: parser.add_argument("--spam_model", required=True, help="BERT spam 模型路徑")
    16: parser.add_argument("--intent_model", required=True, help="六分類模型路徑")
    17: parser.add_argument("--input", required=True, help="輸入信件 JSON 檔案")
    18: parser.add_argument("--output", required=True, help="輸出結果 JSON 檔案")
    19: args = parser.parse_args()
    20: 
    21: # 絕對路徑轉換
    22: input_path = os.path.abspath(args.input)
    23: output_path = os.path.abspath(args.output)
    24: spam_model_path = os.path.abspath(args.spam_model)
    25: intent_model_path = os.path.abspath(args.intent_model)
    26: 
    27: # 載入信件內容
    28: with open(input_path, encoding="utf-8") as f:
    29:     mail = json.load(f)
    30: subject = mail.get("subject", "")
    31: content = mail.get("content", "")
    32: 
    33: # 垃圾信三層過濾
    34: spam_orchestrator = SpamFilterOrchestrator(model_path=spam_model_path)
    35: spam_result = spam_orchestrator.is_legit(subject, content)
    36: 
    37: if not spam_result["allow"]:
    38:     final = {
    39:         "label": "垃圾信",
    40:         "stage": spam_result["stage"],
    41:         "subject": subject,
    42:         "content": content,
    43:     }
    44: else:
    45:     clf = IntentClassifier(model_path=intent_model_path)
    46:     intent_result = clf.classify(subject, content)
    47:     final = intent_result
    48: 
    49: # 輸出結果
    50: os.makedirs(os.path.dirname(output_path), exist_ok=True)
    51: with open(output_path, "w", encoding="utf-8") as f:
    52:     json.dump(final, f, ensure_ascii=False, indent=2)
    53: 
    54: logger.info("已完成主流程處理，輸出至 %s", output_path)
    55: print(json.dumps(final, ensure_ascii=False, indent=2))
--------------------------------------------------------------------------------
END FILE    .archive/cli/run_main.py
================================================================================
================================================================================
BEGIN FILE  .archive/cli/run_orchestrator.py  (2018 bytes)
TAGS: legacy_candidate=yes | sys_path_hack=yes | duplicate_basename=no
--------------------------------------------------------------------------------
     1: import argparse
     2: import json
     3: import os
     4: import sys
     5: 
     6: # 加入 src 模組路徑
     7: SRC_PATH = os.path.join(os.path.dirname(__file__), "src")
     8: if SRC_PATH not in sys.path:
     9:     sys.path.insert(0, SRC_PATH)
    10: 
    11: from spam.ml_spam_classifier import SpamBertClassifier
    12: from spam.rule_filter import RuleBasedSpamFilter
    13: from spam.spam_llm_filter import SpamLLMFilter
    14: from utils.logger import logger
    15: 
    16: parser = argparse.ArgumentParser(description="三層 Spam 過濾流程")
    17: parser.add_argument("--model", required=True, help="BERT 模型路徑")
    18: parser.add_argument("--input", required=True, help="輸入郵件 JSON 檔案")
    19: args = parser.parse_args()
    20: 
    21: model_path = os.path.abspath(args.model)
    22: input_path = os.path.abspath(args.input)
    23: 
    24: if not os.path.isdir(model_path):
    25:     raise FileNotFoundError(f"模型路徑不存在：{model_path}")
    26: if not os.path.isfile(input_path):
    27:     raise FileNotFoundError(f"找不到輸入檔案：{input_path}")
    28: 
    29: with open(input_path, encoding="utf-8") as f:
    30:     mail = json.load(f)
    31: 
    32: subject = mail.get("subject", "")
    33: content = mail.get("content", "")
    34: text = (subject + "\n" + content).strip()
    35: 
    36: logger.info("【Step 1】啟動 Rule-Based 過濾")
    37: rule_filter = RuleBasedSpamFilter()
    38: if rule_filter.is_spam(text):
    39:     logger.info("結果：Rule-Based 判定為垃圾信")
    40:     print("分類結果：垃圾信（Rule-Based）")
    41:     sys.exit(0)
    42: 
    43: logger.info("【Step 2】啟動 BERT Spam 分類模型")
    44: bert_clf = SpamBertClassifier(model_path)
    45: bert_result = bert_clf.predict(subject, content)
    46: if bert_result["label"].lower() == "spam":
    47:     logger.info("結果：BERT 判定為垃圾信")
    48:     print("分類結果：垃圾信（BERT 模型）")
    49:     sys.exit(0)
    50: 
    51: logger.info("【Step 3】啟動 LLM 語意判斷")
    52: llm_filter = SpamLLMFilter()
    53: if llm_filter.is_suspicious(subject, content):
    54:     logger.info("結果：LLM 判定為垃圾信")
    55:     print("分類結果：垃圾信（LLM 分析）")
    56:     sys.exit(0)
    57: 
    58: logger.info("所有層級判斷為正常信件")
    59: print("分類結果：正常信件（非垃圾）")
--------------------------------------------------------------------------------
END FILE    .archive/cli/run_orchestrator.py
================================================================================
================================================================================
BEGIN FILE  .archive/cli/run_rule_filter.py  (857 bytes)
TAGS: legacy_candidate=yes | sys_path_hack=no | duplicate_basename=no
--------------------------------------------------------------------------------
     1: #!/usr/bin/env python3
     2: # 檔案位置：cli/run_rule_filter.py
     3: # 模組用途：使用 CLI 執行 Rule-Based spam 判斷
     4: 
     5: import argparse
     6: import json
     7: 
     8: from spam.rule_filter import RuleBasedSpamFilter
     9: 
    10: 
    11: def run(json_path: str):
    12:     with open(json_path, encoding="utf-8") as f:
    13:         data = json.load(f)
    14: 
    15:     subject = data.get("subject", "")
    16:     content = data.get("content", "")
    17:     full_text = f"{subject}\n{content}".strip()
    18: 
    19:     clf = RuleBasedSpamFilter()
    20:     result = clf.is_spam(full_text)
    21: 
    22:     print("[結果] 是否為垃圾信：", "是" if result else "否")
    23: 
    24: 
    25: if __name__ == "__main__":
    26:     parser = argparse.ArgumentParser(description="使用 Rule-Based 方法檢測垃圾郵件")
    27:     parser.add_argument("--json", required=True, help="輸入 JSON 路徑，需含 subject 與 content 欄位")
    28:     args = parser.parse_args()
    29:     run(args.json)
--------------------------------------------------------------------------------
END FILE    .archive/cli/run_rule_filter.py
================================================================================
================================================================================
BEGIN FILE  .archive/cli/run_spam_classifier.py  (1623 bytes)
TAGS: legacy_candidate=yes | sys_path_hack=no | duplicate_basename=no
--------------------------------------------------------------------------------
     1: #!/usr/bin/env python3
     2: # 檔案位置：cli/run_spam_classifier.py
     3: # 用途：透過 CLI 執行 SpamBertClassifier 並分類指定信件 JSON
     4: 
     5: import argparse
     6: import json
     7: import sys
     8: 
     9: from spam.ml_spam_classifier import SpamBertClassifier
    10: from utils.logger import logger
    11: 
    12: 
    13: def run(args):
    14:     clf = SpamBertClassifier(args.model)
    15: 
    16:     try:
    17:         with open(args.json, encoding="utf-8") as f:
    18:             data = json.load(f)
    19:     except Exception as e:
    20:         logger.error(f"無法讀取 JSON 檔案：{e}")
    21:         sys.exit(1)
    22: 
    23:     subject = data.get("subject", "").strip()
    24:     content = data.get("content")
    25: 
    26:     # 統一格式欄位檢查
    27:     if content is None:
    28:         # 若使用者填寫了舊欄位名，主動提示
    29:         if "body" in data:
    30:             logger.error("請將欄位 'body' 改為 'content'。系統統一使用 'content' 表示信件內容。")
    31:         elif "text" in data:
    32:             logger.error("請將欄位 'text' 改為 'content'。系統統一使用 'content' 表示信件內容。")
    33:         else:
    34:             logger.error("JSON 資料缺少必要欄位 'content'")
    35:         sys.exit(1)
    36: 
    37:     result = clf.predict(subject=subject, content=content.strip())
    38:     print(f"分類結果：{result['label']} (信心值：{result['confidence']})")
    39: 
    40: 
    41: if __name__ == "__main__":
    42:     parser = argparse.ArgumentParser(description="BERT Spam 分類器 CLI 測試")
    43:     parser.add_argument("--json", required=True, help="輸入 JSON 檔案路徑，需包含 subject 與 content 欄位")
    44:     parser.add_argument("--model", required=True, help="模型目錄路徑")
    45:     args = parser.parse_args()
    46:     run(args)
--------------------------------------------------------------------------------
END FILE    .archive/cli/run_spam_classifier.py
================================================================================
================================================================================
BEGIN FILE  .archive/cli/run_spam_filter.py  (1501 bytes)
TAGS: legacy_candidate=yes | sys_path_hack=no | duplicate_basename=no
--------------------------------------------------------------------------------
     1: #!/usr/bin/env python3
     2: # 檔案位置：cli/run_spam_filter.py
     3: # 模組用途：針對單筆或整批 JSON 測資執行 spam 判斷流程
     4: 
     5: import argparse
     6: import json
     7: from pathlib import Path
     8: 
     9: from spam.spam_filter_orchestrator import SpamFilterOrchestrator
    10: 
    11: 
    12: def run_single(json_path: str, model_path: str):
    13:     with open(json_path, encoding="utf-8") as f:
    14:         data = json.load(f)
    15: 
    16:     subject = data.get("subject", "")
    17:     content = data.get("content", "") or data.get("body", "")
    18:     sender = data.get("sender", "")
    19: 
    20:     clf = SpamFilterOrchestrator(model_path)
    21:     result = clf.is_legit(subject, content, sender)
    22: 
    23:     print(f"\n[測資檔案] {json_path}")
    24:     print(f"[主旨] {subject}")
    25:     print(f"[寄件者] {sender}")
    26:     print(f"[判斷結果] 許可: {result['allow']} | 階段: {result['stage']} | 理由: {result['reason']}\n")
    27: 
    28: 
    29: def main():
    30:     parser = argparse.ArgumentParser(description="Spam 判斷 CLI 工具")
    31:     parser.add_argument("--json", required=True, help="單筆 JSON 檔案路徑，或目錄以跑整批")
    32:     parser.add_argument("--model", default="model/bert_spam_classifier", help="ML 模型路徑")
    33:     args = parser.parse_args()
    34: 
    35:     if Path(args.json).is_file():
    36:         run_single(args.json, args.model)
    37:     elif Path(args.json).is_dir():
    38:         for file in sorted(Path(args.json).glob("*.json")):
    39:             run_single(str(file), args.model)
    40:     else:
    41:         print("請指定有效的測資檔路徑或資料夾")
    42: 
    43: 
    44: if __name__ == "__main__":
    45:     main()
--------------------------------------------------------------------------------
END FILE    .archive/cli/run_spam_filter.py
================================================================================
================================================================================
BEGIN FILE  .archive/pipeline/main.py  (2760 bytes)
TAGS: legacy_candidate=yes | sys_path_hack=yes | duplicate_basename=no
--------------------------------------------------------------------------------
     1: #!/usr/bin/env python3
     2: # 檔案位置：pipeline/main.py
     3: # 目的：Smart-Mail-Agent 入口流程（離線安全、IMAP 認證失敗不中斷）
     4: 
     5: from __future__ import annotations
     6: 
     7: import imaplib
     8: import logging
     9: import os
    10: import sys
    11: from pathlib import Path
    12: 
    13: # [SMA_SYS_PATH] 確保可匯入 src 模組
    14: _ROOT = Path(__file__).resolve().parents[1]
    15: _SRC = _ROOT / "src"
    16: if str(_SRC) not in sys.path:
    17:     sys.path.insert(0, str(_SRC))
    18: 
    19: logger = logging.getLogger("Pipeline")
    20: if not logger.handlers:
    21:     logging.basicConfig(level=logging.INFO, format="%(asctime)s [%(levelname)s] [%(name)s] %(message)s")
    22: 
    23: 
    24: def fetch_emails(
    25:     IMAP_HOST: str,
    26:     IMAP_USER: str,
    27:     IMAP_PASS: str,
    28:     folder: str = "INBOX",
    29:     limit: int = 50,
    30:     force: bool = False,
    31: ) -> list[str]:
    32:     """安全抓信：
    33:     - OFFLINE=1 直接跳過
    34:     - 認證失敗或任何錯誤不拋出
    35:     - 回傳空清單也視為成功（不中斷整體流程）
    36:     """
    37:     if os.getenv("OFFLINE", "0") == "1":
    38:         logger.info("[IMAP] OFFLINE 模式，跳過抓信")
    39:         return []
    40: 
    41:     results: list[str] = []
    42:     try:
    43:         with imaplib.IMAP4_SSL(IMAP_HOST) as imap:
    44:             imap.login(IMAP_USER, IMAP_PASS)
    45:             typ, _ = imap.select(folder, readonly=True)
    46:             if typ != "OK":
    47:                 logger.warning("[IMAP] 選擇資料夾失敗，改用 INBOX")
    48:                 imap.select("INBOX", readonly=True)
    49:             typ, data = imap.search(None, "ALL")
    50:             if typ != "OK":
    51:                 logger.warning("[IMAP] 搜尋郵件失敗")
    52:                 return []
    53:             ids = data[0].split() if data and data[0] else []
    54:             if limit and len(ids) > limit:
    55:                 ids = ids[-limit:]
    56:             # 如需取信件內容，可在此做 imap.fetch；此處先保持空清單以確保流程不中斷。
    57:             return results
    58:     except imaplib.IMAP4.error as e:
    59:         logger.warning("[IMAP] 認證失敗：%s", e)
    60:         return []
    61:     except Exception as e:
    62:         logger.exception("[IMAP] 抓信未預期錯誤：%s", e)
    63:         return []
    64: 
    65: 
    66: def run_pipeline(limit: int = 50, force: bool = False) -> int:
    67:     logger.info("[Pipeline] 開始擷取郵件")
    68:     IMAP_HOST = os.getenv("IMAP_HOST", "imap.gmail.com")
    69:     IMAP_USER = os.getenv("IMAP_USER", "")
    70:     IMAP_PASS = os.getenv("IMAP_PASS", "")
    71:     _ = fetch_emails(IMAP_HOST, IMAP_USER, IMAP_PASS, limit=limit, force=force)
    72:     logger.info("[Pipeline] 完成")
    73:     return 0
    74: 
    75: 
    76: if __name__ == "__main__":
    77:     import argparse
    78: 
    79:     parser = argparse.ArgumentParser()
    80:     parser.add_argument("--limit", type=int, default=50)
    81:     parser.add_argument("--force", action="store_true")
    82:     args = parser.parse_args()
    83:     raise SystemExit(run_pipeline(limit=args.limit, force=args.force))
--------------------------------------------------------------------------------
END FILE    .archive/pipeline/main.py
================================================================================
================================================================================
BEGIN FILE  .archive/pipeline/main1.py  (5357 bytes)
TAGS: legacy_candidate=yes | sys_path_hack=yes | duplicate_basename=no
--------------------------------------------------------------------------------
     1: # pipeline/main1.py
     2: 
     3: import argparse
     4: import email
     5: import imaplib
     6: import json
     7: import os
     8: import sqlite3
     9: import sys
    10: from email.header import decode_header
    11: from pathlib import Path
    12: 
    13: from dotenv import load_dotenv
    14: 
    15: sys.path.insert(0, os.path.abspath("src"))
    16: from email_processor import main as process_email_main
    17: from utils.logger import logger
    18: 
    19: load_dotenv()
    20: 
    21: IMAP_HOST = os.getenv("IMAP_HOST")
    22: IMAP_USER = os.getenv("IMAP_USER")
    23: IMAP_PASS = os.getenv("IMAP_PASS")
    24: SAVE_DIR = Path("data/testdata/inbox/")
    25: SAVE_DIR.mkdir(parents=True, exist_ok=True)
    26: 
    27: DB_PATH = "data/db/processed_mails.db"
    28: 
    29: 
    30: def init_db():
    31:     Path("data/db").mkdir(parents=True, exist_ok=True)
    32:     conn = sqlite3.connect(DB_PATH)
    33:     cursor = conn.cursor()
    34:     cursor.execute(
    35:         """
    36:         CREATE TABLE IF NOT EXISTS processed_mails (
    37:             uid TEXT PRIMARY KEY,
    38:             subject TEXT,
    39:             sender TEXT
    40:         )
    41:     """
    42:     )
    43:     conn.commit()
    44:     conn.close()
    45:     logger.info("processed_mails.db 初始化完成")
    46: 
    47: 
    48: def decode_mime_header(header_bytes):
    49:     decoded_parts = decode_header(header_bytes)
    50:     return "".join(part.decode(encoding or "utf-8") if isinstance(part, bytes) else part for part, encoding in decoded_parts)
    51: 
    52: 
    53: def uid_already_processed(uid: str) -> bool:
    54:     conn = sqlite3.connect(DB_PATH)
    55:     cur = conn.cursor()
    56:     cur.execute("SELECT 1 FROM processed_mails WHERE uid=?", (uid,))
    57:     result = cur.fetchone()
    58:     conn.close()
    59:     return result is not None
    60: 
    61: 
    62: def save_processed_uid(uid: str, subject: str, sender: str):
    63:     conn = sqlite3.connect(DB_PATH)
    64:     cur = conn.cursor()
    65:     cur.execute(
    66:         "INSERT OR IGNORE INTO processed_mails (uid, subject, sender) VALUES (?, ?, ?)",
    67:         (uid, subject, sender),
    68:     )
    69:     conn.commit()
    70:     conn.close()
    71: 
    72: 
    73: def fetch_emails(limit: int = 100, force: bool = False):
    74:     with imaplib.IMAP4_SSL(IMAP_HOST) as imap:
    75:         logger.info(f"[IMAP] 連線中：{IMAP_HOST}")
    76:         imap.login(IMAP_USER, IMAP_PASS)
    77: 
    78:         # 中文 Gmail 的「所有郵件」對應資料夾
    79:         status, _ = imap.select('"[Gmail]/&UWiQ6JD1TvY-"')
    80:         if status != "OK":
    81:             logger.error("[IMAP] 無法選擇 [Gmail]/所有郵件")
    82:             return []
    83: 
    84:         status, data = imap.uid("search", None, "ALL")
    85:         if status != "OK":
    86:             logger.error("[IMAP] 搜尋信件失敗")
    87:             return []
    88: 
    89:         uid_list = data[0].split()[-limit:]
    90:         emails = []
    91: 
    92:         for uid_bytes in uid_list:
    93:             uid = uid_bytes.decode()
    94:             if not force and uid_already_processed(uid):
    95:                 logger.info(f"[IMAP] 跳過已處理：UID={uid}")
    96:                 continue
    97: 
    98:             status, msg_data = imap.uid("fetch", uid_bytes, "(RFC822)")
    99:             if status != "OK":
   100:                 logger.warning(f"[IMAP] 下載失敗：UID={uid}")
   101:                 continue
   102: 
   103:             msg = email.message_from_bytes(msg_data[0][1])
   104:             subject = decode_mime_header(msg.get("Subject", ""))
   105:             sender = decode_mime_header(msg.get("From", ""))
   106:             content = ""
   107: 
   108:             if msg.is_multipart():
   109:                 for part in msg.walk():
   110:                     if part.get_content_type() == "text/plain":
   111:                         charset = part.get_content_charset() or "utf-8"
   112:                         content = part.get_payload(decode=True).decode(charset, errors="ignore")
   113:                         break
   114:             else:
   115:                 charset = msg.get_content_charset() or "utf-8"
   116:                 content = msg.get_payload(decode=True).decode(charset, errors="ignore")
   117: 
   118:             email_json = {
   119:                 "subject": subject.strip(),
   120:                 "content": content.strip(),
   121:                 "sender": sender.strip(),
   122:             }
   123: 
   124:             json_path = SAVE_DIR / f"mail_{uid}.json"
   125:             with open(json_path, "w", encoding="utf-8") as f:
   126:                 json.dump(email_json, f, ensure_ascii=False, indent=2)
   127: 
   128:             save_processed_uid(uid, subject, sender)
   129:             emails.append(str(json_path))
   130: 
   131:         return emails
   132: 
   133: 
   134: def run():
   135:     parser = argparse.ArgumentParser()
   136:     parser.add_argument("--limit", type=int, default=100, help="最多擷取多少封")
   137:     parser.add_argument("--force", action="store_true", help="是否強制重抓已處理信")
   138:     args = parser.parse_args()
   139: 
   140:     init_db()
   141:     logger.info("開始抓取郵件")
   142:     paths = fetch_emails(limit=args.limit, force=args.force)
   143:     logger.info(f"共擷取 {len(paths)} 封信件")
   144: 
   145:     total = len(paths)
   146:     success = 0
   147:     failed = 0
   148:     spam_blocked = 0
   149: 
   150:     for path in paths:
   151:         logger.info(f"處理中：{path}")
   152:         sys.argv = ["main", "--input", path]
   153:         try:
   154:             process_email_main()
   155:             logger.info(f"處理完成：{path}")
   156:             with open(path, encoding="utf-8") as f:
   157:                 mail = json.load(f)
   158:             if "報價" in mail.get("subject", ""):
   159:                 spam_blocked += 1
   160:             else:
   161:                 success += 1
   162:         except Exception as e:
   163:             logger.error(f"處理失敗：{e}")
   164:             failed += 1
   165: 
   166:     print("\n信件處理統計報告")
   167:     print(f"- 總共擷取：{total} 封")
   168:     print(f"- 處理成功：{success} 封")
   169:     print(f"- 處理失敗：{failed} 封")
   170:     print(f"- 被過濾為 Spam：{spam_blocked} 封")
   171: 
   172: 
   173: if __name__ == "__main__":
   174:     run()
--------------------------------------------------------------------------------
END FILE    .archive/pipeline/main1.py
================================================================================
================================================================================
BEGIN FILE  .archive/requirements/requirements-dev.txt  (69 bytes)
TAGS: legacy_candidate=yes | sys_path_hack=no | duplicate_basename=no
--------------------------------------------------------------------------------
     1: black==24.4.2
     2: isort==5.13.2
     3: flake8==7.0.0
     4: pytest==8.3.2
     5: build==1.2.1
--------------------------------------------------------------------------------
END FILE    .archive/requirements/requirements-dev.txt
================================================================================
================================================================================
BEGIN FILE  .archive/requirements/requirements.txt  (494 bytes)
TAGS: legacy_candidate=yes | sys_path_hack=no | duplicate_basename=no
--------------------------------------------------------------------------------
     1: transformers>=4.36
     2: torch>=2.1
     3: datasets
     4: scikit-learn
     5: pytesseract
     6: Pillow
     7: beautifulsoup4
     8: openai
     9: langchain
    10: tqdm
    11: fpdf
    12: python-dotenv
    13: streamlit
    14: altair
    15: schedule
    16: transformers>=4.41.1
    17: accelerate>=0.26.0
    18: datasets
    19: scikit-learn
    20: torch>=2.0.0
    21: tqdm
    22: openai
    23: pydantic
    24: python-dotenv
    25: email-validator
    26: matplotlib
    27: sentencepiece
    28: tiktoken
    29: datasets
    30: python-dotenv
    31: pytest>=7.0.0
    32: fpdf2
    33: openai>=1.12.0
    34: tabulate>=0.9.0
    35: pytest-html
    36: rich>=13.0.0
    37: tenacity>=8.0.1
    38: reportlab>=3.6.12
    39: Jinja2>=3.1,<3.2
    40: pydantic>=1.10,<2
    41: PyYAML>=6,<7
--------------------------------------------------------------------------------
END FILE    .archive/requirements/requirements.txt
================================================================================
================================================================================
BEGIN FILE  .archive/spam/__init__.py  (90 bytes)
TAGS: legacy_candidate=yes | sys_path_hack=no | duplicate_basename=no
--------------------------------------------------------------------------------
     1: #!/usr/bin/env python3
     2: # 檔案位置：spam/__init__.py
     3: # 模組用途：相容層封裝
--------------------------------------------------------------------------------
END FILE    .archive/spam/__init__.py
================================================================================
================================================================================
BEGIN FILE  .archive/spam/spam_filter_orchestrator.py  (293 bytes)
TAGS: legacy_candidate=yes | sys_path_hack=no | duplicate_basename=no
--------------------------------------------------------------------------------
     1: #!/usr/bin/env python3
     2: # 檔案位置：spam/spam_filter_orchestrator.py
     3: # 模組用途：相容層，轉發至 smart_mail_agent.spam
     4: 
     5: from importlib import import_module as _imp
     6: 
     7: _SF = _imp("smart_mail_agent.spam.spam_filter_orchestrator")
     8: SpamFilterOrchestrator = _SF.SpamFilterOrchestrator
--------------------------------------------------------------------------------
END FILE    .archive/spam/spam_filter_orchestrator.py
================================================================================
================================================================================
BEGIN FILE  .archive/src/cli/__init__.py  (0 bytes)
TAGS: legacy_candidate=yes | sys_path_hack=no | duplicate_basename=no
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
END FILE    .archive/src/cli/__init__.py
================================================================================
================================================================================
BEGIN FILE  .archive/src/cli/sma.py  (4367 bytes)
TAGS: legacy_candidate=yes | sys_path_hack=no | duplicate_basename=no
--------------------------------------------------------------------------------
     1: from __future__ import annotations
     2: 
     3: import argparse
     4: import csv
     5: import html
     6: import json
     7: from pathlib import Path
     8: from typing import Any
     9: 
    10: from spam.pipeline import analyze
    11: from spam.rules import load_rules
    12: 
    13: 
    14: def _read_json(p: Path) -> dict[str, Any]:
    15:     return json.loads(p.read_text(encoding="utf-8"))
    16: 
    17: 
    18: def _read_eml(p: Path) -> dict[str, Any]:
    19:     # 超輕量 .eml 解析：抓 From/Subject 與全文；附件略過（非關鍵）
    20:     sender, subject = "", ""
    21:     content_lines: list[str] = []
    22:     for line in p.read_text(errors="ignore", encoding="utf-8").splitlines():
    23:         if line.lower().startswith("from:"):
    24:             sender = line.split(":", 1)[1].strip()
    25:         elif line.lower().startswith("subject:"):
    26:             subject = line.split(":", 1)[1].strip()
    27:         else:
    28:             content_lines.append(line)
    29:     return {
    30:         "sender": sender,
    31:         "subject": subject,
    32:         "content": "\n".join(content_lines),
    33:         "attachments": [],
    34:     }
    35: 
    36: 
    37: def spam_scan(inbox: Path, out_dir: Path) -> dict[str, Any]:
    38:     out_dir.mkdir(parents=True, exist_ok=True)
    39:     rows: list[dict[str, Any]] = []
    40:     for ext in ("*.json", "*.eml"):
    41:         for f in inbox.rglob(ext):
    42:             try:
    43:                 email = _read_json(f) if f.suffix.lower() == ".json" else _read_eml(f)
    44:                 res = analyze(email)
    45:                 rows.append({"file": str(f.relative_to(inbox)), **res})
    46:             except Exception as e:
    47:                 rows.append(
    48:                     {
    49:                         "file": str(f.relative_to(inbox)),
    50:                         "label": "error",
    51:                         "score": 0,
    52:                         "reasons": [str(e)],
    53:                         "subject": "",
    54:                     }
    55:                 )
    56:     # 輸出 CSV / JSON / HTML
    57:     json_path = out_dir / "spam_scan.json"
    58:     csv_path = out_dir / "spam_scan.csv"
    59:     html_path = out_dir / "spam_scan.html"
    60: 
    61:     json_path.write_text(json.dumps(rows, ensure_ascii=False, indent=2), encoding="utf-8")
    62:     with csv_path.open("w", newline="", encoding="utf-8") as fp:
    63:         w = csv.writer(fp)
    64:         w.writerow(["file", "label", "score", "subject", "reasons"])
    65:         for r in rows:
    66:             w.writerow(
    67:                 [
    68:                     r.get("file", ""),
    69:                     r.get("label", ""),
    70:                     r.get("score", ""),
    71:                     r.get("subject", ""),
    72:                     " | ".join(r.get("reasons", [])),
    73:                 ]
    74:             )
    75: 
    76:     # HTML 簡表
    77:     table_rows = []
    78:     for r in rows:
    79:         reasons = " | ".join(html.escape(x) for x in r.get("reasons", []))
    80:         table_rows.append(
    81:             f"<tr><td>{html.escape(r.get('file', ''))}</td><td>{html.escape(str(r.get('label', '')))}</td><td>{int(r.get('score', 0))}</td><td>{html.escape(r.get('subject', ''))}</td><td>{reasons}</td></tr>"
    82:         )
    83:     html_doc = (
    84:         "<!doctype html><meta charset='utf-8'><title>Spam Scan Report</title>"
    85:         "<style>body{font-family:system-ui,Segoe UI,Arial} table{border-collapse:collapse;width:100%} th,td{border:1px solid #ddd;padding:6px} th{background:#fafafa;text-align:left}</style>"
    86:         "<h2>Spam Scan Report</h2>"
    87:         f"<p>Total: {len(rows)}</p>"
    88:         "<table><tr><th>File</th><th>Label</th><th>Score</th><th>Subject</th><th>Reasons</th></tr>" + "".join(table_rows) + "</table>"
    89:     )
    90:     html_path.write_text(html_doc, encoding="utf-8")
    91:     return {
    92:         "json": str(json_path),
    93:         "csv": str(csv_path),
    94:         "html": str(html_path),
    95:         "count": len(rows),
    96:     }
    97: 
    98: 
    99: def main():
   100:     ap = argparse.ArgumentParser(prog="sma")
   101:     sub = ap.add_subparsers(dest="cmd")
   102:     s = sub.add_parser("spam-scan", help="批量掃描 inbox 並輸出 CSV/JSON/HTML 報告")
   103:     s.add_argument("--inbox", default="data/inbox", help="來源目錄（預設 data/inbox）")
   104:     s.add_argument("--out", default="reports", help="報告輸出目錄（預設 reports）")
   105:     s.add_argument("--reload", action="store_true", help="執行前強制重載規則")
   106:     args = ap.parse_args()
   107: 
   108:     if args.cmd == "spam-scan":
   109:         if args.reload:
   110:             load_rules(force=True)
   111:         inbox = Path(args.inbox)
   112:         outd = Path(args.out)
   113:         res = spam_scan(inbox, outd)
   114:         print(json.dumps(res, ensure_ascii=False, indent=2))
   115:     else:
   116:         ap.print_help()
   117: 
   118: 
   119: if __name__ == "__main__":
   120:     main()
--------------------------------------------------------------------------------
END FILE    .archive/src/cli/sma.py
================================================================================
================================================================================
BEGIN FILE  .env.example  (199 bytes)
TAGS: legacy_candidate=no | sys_path_hack=no | duplicate_basename=no
--------------------------------------------------------------------------------
     1: # Offline 預設：1（只跑離線測試）; 設 0 可跑線上冒煙
     2: OFFLINE=1
     3: 
     4: # 線上寄信（可用 Gmail App Password）
     5: SMTP_USER=
     6: SMTP_PASS=
     7: SMTP_HOST=smtp.gmail.com
     8: SMTP_PORT=465
     9: REPLY_TO=
--------------------------------------------------------------------------------
END FILE    .env.example
================================================================================
================================================================================
BEGIN FILE  .github/dependabot.yml  (201 bytes)
TAGS: legacy_candidate=no | sys_path_hack=no | duplicate_basename=no
--------------------------------------------------------------------------------
     1: version: 2
     2: updates:
     3:   - package-ecosystem: "pip"
     4:     directory: "/"
     5:     schedule: { interval: "weekly" }
     6:   - package-ecosystem: "github-actions"
     7:     directory: "/"
     8:     schedule: { interval: "weekly" }
--------------------------------------------------------------------------------
END FILE    .github/dependabot.yml
================================================================================
================================================================================
BEGIN FILE  .github/ISSUE_TEMPLATE/bug_report.md  (130 bytes)
TAGS: legacy_candidate=no | sys_path_hack=no | duplicate_basename=no
--------------------------------------------------------------------------------
     1: ---
     2: name: Bug report
     3: about: 回報一個問題
     4: labels: bug
     5: ---
     6: **描述**
     7: **如何重現**
     8: **預期行為**
     9: **環境**
    10: **補充**
--------------------------------------------------------------------------------
END FILE    .github/ISSUE_TEMPLATE/bug_report.md
================================================================================
================================================================================
BEGIN FILE  .github/PULL_REQUEST_TEMPLATE.md  (342 bytes)
TAGS: legacy_candidate=no | sys_path_hack=no | duplicate_basename=no
--------------------------------------------------------------------------------
     1: ## 內容
     2: - 這個 PR 做了什麼？
     3: 
     4: ## 檢查清單
     5: - [ ] `pip install -e ".[dev]"` 安裝成功
     6: - [ ] `ruff check .`、`ruff format --check .` 綠
     7: - [ ] `PYTHONPATH=. pytest -q tests -k "not online"` 綠
     8: - [ ] 無破壞性變更（或已在 PR 描述清楚）
     9: 
    10: ## 風險/相容性
    11: - 是否影響現有 CLI 或 API？有的話請描述。
--------------------------------------------------------------------------------
END FILE    .github/PULL_REQUEST_TEMPLATE.md
================================================================================
================================================================================
BEGIN FILE  .github/workflows-archive/ci-offline.yml  (758 bytes)
TAGS: legacy_candidate=yes | sys_path_hack=no | duplicate_basename=no
--------------------------------------------------------------------------------
     1: name: ci-offline
     2: on:
     3:   push:
     4:   pull_request:
     5: jobs:
     6:   test-offline:
     7:     runs-on: ubuntu-latest
     8:     steps:
     9:       - uses: actions/checkout@v4
    10:       - uses: actions/setup-python@v5
    11:         with: { python-version: '3.10' }
    12:       - name: Install deps
    13:         run: |
    14:           python -m pip install -U pip
    15:           pip install -r requirements.txt || true
    16:           pip install pytest black isort flake8
    17:       - name: Lint
    18:         run: |
    19:           black --check .
    20:           isort --check-only .
    21:           flake8 .
    22:       - name: Run offline tests
    23:         env: { PYTHONPATH: src, OFFLINE: "1" }
    24:         run: pytest -q -k "not online"
    25:       - name: Run matrix demo
    26:         env: { PYTHONPATH: src, OFFLINE: "1" }
    27:         run: python tools/run_actions_matrix.py || true
--------------------------------------------------------------------------------
END FILE    .github/workflows-archive/ci-offline.yml
================================================================================
================================================================================
BEGIN FILE  .github/workflows-archive/ci.yaml  (1473 bytes)
TAGS: legacy_candidate=yes | sys_path_hack=no | duplicate_basename=no
--------------------------------------------------------------------------------
     1: name: CI
     2: 
     3: on:
     4:   push:
     5:     branches: [ "main" ]
     6:   pull_request:
     7: 
     8: jobs:
     9:   build-test:
    10:     runs-on: ubuntu-latest
    11:     timeout-minutes: 20
    12:     steps:
    13:       - uses: actions/checkout@v4
    14: 
    15:       - name: Set up Python
    16:         uses: actions/setup-python@v5
    17:         with:
    18:           python-version: "3.10"
    19: 
    20:       - name: Cache pip
    21:         uses: actions/cache@v4
    22:         with:
    23:           path: ~/.cache/pip
    24:           key: pip-${{ runner.os }}-${{ hashFiles('requirements*.txt') }}
    25:           restore-keys: |
    26:             pip-${{ runner.os }}-
    27: 
    28:       - name: Install deps
    29:         run: |
    30:           python -m pip install -U pip
    31:           if [ -f requirements.txt ]; then pip install -r requirements.txt; fi
    32:           if [ -f requirements-dev.txt ]; then pip install -r requirements-dev.txt; fi
    33: 
    34:       - name: Lint (isort/black/flake8)
    35:         run: |
    36:           isort --check-only .
    37:           black --check .
    38:           flake8
    39: 
    40:       - name: Run tests (offline)
    41:         env:
    42:           OFFLINE: "1"
    43:           PYTHONPATH: "src"
    44:         run: |
    45:           pytest -q
    46: 
    47:       - name: Demo run (bin/smarun)
    48:         env:
    49:           OFFLINE: "1"
    50:           PYTHONPATH: "src"
    51:         run: |
    52:           chmod +x bin/smarun || true
    53:           ./bin/smarun
    54: 
    55:       - name: Upload artifacts
    56:         if: always()
    57:         uses: actions/upload-artifact@v4
    58:         with:
    59:           name: outputs-and-logs
    60:           path: |
    61:             data/output/out_*.json
    62:             logs/sma-*.jsonl
    63:           if-no-files-found: warn
--------------------------------------------------------------------------------
END FILE    .github/workflows-archive/ci.yaml
================================================================================
================================================================================
BEGIN FILE  .github/workflows-archive/docker-ghcr.yml  (887 bytes)
TAGS: legacy_candidate=yes | sys_path_hack=no | duplicate_basename=no
--------------------------------------------------------------------------------
     1: name: Docker (GHCR)
     2: 
     3: on:
     4:   push:
     5:     tags:
     6:       - 'v*'
     7: 
     8: permissions:
     9:   contents: read
    10:   packages: write
    11: 
    12: jobs:
    13:   build-and-push:
    14:     runs-on: ubuntu-latest
    15:     timeout-minutes: 30
    16:     steps:
    17:       - uses: actions/checkout@v4
    18: 
    19:       - name: Set up QEMU
    20:         uses: docker/setup-qemu-action@v3
    21: 
    22:       - name: Set up Buildx
    23:         uses: docker/setup-buildx-action@v3
    24: 
    25:       - name: Login GHCR
    26:         uses: docker/login-action@v3
    27:         with:
    28:           registry: ghcr.io
    29:           username: ${{ github.actor }}
    30:           password: ${{ secrets.GITHUB_TOKEN }}
    31: 
    32:       - name: Build & Push
    33:         uses: docker/build-push-action@v6
    34:         with:
    35:           context: .
    36:           file: ./Dockerfile
    37:           platforms: linux/amd64
    38:           push: true
    39:           tags: |
    40:             ghcr.io/${{ github.repository }}:latest
    41:             ghcr.io/${{ github.repository }}:${{ github.ref_name }}
--------------------------------------------------------------------------------
END FILE    .github/workflows-archive/docker-ghcr.yml
================================================================================
================================================================================
BEGIN FILE  .github/workflows-archive/interview-addon.yml  (593 bytes)
TAGS: legacy_candidate=yes | sys_path_hack=no | duplicate_basename=no
--------------------------------------------------------------------------------
     1: name: Interview Add-on (offline)
     2: on:
     3:   push: { branches: [ '**' ] }
     4:   pull_request: { branches: [ '**' ] }
     5: jobs:
     6:   interview:
     7:     runs-on: ubuntu-latest
     8:     steps:
     9:       - uses: actions/checkout@v4
    10:       - uses: actions/setup-python@v5
    11:         with: { python-version: '3.10' }
    12:       - name: Install deps
    13:         run: |
    14:           python -m pip install -U pip
    15:           if [ -f requirements.txt ]; then pip install -r requirements.txt; fi
    16:           pip install pytest
    17:       - name: Run offline tests
    18:         env: { OFFLINE: '1', PYTHONPATH: 'src' }
    19:         run: pytest -q -k 'not online or e2e'
--------------------------------------------------------------------------------
END FILE    .github/workflows-archive/interview-addon.yml
================================================================================
================================================================================
BEGIN FILE  .github/workflows-archive/interview.yml  (584 bytes)
TAGS: legacy_candidate=yes | sys_path_hack=no | duplicate_basename=no
--------------------------------------------------------------------------------
     1: name: Interview (offline)
     2: on:
     3:   push: { branches: [ "**" ] }
     4:   pull_request: { branches: [ "**" ] }
     5: jobs:
     6:   offline:
     7:     runs-on: ubuntu-latest
     8:     steps:
     9:       - uses: actions/checkout@v4
    10:       - uses: actions/setup-python@v5
    11:         with: { python-version: "3.10" }
    12:       - name: Install deps
    13:         run: |
    14:           python -m pip install -U pip
    15:           if [ -f requirements.txt ]; then pip install -r requirements.txt; fi
    16:           pip install pytest
    17:       - name: Run offline tests
    18:         env: { OFFLINE: "1", PYTHONPATH: "src" }
    19:         run: pytest -q -k "not online or e2e"
--------------------------------------------------------------------------------
END FILE    .github/workflows-archive/interview.yml
================================================================================
================================================================================
BEGIN FILE  .github/workflows-archive/nightly.yml  (736 bytes)
TAGS: legacy_candidate=yes | sys_path_hack=no | duplicate_basename=no
--------------------------------------------------------------------------------
     1: name: Nightly
     2: 
     3: on:
     4:   schedule:
     5:     - cron: '0 17 * * *'  # 每天 01:00 台灣時間左右
     6:   workflow_dispatch:
     7: 
     8: jobs:
     9:   nightly:
    10:     runs-on: ubuntu-latest
    11:     timeout-minutes: 25
    12:     steps:
    13:       - uses: actions/checkout@v4
    14:       - uses: actions/setup-python@v5
    15:         with:
    16:           python-version: '3.10'
    17:           cache: 'pip'
    18:       - name: Install system deps
    19:         run: sudo apt-get update && sudo apt-get install -y tesseract-ocr
    20:       - name: Install Python deps
    21:         run: |
    22:           python -m pip install -U pip
    23:           pip install -r requirements.txt
    24:       - name: Run tests (OFFLINE)
    25:         env:
    26:           OFFLINE: "1"
    27:           PYTHONPATH: "src"
    28:         run: |
    29:           pytest -q --maxfail=1 --disable-warnings
--------------------------------------------------------------------------------
END FILE    .github/workflows-archive/nightly.yml
================================================================================
================================================================================
BEGIN FILE  .github/workflows-archive/offline-ci.yml  (1289 bytes)
TAGS: legacy_candidate=yes | sys_path_hack=no | duplicate_basename=no
--------------------------------------------------------------------------------
     1: name: offline-ci
     2: on:
     3:   push:
     4:     branches: [ "main", "develop" ]
     5:   pull_request:
     6:     branches: [ "main", "develop" ]
     7: jobs:
     8:   offline-tests:
     9:     runs-on: ubuntu-latest
    10:     steps:
    11:       - uses: actions/checkout@v4
    12:       - uses: actions/setup-python@v5
    13:         with:
    14:           python-version: '3.10'
    15:       - name: Install pytest only (offline-friendly)
    16:         run: |
    17:           python -m pip install -U pip
    18:           python -m pip install pytest
    19:       - name: Run offline tests
    20:         env:
    21:           OFFLINE: "1"
    22:           PYTHONPATH: "src"
    23:         run: |
    24:           python -m pytest -q -k "not online"
    25: 
    26: 
    27: spam-report:
    28:   runs-on: ubuntu-latest
    29:   env:
    30:     OFFLINE: "1"
    31:   steps:
    32:     - uses: actions/checkout@v4
    33:     - name: Set up Python
    34:       uses: actions/setup-python@v5
    35:       with:
    36:         python-version: "3.10"
    37:     - name: Install deps (offline-friendly)
    38:       run: |
    39:         python -m pip install --upgrade pip
    40:         python -m pip install -e .
    41:     - name: Spam scan
    42:       run: |
    43:         python -m cli.sma spam-scan --inbox data/inbox --out reports --reload || true
    44:     - name: Upload spam report
    45:       uses: actions/upload-artifact@v4
    46:       with:
    47:         name: spam-report
    48:         path: |
    49:           reports/spam_scan.html
    50:           reports/spam_scan.csv
    51:           reports/spam_scan.json
--------------------------------------------------------------------------------
END FILE    .github/workflows-archive/offline-ci.yml
================================================================================
================================================================================
BEGIN FILE  .github/workflows-archive/release.yml  (1528 bytes)
TAGS: legacy_candidate=yes | sys_path_hack=no | duplicate_basename=no
--------------------------------------------------------------------------------
     1: name: release
     2: on:
     3:   push: { tags: [ 'v*' ] }
     4:   workflow_dispatch:
     5: permissions: { contents: read, packages: write }
     6: jobs:
     7:   build-and-push:
     8:     runs-on: ubuntu-latest
     9:     steps:
    10:       - uses: actions/checkout@v4
    11:       - uses: actions/setup-python@v5
    12:         with: { python-version: '3.10' }
    13:       - name: Install deps
    14:         run: |
    15:           python -m pip install -U pip
    16:           pip install -r requirements.txt
    17:           pip install isort black flake8 mypy
    18:       - name: Lint & Type check & Test
    19:         env: { PYTHONPATH: src, OFFLINE: "1" }
    20:         run: |
    21:           python -m venv .venv
    22:           . .venv/bin/activate
    23:           pip install -r requirements.txt
    24:           isort .
    25:           black .
    26:           flake8 --config .flake8 .
    27:           mypy --exclude '(^|/)(\.venv|data|build|dist)/' src || true
    28:           pytest -q -k "not online"
    29:       - name: Login to GHCR
    30:         uses: docker/login-action@v3
    31:         with:
    32:           registry: ghcr.io
    33:           username: ${{ github.actor }}
    34:           password: ${{ secrets.GITHUB_TOKEN }}
    35:       - name: Extract Docker metadata
    36:         id: meta
    37:         uses: docker/metadata-action@v5
    38:         with:
    39:           images: ghcr.io/${{ github.repository_owner }}/smart-mail-agent
    40:           tags: |
    41:             type=ref,event=tag
    42:             type=raw,value=latest
    43:       - name: Build and push
    44:         uses: docker/build-push-action@v6
    45:         with:
    46:           context: .
    47:           push: true
    48:           tags: ${{ steps.meta.outputs.tags }}
    49:           labels: ${{ steps.meta.outputs.labels }}
--------------------------------------------------------------------------------
END FILE    .github/workflows-archive/release.yml
================================================================================
================================================================================
BEGIN FILE  .github/workflows-archive/security.yml  (805 bytes)
TAGS: legacy_candidate=yes | sys_path_hack=no | duplicate_basename=no
--------------------------------------------------------------------------------
     1: name: security
     2: on:
     3:   pull_request:
     4:   push:
     5:     branches: [ "main", "develop" ]
     6: jobs:
     7:   sec-scan:
     8:     runs-on: ubuntu-latest
     9:     steps:
    10:       - uses: actions/checkout@v4
    11:       - uses: actions/setup-python@v5
    12:         with:
    13:           python-version: "3.10"
    14:       - name: Install scanners
    15:         run: |
    16:           python -m pip install -U pip
    17:           python -m pip install bandit detect-secrets
    18:       - name: Bandit
    19:         run: |
    20:           bandit -q -r -x tests,data,.venv .
    21:       - name: Detect Secrets
    22:         run: |
    23:           detect-secrets scan --all-files --exclude-files '.*(\.venv|\.git|data|artifacts|reports|archive).*' > ds_report.json
    24:       - name: Upload detect-secrets report
    25:         uses: actions/upload-artifact@v4
    26:         with:
    27:           name: detect-secrets
    28:           path: ds_report.json
--------------------------------------------------------------------------------
END FILE    .github/workflows-archive/security.yml
================================================================================
================================================================================
BEGIN FILE  .github/workflows/ci.yml  (874 bytes)
TAGS: legacy_candidate=no | sys_path_hack=no | duplicate_basename=no
--------------------------------------------------------------------------------
     1: name: build
     2: on:
     3:   push: { branches: [ main ] }
     4:   pull_request: { branches: [ main ] }
     5: 
     6: permissions:
     7:   contents: read
     8: 
     9: jobs:
    10:   test:
    11:     name: tests
    12:     runs-on: ubuntu-latest
    13:     strategy:
    14:       fail-fast: false
    15:       matrix:
    16:         python-version: ["3.10"]
    17: 
    18:     env:
    19:       PYTHONPATH: .:src
    20:       OFFLINE: "1"
    21: 
    22:     steps:
    23:       - uses: actions/checkout@v4
    24:       - uses: actions/setup-python@v5
    25:         with:
    26:           python-version: ${{ matrix.python-version }}
    27: 
    28:       - name: Install deps
    29:         run: |
    30:           python -m pip install -U pip
    31:           pip install -U pytest pytest-cov black isort ruff
    32: 
    33:       - name: Lint
    34:         run: |
    35:           ruff check src tests
    36:           black --check src tests
    37:           isort --check-only src tests
    38: 
    39:       - name: Tests
    40:         run: |
    41:           pytest -q --disable-warnings --cov=src --cov-report=xml --cov-report=term-missing
--------------------------------------------------------------------------------
END FILE    .github/workflows/ci.yml
================================================================================
================================================================================
BEGIN FILE  .gitignore  (252 bytes)
TAGS: legacy_candidate=no | sys_path_hack=no | duplicate_basename=no
--------------------------------------------------------------------------------
     1: # venv / caches
     2: .venv/
     3: __pycache__/
     4: *.pyc
     5: .pytest_cache/
     6: # build artifacts
     7: build/
     8: dist/
     9: *.egg-info/
    10: # editor
    11: *.swp
    12: .DS_Store
    13: # data outputs (保留版本但可視需要忽略)
    14: data/output/
    15: # local env
    16: .env
    17: reports/
    18: audit_bundle_*
    19: src_lowcov/
    20: data/*.db
--------------------------------------------------------------------------------
END FILE    .gitignore
================================================================================
================================================================================
BEGIN FILE  .portfolio_hidden/.archive/legacy/src/policy_engine.py  (65 bytes)
TAGS: legacy_candidate=yes | sys_path_hack=no | duplicate_basename=no
--------------------------------------------------------------------------------
     1: from smart_mail_agent.core.policy_engine import *  # legacy shim
--------------------------------------------------------------------------------
END FILE    .portfolio_hidden/.archive/legacy/src/policy_engine.py
================================================================================
================================================================================
BEGIN FILE  .portfolio_hidden/.archive/legacy/src/sma_types.py  (61 bytes)
TAGS: legacy_candidate=yes | sys_path_hack=no | duplicate_basename=no
--------------------------------------------------------------------------------
     1: from smart_mail_agent.core.sma_types import *  # legacy shim
--------------------------------------------------------------------------------
END FILE    .portfolio_hidden/.archive/legacy/src/sma_types.py
================================================================================
================================================================================
BEGIN FILE  .portfolio_hidden/.dev/__init__.py  (0 bytes)
TAGS: legacy_candidate=no | sys_path_hack=no | duplicate_basename=no
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
END FILE    .portfolio_hidden/.dev/__init__.py
================================================================================
================================================================================
BEGIN FILE  .portfolio_hidden/.dev/apply_classifier_fallback_fix_v1.py  (6999 bytes)
TAGS: legacy_candidate=no | sys_path_hack=no | duplicate_basename=no
--------------------------------------------------------------------------------
     1: #!/usr/bin/env python3
     2: # 檔案位置：tools/apply_classifier_fallback_fix_v1.py
     3: # 目的：覆寫 src/classifier.py（僅調整 fallback 規則：只有「低信心 且 泛用詞」才改成「其他」）
     4: 
     5: from pathlib import Path
     6: 
     7: CLASSIFIER_CODE = r'''#!/usr/bin/env python3
     8: # 檔案位置：src/classifier.py
     9: # 模組用途：
    10: # 1. 提供 IntentClassifier 類別，使用模型或外部注入 pipeline 進行郵件意圖分類
    11: # 2. 支援 CLI 直接執行分類（離線可用；測試可注入 mock）
    12: 
    13: from __future__ import annotations
    14: 
    15: import argparse
    16: import json
    17: import re
    18: from pathlib import Path
    19: from typing import Any, Callable, Dict, Optional
    20: 
    21: from transformers import AutoModelForSequenceClassification, AutoTokenizer, pipeline  # type: ignore
    22: from utils.logger import logger  # 統一日誌
    23: 
    24: # ===== 規則關鍵字（含中文常見商務字眼）=====
    25: RE_QUOTE = re.compile(
    26:     r"(報價|報價單|quotation|price|價格|採購|合作|方案|洽詢|詢價|訂購|下單)",
    27:     re.I,
    28: )
    29: NEG_WORDS = ["爛", "糟", "無法", "抱怨", "氣死", "差", "不滿", "品質差", "不舒服", "難用", "處理太慢"]
    30: NEG_RE = re.compile("|".join(map(re.escape, NEG_WORDS)))
    31: GENERIC_WORDS = ["hi", "hello", "test", "how are you", "你好", "您好", "請問"]
    32: 
    33: 
    34: def smart_truncate(text: str, max_chars: int = 1000) -> str:
    35:     """智慧截斷輸入文字，保留前中後資訊片段。"""
    36:     if len(text) <= max_chars:
    37:         return text
    38:     head = text[: int(max_chars * 0.4)]
    39:     mid_start = int(len(text) / 2 - max_chars * 0.15)
    40:     mid_end = int(len(text) / 2 + max_chars * 0.15)
    41:     middle = text[mid_start:mid_end]
    42:     tail = text[-int(max_chars * 0.3) :]
    43:     return f"{head}\n...\n{middle}\n...\n{tail}"
    44: 
    45: 
    46: class IntentClassifier:
    47:     """意圖分類器：可用 HF pipeline 或外部注入的 pipeline（測試/離線）。"""
    48: 
    49:     def __init__(
    50:         self,
    51:         model_path: str,
    52:         pipeline_override: Optional[Callable[..., Any]] = None,
    53:         *,
    54:         local_files_only: bool = True,
    55:         low_conf_threshold: float = 0.4,
    56:     ) -> None:
    57:         """
    58:         參數：
    59:             model_path: 模型路徑或名稱（離線時需為本地路徑）
    60:             pipeline_override: 測試或自定義時注入的函式，簽名為 (text, truncation=True) -> [ {label, score} ]
    61:             local_files_only: 是否禁止網路抓取模型（預設 True，避免 CI/無網路掛掉）
    62:             low_conf_threshold: 低信心 fallback 門檻
    63:         """
    64:         self.model_path = model_path
    65:         self.low_conf_threshold = low_conf_threshold
    66: 
    67:         if pipeline_override is not None:
    68:             # 測試/離線：直接用外部 pipeline，避免載入 HF 權重
    69:             self.pipeline = pipeline_override  # type: ignore[assignment]
    70:             self.tokenizer = None
    71:             self.model = None
    72:             logger.info("[IntentClassifier] 使用外部注入的 pipeline（不載入模型）")
    73:         else:
    74:             logger.info(f"[IntentClassifier] 載入模型：{model_path}")
    75:             self.tokenizer = AutoTokenizer.from_pretrained(model_path, local_files_only=local_files_only)
    76:             self.model = AutoModelForSequenceClassification.from_pretrained(
    77:                 model_path, local_files_only=local_files_only
    78:             )
    79:             self.pipeline = pipeline("text-classification", model=self.model, tokenizer=self.tokenizer)
    80: 
    81:     @staticmethod
    82:     def _is_negative(text: str) -> bool:
    83:         return bool(NEG_RE.search(text))
    84: 
    85:     @staticmethod
    86:     def _is_generic(text: str) -> bool:
    87:         return any(g in text.lower() for g in GENERIC_WORDS)
    88: 
    89:     def classify(self, subject: str, content: str) -> Dict[str, Any]:
    90:         """執行分類與 fallback 修正。"""
    91:         raw_text = f"{subject.strip()}\n{content.strip()}"
    92:         text = smart_truncate(raw_text)
    93: 
    94:         try:
    95:             # 支援：transformers pipeline 或外部函式 (text, truncation=True) -> [ {label, score} ]
    96:             result_list = self.pipeline(text, truncation=True)  # type: ignore[misc]
    97:             result = result_list[0] if isinstance(result_list, list) else result_list
    98:             model_label = str(result.get("label", "unknown"))
    99:             confidence = float(result.get("score", 0.0))
   100:         except Exception as e:  # 不得因單一錯誤中斷流程
   101:             logger.error(f"[IntentClassifier] 推論失敗：{e}")
   102:             return {
   103:                 "predicted_label": "unknown",
   104:                 "confidence": 0.0,
   105:                 "subject": subject,
   106:                 "body": content,
   107:             }
   108: 
   109:         # ===== Fallback 決策：規則 > 情緒 > 低信心泛用 =====
   110:         fallback_label = model_label
   111:         if RE_QUOTE.search(text):
   112:             fallback_label = "業務接洽或報價"
   113:         elif self._is_negative(text):
   114:             fallback_label = "投訴與抱怨"
   115:         elif confidence < self.low_conf_threshold and self._is_generic(text):
   116:             # 只有在「低信心」且文字屬於泛用招呼/測試語句時，才降為「其他」
   117:             fallback_label = "其他"
   118: 
   119:         if fallback_label != model_label:
   120:             logger.info(f"[Fallback] 類別調整：{model_label} → {fallback_label}（信心值：{confidence:.4f}）")
   121: 
   122:         return {
   123:             "predicted_label": fallback_label,
   124:             "confidence": confidence,
   125:             "subject": subject,
   126:             "body": content,
   127:         }
   128: 
   129: 
   130: def _cli() -> None:
   131:     parser = argparse.ArgumentParser(description="信件意圖分類 CLI")
   132:     parser.add_argument("--model", type=str, required=True, help="模型路徑（本地路徑或名稱）")
   133:     parser.add_argument("--subject", type=str, required=True, help="郵件主旨")
   134:     parser.add_argument("--content", type=str, required=True, help="郵件內容")
   135:     parser.add_argument(
   136:         "--output",
   137:         type=str,
   138:         default="data/output/classify_result.json",
   139:         help="輸出 JSON 檔路徑",
   140:     )
   141:     parser.add_argument(
   142:         "--allow-online",
   143:         action="store_true",
   144:         help="允許線上抓取模型（預設關閉，CI/離線建議關）",
   145:     )
   146:     args = parser.parse_args()
   147: 
   148:     clf = IntentClassifier(model_path=args.model, pipeline_override=None, local_files_only=not args.allow_online)
   149:     result = clf.classify(subject=args.subject, content=args.content)
   150: 
   151:     output_path = Path(args.output)
   152:     output_path.parent.mkdir(parents=True, exist_ok=True)
   153:     with open(output_path, "w", encoding="utf-8") as f:
   154:         json.dump(result, f, ensure_ascii=False, indent=2)
   155: 
   156:     logger.info(f"[classifier.py CLI] 分類完成，結果已輸出至 {output_path}")
   157:     print(json.dumps(result, ensure_ascii=False, indent=2))
   158: 
   159: 
   160: if __name__ == "__main__":
   161:     _cli()
   162: '''
   163: 
   164: 
   165: def main():
   166:     target = Path("src/classifier.py")
   167:     target.parent.mkdir(parents=True, exist_ok=True)
   168:     target.write_text(CLASSIFIER_CODE, encoding="utf-8")
   169:     print(f"[ok] 覆寫 {target} 完成（已更新 fallback 規則）")
   170: 
   171: 
   172: if __name__ == "__main__":
   173:     main()
--------------------------------------------------------------------------------
END FILE    .portfolio_hidden/.dev/apply_classifier_fallback_fix_v1.py
================================================================================
================================================================================
BEGIN FILE  .portfolio_hidden/.dev/apply_docker_ci_v1.py  (6395 bytes)
TAGS: legacy_candidate=no | sys_path_hack=no | duplicate_basename=no
--------------------------------------------------------------------------------
     1: #!/usr/bin/env python3
     2: # 檔案位置：tools/apply_docker_ci_v1.py
     3: # 模組用途：一鍵建立/更新 Dockerfile、.dockerignore、docker-compose.yml、docker entrypoint、Docker CI workflow
     4: 
     5: import argparse
     6: from pathlib import Path
     7: from textwrap import dedent
     8: 
     9: ROOT = Path(__file__).resolve().parents[1]
    10: 
    11: 
    12: def write(path: Path, content: str, force: bool):
    13:     path.parent.mkdir(parents=True, exist_ok=True)
    14:     if path.exists() and not force:
    15:         print(f"[skip] {path} 已存在（未覆蓋）")
    16:         return
    17:     path.write_text(content, encoding="utf-8")
    18:     print(f"[ok]   寫入 {path}")
    19: 
    20: 
    21: def main():
    22:     ap = argparse.ArgumentParser(description="Apply Docker & Compose & Docker CI files")
    23:     ap.add_argument("--force", action="store_true", help="強制覆蓋既有檔案")
    24:     args = ap.parse_args()
    25: 
    26:     files = {
    27:         # ---- Dockerfile ----
    28:         ROOT / "Dockerfile": dedent(
    29:             """
    30:             # syntax=docker/dockerfile:1.6
    31:             # 檔案位置：Dockerfile
    32:             # 模組用途：Smart-Mail-Agent 容器建置（python:3.11-slim、非 root、Noto CJK 字型）
    33: 
    34:             FROM python:3.11-slim AS base
    35: 
    36:             # 系統依賴與字型（FPDF 中文）
    37:             RUN apt-get update && apt-get install -y --no-install-recommends \\
    38:                 gosu tini locales fonts-noto-cjk \\
    39:                 && rm -rf /var/lib/apt/lists/*
    40: 
    41:             # 設定 UTF-8
    42:             RUN sed -i '/zh_TW.UTF-8/s/^# //g' /etc/locale.gen && \\
    43:                 sed -i '/en_US.UTF-8/s/^# //g' /etc/locale.gen && \\
    44:                 locale-gen
    45:             ENV LANG=zh_TW.UTF-8 LC_ALL=zh_TW.UTF-8
    46: 
    47:             # 非 root 使用者
    48:             ARG APP_USER=app
    49:             RUN useradd -ms /bin/bash ${APP_USER}
    50: 
    51:             WORKDIR /app
    52:             COPY requirements.txt /app/requirements.txt
    53:             RUN pip install -U pip && pip install -r /app/requirements.txt
    54: 
    55:             # 複製專案
    56:             COPY . /app
    57: 
    58:             # 預設環境
    59:             ENV PYTHONUNBUFFERED=1 \\
    60:                 PYTHONPATH=src
    61: 
    62:             # 建立資料目錄與字型連結（若沒給 QUOTE_FONT_PATH，FPDF 仍可用 Noto CJK）
    63:             RUN mkdir -p /app/data /app/logs /app/assets/fonts && \\
    64:                 ln -sf /usr/share/fonts/opentype/noto /app/assets/fonts/system-noto
    65: 
    66:             # 權限
    67:             RUN chown -R ${APP_USER}:${APP_USER} /app
    68:             USER ${APP_USER}
    69: 
    70:             # entrypoint：先初始化 DB，再跑 pipeline（若存在），否則跑 scripts/run_all.py
    71:             RUN chmod +x docker/entrypoint.sh || true
    72: 
    73:             ENTRYPOINT ["/usr/bin/tini","--"]
    74:             CMD ["bash","-lc","docker/entrypoint.sh"]
    75:         """
    76:         ).lstrip(),
    77:         # ---- docker/entrypoint.sh ----
    78:         ROOT / "docker" / "entrypoint.sh": dedent(
    79:             """
    80:             #!/usr/bin/env bash
    81:             # 檔案位置：docker/entrypoint.sh
    82:             # 模組用途：容器啟動：初始化 DB → 執行主流程或 run_all
    83: 
    84:             set -e
    85: 
    86:             echo "[entrypoint] 初始化資料庫…"
    87:             python init_db.py || true
    88: 
    89:             if [ -f "pipeline/main.py" ]; then
    90:               echo "[entrypoint] 執行 pipeline/main.py"
    91:               exec python pipeline/main.py --limit "${LIMIT:-50}" --force
    92:             elif [ -f "scripts/run_all.py" ]; then
    93:               echo "[entrypoint] 執行 scripts/run_all.py"
    94:               exec python scripts/run_all.py
    95:             else
    96:               echo "[entrypoint] 找不到 pipeline/main.py 或 scripts/run_all.py，進入睡眠以便除錯"
    97:               exec tail -f /dev/null
    98:             fi
    99:         """
   100:         ).lstrip(),
   101:         # ---- .dockerignore ----
   102:         ROOT / ".dockerignore": dedent(
   103:             """
   104:             # 檔案位置：.dockerignore
   105:             # 模組用途：避免把不必要檔案打包進 Docker context
   106: 
   107:             .git
   108:             .venv
   109:             __pycache__
   110:             .pytest_cache
   111:             .mypy_cache
   112:             .DS_Store
   113:             *.db
   114:             data/
   115:             logs/
   116:             .env
   117:             .coverage
   118:             dist/
   119:             build/
   120:             .gitignore
   121:             README.md
   122:         """
   123:         ).lstrip(),
   124:         # ---- docker-compose.yml ----
   125:         ROOT / "docker-compose.yml": dedent(
   126:             """
   127:             # 檔案位置：docker-compose.yml
   128:             # 模組用途：本地或伺服器一鍵啟動 Smart-Mail-Agent
   129: 
   130:             services:
   131:               smart-mail-agent:
   132:                 build: .
   133:                 image: smart-mail-agent:local
   134:                 env_file:
   135:                   - .env
   136:                 environment:
   137:                   - PYTHONPATH=src
   138:                   # LIMIT 可覆蓋 entrypoint 的抓信數量
   139:                   - LIMIT=50
   140:                 volumes:
   141:                   - ./data:/app/data
   142:                   - ./logs:/app/logs
   143:                 # 若你沒有 pipeline/main.py，可改成跑 scripts/run_all.py
   144:                 command: []
   145:         """
   146:         ).lstrip(),
   147:         # ---- GitHub Actions：Docker build（驗證能建置） ----
   148:         ROOT / ".github" / "workflows" / "docker.yml": dedent(
   149:             """
   150:             # 檔案位置：.github/workflows/docker.yml
   151:             # 模組用途：在 PR 與 main push 驗證 Docker 能成功 build
   152: 
   153:             name: Docker Build
   154: 
   155:             on:
   156:               push:
   157:                 branches: [ main, master ]
   158:               pull_request:
   159:                 branches: [ main, master ]
   160: 
   161:             jobs:
   162:               docker-build:
   163:                 runs-on: ubuntu-latest
   164:                 steps:
   165:                   - name: Checkout
   166:                     uses: actions/checkout@v4
   167: 
   168:                   - name: Set up QEMU
   169:                     uses: docker/setup-qemu-action@v3
   170: 
   171:                   - name: Set up Docker Buildx
   172:                     uses: docker/setup-buildx-action@v3
   173: 
   174:                   - name: Build (no push)
   175:                     uses: docker/build-push-action@v6
   176:                     with:
   177:                       context: .
   178:                       file: ./Dockerfile
   179:                       push: false
   180:                       platforms: linux/amd64
   181:         """
   182:         ).lstrip(),
   183:     }
   184: 
   185:     for p, content in files.items():
   186:         write(p, content, args.force)
   187: 
   188:     print("\\n[提醒] 設定 docker/entrypoint.sh 執行權限：")
   189:     print("chmod +x docker/entrypoint.sh")
   190: 
   191: 
   192: if __name__ == "__main__":
   193:     main()
--------------------------------------------------------------------------------
END FILE    .portfolio_hidden/.dev/apply_docker_ci_v1.py
================================================================================
================================================================================
BEGIN FILE  .portfolio_hidden/.dev/apply_fix_log_writer_v1.py  (5507 bytes)
TAGS: legacy_candidate=no | sys_path_hack=no | duplicate_basename=no
--------------------------------------------------------------------------------
     1: #!/usr/bin/env python3
     2: # 檔案：tools/apply_fix_log_writer_v1.py
     3: # 目的：修正 log_writer 介面，支援 predicted_label / confidence / action / error / summary
     4: #       並讓 src/utils/log_writer.py 轉向使用 src/log_writer.py（避免雙版本走鐘）
     5: 
     6: from __future__ import annotations
     7: 
     8: from pathlib import Path
     9: from textwrap import dedent
    10: 
    11: ROOT = Path(__file__).resolve().parents[1]
    12: 
    13: SRC_LOG_WRITER = dedent(
    14:     """\
    15:     #!/usr/bin/env python3
    16:     # 檔案位置：src/log_writer.py
    17:     # 模組用途：統一寫入 emails_log.db 的工具（企業級欄位與穩定介面）
    18:     from __future__ import annotations
    19: 
    20:     import logging
    21:     import sqlite3
    22:     from datetime import datetime, timezone
    23:     from pathlib import Path
    24:     from typing import Optional
    25: 
    26:     # 統一日誌格式
    27:     logger = logging.getLogger("log_writer")
    28:     if not logger.handlers:
    29:         logging.basicConfig(
    30:             level=logging.INFO,
    31:             format="%(asctime)s [%(levelname)s] [log_writer] %(message)s",
    32:         )
    33: 
    34:     ROOT = Path(__file__).resolve().parents[1]
    35:     DB_PATH = ROOT / "data" / "emails_log.db"
    36: 
    37:     def _ensure_schema(conn: sqlite3.Connection) -> None:
    38:         \"\"\"建立 emails_log 資料表（若不存在）。\"\"\"
    39:         conn.execute(
    40:             '''
    41:             CREATE TABLE IF NOT EXISTS emails_log (
    42:                 id INTEGER PRIMARY KEY AUTOINCREMENT,
    43:                 subject TEXT,
    44:                 content TEXT,
    45:                 summary TEXT,
    46:                 predicted_label TEXT,
    47:                 confidence REAL,
    48:                 action TEXT,
    49:                 error TEXT,
    50:                 created_at TEXT
    51:             )
    52:             '''
    53:         )
    54:         conn.commit()
    55: 
    56:     def log_to_db(
    57:         subject: str,
    58:         content: str = "",
    59:         summary: str = "",
    60:         predicted_label: Optional[str] = None,
    61:         confidence: Optional[float] = None,
    62:         action: str = "",
    63:         error: str = "",
    64:         db_path: Optional[Path] = None,
    65:     ) -> int:
    66:         \"\"\"寫入一筆處理紀錄到 emails_log.db。
    67: 
    68:         參數：
    69:             subject: 題目/主旨
    70:             content: 內文（可省略）
    71:             summary: 摘要（可省略）
    72:             predicted_label: 預測分類（可省略）
    73:             confidence: 信心值（可省略）
    74:             action: 採取動作（可省略）
    75:             error: 錯誤訊息（可省略）
    76:             db_path: 自訂 DB 路徑（測試用）
    77: 
    78:         回傳：
    79:             新增記錄的 rowid（int）
    80:         \"\"\"
    81:         path = Path(db_path) if db_path else DB_PATH
    82:         path.parent.mkdir(parents=True, exist_ok=True)
    83: 
    84:         conn = sqlite3.connect(str(path))
    85:         try:
    86:             _ensure_schema(conn)
    87:             cur = conn.execute(
    88:                 '''
    89:                 INSERT INTO emails_log (
    90:                     subject, content, summary, predicted_label,
    91:                     confidence, action, error, created_at
    92:                 ) VALUES (?, ?, ?, ?, ?, ?, ?, ?)
    93:                 ''',
    94:                 (
    95:                     subject,
    96:                     content,
    97:                     summary,
    98:                     predicted_label,
    99:                     float(confidence) if confidence is not None else None,
   100:                     action,
   101:                     error,
   102:                     datetime.now(timezone.utc).isoformat(),
   103:                 ),
   104:             )
   105:             conn.commit()
   106:             rowid = int(cur.lastrowid or 0)
   107:             logger.info("已記錄：%s / %s / 信心 %s", predicted_label or "-", action or "-", f"{confidence:.4f}" if confidence is not None else "-")
   108:             return rowid
   109:         finally:
   110:             conn.close()
   111: 
   112:     if __name__ == "__main__":
   113:         # 提供簡易 CLI：python -m src.log_writer "主旨" --label "分類"
   114:         import argparse
   115: 
   116:         parser = argparse.ArgumentParser()
   117:         parser.add_argument("subject", help="主旨")
   118:         parser.add_argument("--content", default="", help="內文")
   119:         parser.add_argument("--summary", default="", help="摘要")
   120:         parser.add_argument("--label", dest="predicted_label", default=None, help="分類")
   121:         parser.add_argument("--confidence", type=float, default=None, help="信心值")
   122:         parser.add_argument("--action", default="", help="動作")
   123:         parser.add_argument("--error", default="", help="錯誤訊息")
   124:         args = parser.parse_args()
   125: 
   126:         log_to_db(
   127:             subject=args.subject,
   128:             content=args.content,
   129:             summary=args.summary,
   130:             predicted_label=args.predicted_label,
   131:             confidence=args.confidence,
   132:             action=args.action,
   133:             error=args.error,
   134:         )
   135:         print("[OK] 已寫入 emails_log")
   136:     """
   137: )
   138: 
   139: UTILS_LOG_WRITER = dedent(
   140:     """\
   141:     #!/usr/bin/env python3
   142:     # 檔案位置：src/utils/log_writer.py
   143:     # 模組用途：向後相容封裝（統一轉用 src.log_writer.log_to_db）
   144:     from __future__ import annotations
   145: 
   146:     from src.log_writer import log_to_db  # re-export
   147:     __all__ = ["log_to_db"]
   148:     """
   149: )
   150: 
   151: 
   152: def main() -> None:
   153:     # 覆寫 src/log_writer.py
   154:     p1 = ROOT / "src" / "log_writer.py"
   155:     p1.write_text(SRC_LOG_WRITER, encoding="utf-8")
   156:     print(f"[ok]   寫入 {p1}")
   157: 
   158:     # 覆寫/建立 src/utils/log_writer.py（轉向）
   159:     p2 = ROOT / "src" / "utils" / "log_writer.py"
   160:     p2.parent.mkdir(parents=True, exist_ok=True)
   161:     p2.write_text(UTILS_LOG_WRITER, encoding="utf-8")
   162:     print(f"[ok]   寫入 {p2}")
   163: 
   164: 
   165: if __name__ == "__main__":
   166:     main()
--------------------------------------------------------------------------------
END FILE    .portfolio_hidden/.dev/apply_fix_log_writer_v1.py
================================================================================
================================================================================
BEGIN FILE  .portfolio_hidden/.dev/apply_fix_round9.py  (3303 bytes)
TAGS: legacy_candidate=no | sys_path_hack=yes | duplicate_basename=no
--------------------------------------------------------------------------------
     1: #!/usr/bin/env python3
     2: # 檔案：tools/apply_fix_round9.py
     3: # 目的：把 pipeline/main.py 覆寫成安全可執行版本（支援 OFFLINE=1，IMAP 錯誤不崩潰）
     4: 
     5: from __future__ import annotations
     6: 
     7: from pathlib import Path
     8: 
     9: ROOT = Path(__file__).resolve().parents[1]
    10: 
    11: SAFE_PIPELINE = """#!/usr/bin/env python3
    12: # 檔案位置：pipeline/main.py
    13: # 目的：Smart-Mail-Agent 入口流程（離線安全、IMAP 認證失敗不中斷）
    14: 
    15: from __future__ import annotations
    16: import os
    17: import sys
    18: import imaplib
    19: import logging
    20: from pathlib import Path
    21: 
    22: # [SMA_SYS_PATH] 確保可匯入 src 模組
    23: _ROOT = Path(__file__).resolve().parents[1]
    24: _SRC = _ROOT / "src"
    25: if str(_SRC) not in sys.path:
    26:     sys.path.insert(0, str(_SRC))
    27: 
    28: logger = logging.getLogger("Pipeline")
    29: if not logger.handlers:
    30:     logging.basicConfig(
    31:         level=logging.INFO,
    32:         format="%(asctime)s [%(levelname)s] [%(name)s] %(message)s"
    33:     )
    34: 
    35: def fetch_emails(IMAP_HOST: str, IMAP_USER: str, IMAP_PASS: str, folder: str = "INBOX", limit: int = 50, force: bool = False) -> list[str]:
    36:     \"\"\"安全抓信：
    37:     - OFFLINE=1 直接跳過
    38:     - 認證失敗或任何錯誤不拋出
    39:     - 回傳空清單也視為成功（不中斷整體流程）
    40:     \"\"\"
    41:     if os.getenv("OFFLINE", "0") == "1":
    42:         logger.info("[IMAP] OFFLINE 模式，跳過抓信")
    43:         return []
    44: 
    45:     results: list[str] = []
    46:     try:
    47:         with imaplib.IMAP4_SSL(IMAP_HOST) as imap:
    48:             imap.login(IMAP_USER, IMAP_PASS)
    49:             typ, _ = imap.select(folder, readonly=True)
    50:             if typ != "OK":
    51:                 logger.warning("[IMAP] 選擇資料夾失敗，改用 INBOX")
    52:                 imap.select("INBOX", readonly=True)
    53:             typ, data = imap.search(None, "ALL")
    54:             if typ != "OK":
    55:                 logger.warning("[IMAP] 搜尋郵件失敗")
    56:                 return []
    57:             ids = data[0].split() if data and data[0] else []
    58:             if limit and len(ids) > limit:
    59:                 ids = ids[-limit:]
    60:             # 如需取信件內容，可在此做 imap.fetch；此處先保持空清單以確保流程不中斷。
    61:             return results
    62:     except imaplib.IMAP4.error as e:
    63:         logger.warning("[IMAP] 認證失敗：%s", e)
    64:         return []
    65:     except Exception as e:
    66:         logger.exception("[IMAP] 抓信未預期錯誤：%s", e)
    67:         return []
    68: 
    69: def run_pipeline(limit: int = 50, force: bool = False) -> int:
    70:     logger.info("[Pipeline] 開始擷取郵件")
    71:     IMAP_HOST = os.getenv("IMAP_HOST", "imap.gmail.com")
    72:     IMAP_USER = os.getenv("IMAP_USER", "")
    73:     IMAP_PASS = os.getenv("IMAP_PASS", "")
    74:     _ = fetch_emails(IMAP_HOST, IMAP_USER, IMAP_PASS, limit=limit, force=force)
    75:     logger.info("[Pipeline] 完成")
    76:     return 0
    77: 
    78: if __name__ == "__main__":
    79:     import argparse
    80:     parser = argparse.ArgumentParser()
    81:     parser.add_argument("--limit", type=int, default=50)
    82:     parser.add_argument("--force", action="store_true")
    83:     args = parser.parse_args()
    84:     raise SystemExit(run_pipeline(limit=args.limit, force=args.force))
    85: """
    86: 
    87: 
    88: def main() -> None:
    89:     target = ROOT / "pipeline" / "main.py"
    90:     target.parent.mkdir(parents=True, exist_ok=True)
    91:     target.write_text(SAFE_PIPELINE, encoding="utf-8")
    92:     print(f"[ok]  覆寫 {target}")
    93: 
    94: 
    95: if __name__ == "__main__":
    96:     main()
--------------------------------------------------------------------------------
END FILE    .portfolio_hidden/.dev/apply_fix_round9.py
================================================================================
================================================================================
BEGIN FILE  .portfolio_hidden/.dev/apply_imap_debug_v2.py  (2564 bytes)
TAGS: legacy_candidate=no | sys_path_hack=no | duplicate_basename=no
--------------------------------------------------------------------------------
     1: #!/usr/bin/env python3
     2: # 檔案：tools/apply_imap_debug_v2.py
     3: # 作用：覆寫 scripts/imap_debug.py，修正檔首縮排/三引號造成的語法錯誤
     4: 
     5: from __future__ import annotations
     6: 
     7: from pathlib import Path
     8: 
     9: ROOT = Path(__file__).resolve().parents[1]
    10: OUT = ROOT / "scripts" / "imap_debug.py"
    11: 
    12: CONTENT = """#!/usr/bin/env python3
    13: # 檔案：scripts/imap_debug.py
    14: # 目的：用 .env 的 IMAP_* 做連線與登入測試，輸出細節與常見修法提示
    15: 
    16: from __future__ import annotations
    17: import os
    18: import imaplib
    19: import ssl
    20: 
    21: # 載入 .env
    22: try:
    23:     from dotenv import load_dotenv  # type: ignore
    24:     load_dotenv()
    25: except Exception:
    26:     pass
    27: 
    28: 
    29: def main() -> int:
    30:     host = os.getenv("IMAP_HOST", "")
    31:     user = os.getenv("IMAP_USER", "")
    32:     pwd = os.getenv("IMAP_PASS", "")
    33:     folder = os.getenv("IMAP_FOLDER", "INBOX")
    34: 
    35:     print(f"[IMAP] host={host} folder={folder} user={user}")
    36:     if not all([host, user, pwd]):
    37:         print("[IMAP] 參數不足：請設定 IMAP_HOST / IMAP_USER / IMAP_PASS")
    38:         return 2
    39: 
    40:     try:
    41:         ctx = ssl.create_default_context()
    42:         with imaplib.IMAP4_SSL(host, ssl_context=ctx) as im:
    43:             print("[IMAP] 嘗試登入…")
    44:             im.login(user, pwd)
    45:             print("[IMAP] 登入成功")
    46:             typ, _ = im.select(folder, readonly=True)
    47:             print(f"[IMAP] select {folder}：{typ}")
    48:             typ, data = im.search(None, "ALL")
    49:             ids = data[0].split() if (typ == "OK" and data and data[0]) else []
    50:             print(f"[IMAP] 搜尋 ALL：{typ}，可見郵件數：{len(ids)}")
    51:             return 0
    52:     except imaplib.IMAP4.error as e:
    53:         print(f"[IMAP][AUTH] 認證失敗：{e}")
    54:         print(
    55:             "== 常見修法 ==\\n"
    56:             "1) Gmail → 設定 → 轉寄與 POP/IMAP → 啟用 IMAP\\n"
    57:             "2) 必須使用『應用程式密碼』當作 IMAP_PASS（不是一般登入密碼）\\n"
    58:             "3) 兩步驟驗證開啟後，到『Google 帳戶→安全性→應用程式密碼』產生 16 碼\\n"
    59:             "4) 產生的 16 碼請去除空白貼到 .env（避免隱藏空白）\\n"
    60:             "5) SMTP_PASS 與 IMAP_PASS 可分開各自生成（建議）"
    61:         )
    62:         return 1
    63:     except Exception as e:
    64:         print(f"[IMAP][ERR] 一般錯誤：{e!r}")
    65:         return 3
    66: 
    67: 
    68: if __name__ == "__main__":
    69:     raise SystemExit(main())
    70: """
    71: 
    72: 
    73: def main() -> None:
    74:     OUT.parent.mkdir(parents=True, exist_ok=True)
    75:     OUT.write_text(CONTENT, encoding="utf-8")
    76:     print(f"[ok] 寫入 {OUT}")
    77: 
    78: 
    79: if __name__ == "__main__":
    80:     main()
--------------------------------------------------------------------------------
END FILE    .portfolio_hidden/.dev/apply_imap_debug_v2.py
================================================================================
================================================================================
BEGIN FILE  .portfolio_hidden/.dev/apply_mailer_online_tests_v1.py  (3021 bytes)
TAGS: legacy_candidate=no | sys_path_hack=no | duplicate_basename=no
--------------------------------------------------------------------------------
     1: #!/usr/bin/env python3
     2: """tools/apply_mailer_online_tests_v1.py
     3: 建立「線上寄信」整合測試與 Makefile 目標：
     4: - tests/test_mailer_online.py：呼叫 scripts/online_check.py，斷言寄信成功訊息
     5: - pytest.ini：加入 pytest -m online 的標記說明
     6: - Makefile：新增 smtp-test-online 目標
     7: """
     8: 
     9: from __future__ import annotations
    10: 
    11: import re
    12: from pathlib import Path
    13: 
    14: ROOT = Path(__file__).resolve().parents[1]
    15: 
    16: 
    17: def write(p: Path, text: str) -> None:
    18:     p.parent.mkdir(parents=True, exist_ok=True)
    19:     p.write_text(text, encoding="utf-8")
    20:     print(f"[ok] write {p}")
    21: 
    22: 
    23: # 1) 建立線上寄信測試
    24: write(
    25:     ROOT / "tests" / "test_mailer_online.py",
    26:     """#!/usr/bin/env python3
    27: # tests/test_mailer_online.py
    28: # 在 ON-LINE 環境下，實際寄一封測試信到 REPLY_TO，驗證 SMTP 是否可用。
    29: from __future__ import annotations
    30: import os
    31: import pathlib
    32: import subprocess
    33: import sys
    34: import pytest
    35: 
    36: pytestmark = pytest.mark.online
    37: 
    38: REPO_ROOT = pathlib.Path(__file__).resolve().parents[1]
    39: 
    40: def _skip_if_no_env() -> None:
    41:     required = ["SMTP_USER", "SMTP_PASS", "SMTP_HOST", "SMTP_PORT", "REPLY_TO"]
    42:     missing = [k for k in required if not os.getenv(k)]
    43:     if os.getenv("OFFLINE", "0") == "1" or missing:
    44:         pytest.skip(f"缺少環境變數或 OFFLINE=1，略過線上寄信測試。missing={missing}")
    45: 
    46: def test_smtp_live_send_ok() -> None:
    47:     _skip_if_no_env()
    48:     proc = subprocess.run(
    49:         [sys.executable, str(REPO_ROOT / "scripts" / "online_check.py")],
    50:         text=True,
    51:         capture_output=True,
    52:         check=False,
    53:     )
    54:     assert proc.returncode == 0, f"online_check.py 退出碼非 0：\\n{proc.stderr or proc.stdout}"
    55:     assert "SMTP 寄信成功" in proc.stdout, f"未偵測到 SMTP 成功訊息：\\n{proc.stdout}"
    56: """,
    57: )
    58: 
    59: # 2) 確保 pytest.ini 有 online 標記
    60: pytest_ini = ROOT / "pytest.ini"
    61: if pytest_ini.exists():
    62:     txt = pytest_ini.read_text(encoding="utf-8")
    63:     if "online:" not in txt:
    64:         if "markers" not in txt:
    65:             txt = txt.rstrip() + "\nmarkers =\n    online: tests that hit real SMTP/IMAP\n"
    66:         else:
    67:             txt = re.sub(
    68:                 r"(markers\s*=\s*)([^\n]*?)\n",
    69:                 r"\\1\\2\n    online: tests that hit real SMTP/IMAP\n",
    70:                 txt,
    71:                 flags=re.IGNORECASE,
    72:             )
    73:         pytest_ini.write_text(txt, encoding="utf-8")
    74:         print("[ok] update pytest.ini markers")
    75: else:
    76:     write(pytest_ini, "[pytest]\nmarkers =\n    online: tests that hit real SMTP/IMAP\n")
    77: 
    78: # 3) Makefile 增加 smtp-test-online 目標
    79: mk = ROOT / "Makefile"
    80: target = "\n.PHONY: smtp-test-online\nsmtp-test-online:\n\tOFFLINE=0 PYTHONPATH=src .venv/bin/pytest -q -m online -k mailer_online -s\n"
    81: if mk.exists():
    82:     t = mk.read_text(encoding="utf-8")
    83:     if "smtp-test-online:" not in t:
    84:         mk.write_text(t + target, encoding="utf-8")
    85:         print("[ok] append Makefile target: smtp-test-online")
    86: else:
    87:     write(mk, target)
    88: 
    89: print("\n[done] apply_mailer_online_tests_v1 completed.")
--------------------------------------------------------------------------------
END FILE    .portfolio_hidden/.dev/apply_mailer_online_tests_v1.py
================================================================================
================================================================================
BEGIN FILE  .portfolio_hidden/.dev/bootstrap_gh_ci.sh  (1738 bytes)
TAGS: legacy_candidate=no | sys_path_hack=no | duplicate_basename=no
--------------------------------------------------------------------------------
     1: #!/usr/bin/env bash
     2: set -euo pipefail
     3: 
     4: # 0) 安裝 gh（Ubuntu/WSL）
     5: if ! command -v gh >/dev/null 2>&1; then
     6:   echo "[info] installing GitHub CLI..."
     7:   sudo apt update
     8:   if ! sudo apt -y install gh; then
     9:     # 官方套件庫（若發行版沒有 gh）
    10:     type -p curl >/dev/null || sudo apt -y install curl
    11:     curl -fsSL https://cli.github.com/packages/githubcli-archive-keyring.gpg \
    12:       | sudo dd of=/usr/share/keyrings/githubcli-archive-keyring.gpg
    13:     sudo chmod go+r /usr/share/keyrings/githubcli-archive-keyring.gpg
    14:     echo "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/githubcli-archive-keyring.gpg] https://cli.github.com/packages stable main" \
    15:       | sudo tee /etc/apt/sources.list.d/github-cli.list >/dev/null
    16:     sudo apt update && sudo apt -y install gh
    17:   fi
    18: fi
    19: gh --version
    20: 
    21: # 1) gh 登入（會在 Windows 開瀏覽器授權）
    22: echo "[info] gh auth login ..."
    23: gh auth status || gh auth login --hostname github.com --web
    24: 
    25: # 2) 確保目前專案具備 GitHub 遠端
    26: if ! git remote get-url origin >/dev/null 2>&1; then
    27:   echo "[info] no origin remote, creating repo on GitHub and pushing..."
    28:   # 直接用資料夾名當 repo 名稱（smart-mail-agent）
    29:   gh repo create --public --source . --remote origin --push --confirm
    30: fi
    31: 
    32: # 3) 推 .env 到 GitHub Secrets（使用現有工具）
    33: chmod +x tools/push_secrets_from_env.sh || true
    34: ./tools/push_secrets_from_env.sh
    35: 
    36: # 4) 觸發 CI（SMTP 線上測試）
    37: echo "[info] trigger workflow: SMTP Online Test"
    38: gh workflow run "SMTP Online Test" || gh workflow run ".github/workflows/smtp-online.yml"
    39: 
    40: # 5) 追蹤狀態（顯示最近一次工作與即時 watch）
    41: echo "== recent runs =="
    42: gh run list --limit 5
    43: echo "== watching =="
    44: gh run watch
--------------------------------------------------------------------------------
END FILE    .portfolio_hidden/.dev/bootstrap_gh_ci.sh
================================================================================
================================================================================
BEGIN FILE  .portfolio_hidden/.dev/check_env.py  (1406 bytes)
TAGS: legacy_candidate=no | sys_path_hack=no | duplicate_basename=no
--------------------------------------------------------------------------------
     1: #!/usr/bin/env python3
     2: from __future__ import annotations
     3: 
     4: import os
     5: from pathlib import Path
     6: 
     7: ROOT = Path(__file__).resolve().parents[1]
     8: REQ_DIRS = [ROOT / "logs", ROOT / "data" / "output"]
     9: REQ_TPLS = [
    10:     ROOT / "templates" / "sales_inquiry_reply.j2",
    11:     ROOT / "templates" / "complaint_low.j2",
    12:     ROOT / "templates" / "complaint_med.j2",
    13:     ROOT / "templates" / "complaint_high.j2",
    14:     ROOT / "templates" / "needs_summary.md.j2",
    15: ]
    16: POLICY = ROOT / "configs" / "policy.yaml"
    17: DEFAULT_FONT = ROOT / "assets" / "fonts" / "NotoSansTC-Regular.ttf"
    18: 
    19: 
    20: def main() -> int:
    21:     print("=== Environment Self-Check ===")
    22:     print("\n[Directories]")
    23:     for d in REQ_DIRS:
    24:         d.mkdir(parents=True, exist_ok=True)
    25:         print(f"- {d}: ok")
    26:     print("\n[Templates]")
    27:     for t in REQ_TPLS:
    28:         print(f"- {t}: {'exists' if t.exists() else 'missing'}")
    29:     print("\n[Policy]")
    30:     print(f"- {POLICY}: {'exists' if POLICY.exists() else 'missing'}")
    31:     print("\n[Fonts]")
    32:     font_path = os.getenv("SMA_PDF_FONT_PATH") or os.getenv("FONT_PATH") or str(DEFAULT_FONT)
    33:     fp = Path(font_path if Path(font_path).is_absolute() else ROOT / font_path)
    34:     print(f"- {fp}: {'exists' if fp.exists() else 'missing'}")
    35:     if not fp.exists():
    36:         print("建議：提供中文字型；否則 PDF 流程會降級為 .txt（非致命）。")
    37:     return 0
    38: 
    39: 
    40: if __name__ == "__main__":
    41:     raise SystemExit(main())
--------------------------------------------------------------------------------
END FILE    .portfolio_hidden/.dev/check_env.py
================================================================================
================================================================================
BEGIN FILE  .portfolio_hidden/.dev/cleanup_repo.py  (385 bytes)
TAGS: legacy_candidate=no | sys_path_hack=no | duplicate_basename=no
--------------------------------------------------------------------------------
     1: #!/usr/bin/env python3
     2: from pathlib import Path
     3: 
     4: JUNK = ["=0.9.0", "=13.0.0", "DELETE", "FROM", "SELECT"]
     5: 
     6: 
     7: def main():
     8:     root = Path(".").resolve()
     9:     removed = []
    10:     for name in JUNK:
    11:         p = root / name
    12:         if p.exists():
    13:             p.unlink()
    14:             removed.append(name)
    15:     print("[CLEAN] removed:", removed or "nothing")
    16: 
    17: 
    18: if __name__ == "__main__":
    19:     main()
--------------------------------------------------------------------------------
END FILE    .portfolio_hidden/.dev/cleanup_repo.py
================================================================================
================================================================================
BEGIN FILE  .portfolio_hidden/.dev/db_migrate_emails_log.py  (2686 bytes)
TAGS: legacy_candidate=no | sys_path_hack=no | duplicate_basename=no
--------------------------------------------------------------------------------
     1: #!/usr/bin/env python3
     2: # 檔案位置：tools/db_migrate_emails_log.py
     3: # 模組用途：將舊表 email_logs 併入 emails_log，補欄位並避免 UNIQUE 衝突
     4: 
     5: import sqlite3
     6: from pathlib import Path
     7: 
     8: DB_PATH = Path("data/emails_log.db")
     9: FINAL = "emails_log"
    10: LEGACY = "email_logs"
    11: 
    12: REQUIRED = [
    13:     ("id", "INTEGER PRIMARY KEY AUTOINCREMENT"),
    14:     ("subject", "TEXT"),
    15:     ("content", "TEXT"),
    16:     ("summary", "TEXT"),
    17:     ("predicted_label", "TEXT"),
    18:     ("confidence", "REAL"),
    19:     ("action", "TEXT"),
    20:     ("error", "TEXT"),
    21:     ("created_at", "TEXT"),
    22: ]
    23: 
    24: 
    25: def list_tables(conn):
    26:     return {r[0] for r in conn.execute("SELECT name FROM sqlite_master WHERE type='table'")}
    27: 
    28: 
    29: def cols_of(conn, table):
    30:     return [r[1] for r in conn.execute(f"PRAGMA table_info({table})")]
    31: 
    32: 
    33: def ensure_final(conn):
    34:     cols = ", ".join([f"{n} {t}" for n, t in REQUIRED])
    35:     conn.execute(f"CREATE TABLE IF NOT EXISTS {FINAL} ({cols})")
    36:     conn.commit()
    37: 
    38: 
    39: def align_columns(conn, table):
    40:     existing = set(cols_of(conn, table))
    41:     for name, typ in REQUIRED:
    42:         if name not in existing:
    43:             print(f"[migrate] {table} 新增欄位：{name} {typ}")
    44:             conn.execute(f"ALTER TABLE {table} ADD COLUMN {name} {typ}")
    45:             conn.commit()
    46: 
    47: 
    48: def migrate():
    49:     DB_PATH.parent.mkdir(parents=True, exist_ok=True)
    50:     conn = sqlite3.connect(str(DB_PATH))
    51:     try:
    52:         ensure_final(conn)
    53:         tables = list_tables(conn)
    54: 
    55:         if LEGACY in tables and FINAL not in tables:
    56:             print("[migrate] 將 email_logs 更名為 emails_log")
    57:             conn.execute(f"ALTER TABLE {LEGACY} RENAME TO {FINAL}")
    58:             conn.commit()
    59:             align_columns(conn, FINAL)
    60:         elif LEGACY in tables and FINAL in tables:
    61:             # 將舊表資料搬到新表（排除 id，避免 UNIQUE 衝突）
    62:             align_columns(conn, LEGACY)
    63:             align_columns(conn, FINAL)
    64:             legacy_cols = cols_of(conn, LEGACY)
    65:             final_cols = cols_of(conn, FINAL)
    66:             common = [c for c in legacy_cols if c in final_cols and c != "id"]
    67:             if common:
    68:                 cols_csv = ", ".join(common)
    69:                 print(f"[migrate] 合併資料：{LEGACY} → {FINAL}（欄位：{cols_csv}；不搬 id）")
    70:                 conn.execute(f"INSERT INTO {FINAL} ({cols_csv}) SELECT {cols_csv} FROM {LEGACY}")
    71:                 conn.commit()
    72:             # 移除舊表避免之後重複合併
    73:             conn.execute(f"DROP TABLE {LEGACY}")
    74:             conn.commit()
    75: 
    76:         align_columns(conn, FINAL)
    77:         print("[migrate] 完成。現有欄位：", cols_of(conn, FINAL))
    78:     finally:
    79:         conn.close()
    80: 
    81: 
    82: if __name__ == "__main__":
    83:     migrate()
--------------------------------------------------------------------------------
END FILE    .portfolio_hidden/.dev/db_migrate_emails_log.py
================================================================================
================================================================================
BEGIN FILE  .portfolio_hidden/.dev/dedup_cleanup.sh  (3737 bytes)
TAGS: legacy_candidate=no | sys_path_hack=no | duplicate_basename=no
--------------------------------------------------------------------------------
     1: #!/usr/bin/env bash
     2: # 去重 + 瘦身 + 基本工具化（僅搬檔/刪產物，不改你的業務邏輯）
     3: set +e
     4: set -u
     5: 
     6: cd "$(dirname "$0")/.." || exit 1
     7: 
     8: STAMP="$(date +%Y%m%d-%H%M%S)"
     9: BK="backup_dedup_${STAMP}"
    10: mkdir -p "${BK}"
    11: 
    12: echo "=== [1/6] 備份可能要移除/替換的檔案 ==="
    13: for p in \
    14:   share_bundle \
    15:   run_pipeline.sh \
    16:   init_db.py \
    17:   README.md
    18: do
    19:   if [ -e "$p" ]; then
    20:     mkdir -p "${BK}/$(dirname "$p")"
    21:     mv "$p" "${BK}/$p"
    22:     echo "moved: $p -> ${BK}/$p"
    23:   fi
    24: done
    25: 
    26: echo "=== [2/6] 去重與清理（不動邏輯程式） ==="
    27: # 2-1) 移除重複目錄
    28: rm -rf share_bundle 2>/dev/null || true
    29: 
    30: # 2-2) 清理大檔/產物（單條加 || true，避免因不存在而中斷）
    31: rm -f assets/fonts/*.ttf 2>/dev/null || true
    32: rm -rf .pytest_cache 2>/dev/null || true
    33: rm -rf htmlcov .coverage* coverage.xml 2>/dev/null || true
    34: rm -rf logs/* 2>/dev/null || true
    35: rm -rf data/output/* 2>/dev/null || true
    36: rm -f smart-mail-agent-*.tar.gz smart-mail-agent-*.tgz 2>/dev/null || true
    37: # 用 find 刪 __pycache__，不會回非 0
    38: find . -type d -name "__pycache__" -prune -exec rm -rf {} + 2>/dev/null
    39: 
    40: echo "=== [3/6] 強化 .gitignore（避免之後又長肥檔） ==="
    41: add_ignore() { grep -qxF "$1" .gitignore 2>/dev/null || echo "$1" >> .gitignore; }
    42: add_ignore "# --- dedup cleanup ($(date)) ---"
    43: add_ignore "share_bundle/"
    44: add_ignore "assets/fonts/*.ttf"
    45: add_ignore "logs/"
    46: add_ignore "src/logs/"
    47: add_ignore "*.log"
    48: add_ignore "htmlcov/"
    49: add_ignore ".coverage*"
    50: add_ignore ".pytest_cache/"
    51: add_ignore "data/output/"
    52: 
    53: echo "=== [4/6] 產生 Makefile 常用指令（可覆蓋） ==="
    54: cat > Makefile <<'MAKE'
    55: .PHONY: help install format lint test-offline clean-light clean-heavy tools-check-log tools-list-folders tools-online-check
    56: 
    57: help:
    58: 	@echo "make install        - 建 venv + 安裝開發套件"
    59: 	@echo "make format         - isort + black"
    60: 	@echo "make lint           - flake8（不擋）"
    61: 	@echo "make test-offline   - OFFLINE=1，僅 not online 測試"
    62: 	@echo "make clean-light    - 清快取/覆蓋/輸出（安全）"
    63: 	@echo "make clean-heavy    - 連 pip/hf 快取一起清（更省空間）"
    64: 	@echo "make tools-check-log     - 檢視最近 20 筆 emails_log"
    65: 	@echo "make tools-list-folders  - 列 IMAP 資料夾（OFFLINE=1 會 SKIP）"
    66: 	@echo "make tools-online-check  - 線上 smoke（需 SMTP/IMAP 環境）"
    67: 
    68: install:
    69: 	python -m venv .venv || true
    70: 	. .venv/bin/activate; \
    71: 	pip install -U pip; \
    72: 	pip install -r requirements.txt || true; \
    73: 	pip install -U pytest black isort flake8 python-dotenv
    74: 
    75: format:
    76: 	. .venv/bin/activate; python -m isort .; python -m black .
    77: 
    78: lint:
    79: 	. .venv/bin/activate; python -m flake8 || true
    80: 
    81: test-offline:
    82: 	. .venv/bin/activate; OFFLINE=1 PYTHONPATH=src pytest -q -k "not online"
    83: 
    84: clean-light:
    85: 	rm -rf .pytest_cache || true
    86: 	find . -type d -name "__pycache__" -prune -exec rm -rf {} + 2>/dev/null || true
    87: 	rm -rf htmlcov .coverage* coverage.xml logs/* data/output/* || true
    88: 
    89: clean-heavy: clean-light
    90: 	python -m pip cache purge || true
    91: 	rm -rf ~/.cache/pip ~/.cache/huggingface ~/.cache/torch || true
    92: 
    93: tools-check-log:
    94: 	. .venv/bin/activate; PYTHONPATH=src python scripts/check_email_log.py --limit 20
    95: 
    96: tools-list-folders:
    97: 	. .venv/bin/activate; PYTHONPATH=src python scripts/list_gmail_folders.py
    98: 
    99: tools-online-check:
   100: 	. .venv/bin/activate; PYTHONPATH=src python scripts/online_check.py
   101: MAKE
   102: 
   103: echo "=== [5/6]（可選）離線自測：若系統有 pytest 就跑；不會中斷 ==="
   104: if command -v python >/dev/null 2>&1; then
   105:   [ -d .venv ] && . .venv/bin/activate
   106:   export OFFLINE=1
   107:   python -c "import pytest" >/dev/null 2>&1 && PYTHONPATH=src pytest -q -k "not online" || echo "(略過 pytest)"
   108: fi
   109: 
   110: echo "=== [6/6] 完成；所有被動到的檔已備份在：${BK} ==="
--------------------------------------------------------------------------------
END FILE    .portfolio_hidden/.dev/dedup_cleanup.sh
================================================================================
================================================================================
BEGIN FILE  .portfolio_hidden/.dev/dedupe_requirements.py  (866 bytes)
TAGS: legacy_candidate=no | sys_path_hack=no | duplicate_basename=no
--------------------------------------------------------------------------------
     1: #!/usr/bin/env python3
     2: # 檔案位置：tools/dedupe_requirements.py
     3: # 模組用途：requirements.txt 去重與排序，輸出 requirements.cleaned.txt
     4: 
     5: import re
     6: from pathlib import Path
     7: 
     8: IN = Path("requirements.txt")
     9: OUT = Path("requirements.cleaned.txt")
    10: 
    11: 
    12: def main():
    13:     if not IN.exists():
    14:         print("找不到 requirements.txt")
    15:         return
    16:     lines = [line.strip() for line in IN.read_text(encoding="utf-8").splitlines()]
    17:     pkgs = {}
    18:     for line in lines:
    19:         if not line or line.startswith("#"):
    20:             continue
    21:         name = re.split(r"[<>=!~ ]", line, maxsplit=1)[0].lower()
    22:         # 保留最後一次宣告
    23:         pkgs[name] = line
    24:     cleaned = sorted(pkgs.values(), key=lambda s: s.lower())
    25:     OUT.write_text("\n".join(cleaned) + "\n", encoding="utf-8")
    26:     print(f"已輸出：{OUT}")
    27: 
    28: 
    29: if __name__ == "__main__":
    30:     main()
--------------------------------------------------------------------------------
END FILE    .portfolio_hidden/.dev/dedupe_requirements.py
================================================================================
================================================================================
BEGIN FILE  .portfolio_hidden/.dev/dev_runner.py  (996 bytes)
TAGS: legacy_candidate=no | sys_path_hack=no | duplicate_basename=no
--------------------------------------------------------------------------------
     1: #!/usr/bin/env python3
     2: # 檔案位置：tools/dev_runner.py
     3: # 模組用途：一鍵執行 flake8 + pytest；失敗時顯示第一個錯誤並產生 PROJECT_STATUS.md
     4: 
     5: import subprocess
     6: import sys
     7: from pathlib import Path
     8: 
     9: ROOT = Path(__file__).resolve().parents[1]
    10: 
    11: 
    12: def run(cmd):
    13:     print(f"$ {' '.join(cmd)}")
    14:     return subprocess.run(cmd, cwd=ROOT).returncode
    15: 
    16: 
    17: def main():
    18:     v = ROOT / ".venv" / "bin"
    19:     flake8 = str(v / "flake8") if (v / "flake8").exists() else "flake8"
    20:     pytest = str(v / "pytest") if (v / "pytest").exists() else "pytest"
    21:     py = str(v / "python") if (v / "python").exists() else sys.executable
    22: 
    23:     rc = run([flake8, "."])
    24:     if rc != 0:
    25:         sys.exit(rc)
    26: 
    27:     rc = run([pytest, "-q"])
    28:     if rc != 0:
    29:         print("\n[test] 顯示第一個失敗的詳細訊息…\n")
    30:         run([pytest, "-x", "-vv"])
    31:         sys.exit(1)
    32: 
    33:     print("\n[info] 產生 PROJECT_STATUS.md…")
    34:     run([py, "tools/project_catalog.py"])
    35: 
    36: 
    37: if __name__ == "__main__":
    38:     main()
--------------------------------------------------------------------------------
END FILE    .portfolio_hidden/.dev/dev_runner.py
================================================================================
================================================================================
BEGIN FILE  .portfolio_hidden/.dev/finalize_and_push.sh  (916 bytes)
TAGS: legacy_candidate=no | sys_path_hack=no | duplicate_basename=no
--------------------------------------------------------------------------------
     1: #!/usr/bin/env bash
     2: set -euo pipefail
     3: 
     4: # 0) 進入 repo 根目錄
     5: cd "$(dirname "$0")/.." || exit 1
     6: 
     7: echo "==> 1) 檢查/建立 venv & 升級 pip"
     8: test -d .venv || python -m venv .venv
     9: . .venv/bin/activate
    10: python -m pip -q install -U pip
    11: 
    12: echo "==> 2) 安裝必要套件（含 dev）"
    13: pip -q install -r requirements.txt || true
    14: pip -q install -U pytest black isort flake8 python-dotenv
    15: 
    16: echo "==> 3) 統一格式 & Lint（不通過就中止）"
    17: python -m isort .
    18: python -m black .
    19: python -m flake8
    20: 
    21: echo "==> 4) 跑離線測試（與 CI 同步集合）"
    22: export OFFLINE=1
    23: PYTHONPATH=src pytest -q -k "not online"
    24: 
    25: echo "==> 5) 自動 commit & push（若有變更）"
    26: if ! git diff --quiet || ! git diff --cached --quiet; then
    27:   git add -A
    28:   git commit -m "chore: format+lint; offline tests green (finalize_and_push)"
    29:   git push
    30: else
    31:   echo "沒有需要提交的變更，跳過 commit/push"
    32: fi
    33: 
    34: echo "==> 完成 ✅"
--------------------------------------------------------------------------------
END FILE    .portfolio_hidden/.dev/finalize_and_push.sh
================================================================================
================================================================================
BEGIN FILE  .portfolio_hidden/.dev/fix_from_pretrained_order.py  (3179 bytes)
TAGS: legacy_candidate=no | sys_path_hack=no | duplicate_basename=no
--------------------------------------------------------------------------------
     1: #!/usr/bin/env python3
     2: from __future__ import annotations
     3: 
     4: from pathlib import Path
     5: 
     6: 
     7: def split_top_level_commas(s: str) -> list[str]:
     8:     out, buf = [], []
     9:     depth = 0
    10:     in_str = False
    11:     str_q = ""
    12:     esc = False
    13:     for ch in s:
    14:         if in_str:
    15:             buf.append(ch)
    16:             if esc:
    17:                 esc = False
    18:             elif ch == "\\":
    19:                 esc = True
    20:             elif ch == str_q:
    21:                 in_str = False
    22:             continue
    23:         if ch in ('"', "'"):
    24:             in_str = True
    25:             str_q = ch
    26:             buf.append(ch)
    27:             continue
    28:         if ch in "([{":
    29:             depth += 1
    30:             buf.append(ch)
    31:             continue
    32:         if ch in ")]}":
    33:             depth -= 1
    34:             buf.append(ch)
    35:             continue
    36:         if ch == "," and depth == 0:
    37:             part = "".join(buf).strip()
    38:             if part:
    39:                 out.append(part)
    40:             buf = []
    41:             continue
    42:         buf.append(ch)
    43:     tail = "".join(buf).strip()
    44:     if tail:
    45:         out.append(tail)
    46:     return out
    47: 
    48: 
    49: def rewrite_calls(src: str) -> tuple[str, int]:
    50:     i = 0
    51:     changed = 0
    52:     need = "from_pretrained("
    53:     out = []
    54:     while True:
    55:         j = src.find(need, i)
    56:         if j == -1:
    57:             out.append(src[i:])
    58:             break
    59:         # write text before call
    60:         out.append(src[i:j])
    61:         # find '(' start and matching ')'
    62:         lp = src.find("(", j)
    63:         k = lp + 1
    64:         depth = 1
    65:         in_str = False
    66:         str_q = ""
    67:         esc = False
    68:         while k < len(src):
    69:             ch = src[k]
    70:             if in_str:
    71:                 if esc:
    72:                     esc = False
    73:                 elif ch == "\\":
    74:                     esc = True
    75:                 elif ch == str_q:
    76:                     in_str = False
    77:             else:
    78:                 if ch in ('"', "'"):
    79:                     in_str = True
    80:                     str_q = ch
    81:                 elif ch == "(":
    82:                     depth += 1
    83:                 elif ch == ")":
    84:                     depth -= 1
    85:                     if depth == 0:
    86:                         break
    87:             k += 1
    88:         if k >= len(src):
    89:             # unmatched, give up
    90:             out.append(src[j:])
    91:             break
    92: 
    93:         args_str = src[lp + 1 : k]
    94:         args = split_top_level_commas(args_str)
    95:         # 分出位置/關鍵字，保持原始順序
    96:         pos_args = [a for a in args if "=" not in a.split("=", 1)[0]]
    97:         kw_args = [a for a in args if "=" in a.split("=", 1)[0]]
    98: 
    99:         # 如果先前寫成了「關鍵字在前、位置在後」，這裡會重排為合法順序
   100:         new_args = ", ".join(pos_args + kw_args)
   101: 
   102:         out.append("from_pretrained(" + new_args + ")")
   103:         changed += 1
   104:         i = k + 1
   105:     return "".join(out), changed
   106: 
   107: 
   108: p = Path("src/classifier.py")
   109: src = p.read_text(encoding="utf-8")
   110: new_src, n = rewrite_calls(src)
   111: if n > 0 and new_src != src:
   112:     backup = p.with_suffix(p.suffix + ".bak")
   113:     backup.write_text(src, encoding="utf-8")
   114:     p.write_text(new_src, encoding="utf-8")
   115:     print(f"fixed {n} call(s); backup saved to {backup}")
   116: else:
   117:     print("no change (calls already ordered or not found)")
--------------------------------------------------------------------------------
END FILE    .portfolio_hidden/.dev/fix_from_pretrained_order.py
================================================================================
================================================================================
BEGIN FILE  .portfolio_hidden/.dev/fix_from_pretrained_order_v2.py  (3227 bytes)
TAGS: legacy_candidate=no | sys_path_hack=no | duplicate_basename=no
--------------------------------------------------------------------------------
     1: #!/usr/bin/env python3
     2: from __future__ import annotations
     3: 
     4: from pathlib import Path
     5: 
     6: 
     7: def split_top_level_commas(s: str) -> list[str]:
     8:     out, buf = [], []
     9:     depth = 0
    10:     in_str = False
    11:     esc = False
    12:     quote = ""
    13:     for ch in s:
    14:         if in_str:
    15:             buf.append(ch)
    16:             if esc:
    17:                 esc = False
    18:             elif ch == "\\":
    19:                 esc = True
    20:             elif ch == quote:
    21:                 in_str = False
    22:             continue
    23:         if ch in "\"'":
    24:             in_str = True
    25:             quote = ch
    26:             buf.append(ch)
    27:             continue
    28:         if ch in "([{":
    29:             depth += 1
    30:             buf.append(ch)
    31:             continue
    32:         if ch in ")]}":
    33:             depth -= 1
    34:             buf.append(ch)
    35:             continue
    36:         if ch == "," and depth == 0:
    37:             part = "".join(buf).strip()
    38:             if part:
    39:                 out.append(part)
    40:             buf = []
    41:             continue
    42:         buf.append(ch)
    43:     tail = "".join(buf).strip()
    44:     if tail:
    45:         out.append(tail)
    46:     return out
    47: 
    48: 
    49: def fix_source(src: str) -> tuple[str, int]:
    50:     i = 0
    51:     changed = 0
    52:     out = []
    53:     while True:
    54:         j = src.find(".from_pretrained(", i)
    55:         if j == -1:
    56:             out.append(src[i:])
    57:             break
    58:         # 找前綴（物件/類別名）
    59:         k = j - 1
    60:         while k >= 0 and (src[k].isalnum() or src[k] in "._"):
    61:             k -= 1
    62:         prefix = src[k + 1 : j]  # 例如 AutoTokenizer 或 AutoModelForSequenceClassification 或某變數.pipeline
    63:         # 括號配對
    64:         lp = j + len(".from_pretrained(")
    65:         pos = lp
    66:         depth = 1
    67:         in_str = False
    68:         esc = False
    69:         quote = ""
    70:         while pos < len(src):
    71:             ch = src[pos]
    72:             if in_str:
    73:                 if esc:
    74:                     esc = False
    75:                 elif ch == "\\":
    76:                     esc = True
    77:                 elif ch == quote:
    78:                     in_str = False
    79:             else:
    80:                 if ch in "\"'":
    81:                     in_str = True
    82:                     quote = ch
    83:                 elif ch == "(":
    84:                     depth += 1
    85:                 elif ch == ")":
    86:                     depth -= 1
    87:                     if depth == 0:
    88:                         break
    89:             pos += 1
    90:         if pos >= len(src):
    91:             # 括號不配對，跳過
    92:             out.append(src[i:])
    93:             break
    94:         args_str = src[lp:pos]
    95:         args = split_top_level_commas(args_str)
    96:         # 重排：位置參數在前，關鍵字在後（保序）
    97:         pos_args = [a for a in args if "=" not in a.split("=", 1)[0]]
    98:         kw_args = [a for a in args if "=" in a.split("=", 1)[0]]
    99:         new_args = ", ".join(pos_args + kw_args)
   100:         out.append(src[i : k + 1] + prefix + ".from_pretrained(" + new_args + ")")
   101:         i = pos + 1
   102:         changed += 1
   103:     return "".join(out), changed
   104: 
   105: 
   106: p = Path("src/classifier.py")
   107: src = p.read_text(encoding="utf-8")
   108: new_src, n = fix_source(src)
   109: if n and new_src != src:
   110:     bak = p.with_suffix(p.suffix + ".bak")
   111:     bak.write_text(src, encoding="utf-8")
   112:     p.write_text(new_src, encoding="utf-8")
   113:     print(f"fixed {n} call(s); backup: {bak}")
   114: else:
   115:     print("no change")
--------------------------------------------------------------------------------
END FILE    .portfolio_hidden/.dev/fix_from_pretrained_order_v2.py
================================================================================
================================================================================
BEGIN FILE  .portfolio_hidden/.dev/fix_from_pretrained_order_v3.py  (4270 bytes)
TAGS: legacy_candidate=no | sys_path_hack=no | duplicate_basename=no
--------------------------------------------------------------------------------
     1: #!/usr/bin/env python3
     2: from __future__ import annotations
     3: 
     4: from pathlib import Path
     5: 
     6: 
     7: def split_top_level_commas(s: str) -> list[str]:
     8:     out, buf = [], []
     9:     depth, in_str, esc = 0, False, False
    10:     quote = ""
    11:     for ch in s:
    12:         if in_str:
    13:             buf.append(ch)
    14:             if esc:
    15:                 esc = False
    16:             elif ch == "\\":
    17:                 esc = True
    18:             elif ch == quote:
    19:                 in_str = False
    20:             continue
    21:         if ch in "\"'":
    22:             in_str, quote = True, ch
    23:             buf.append(ch)
    24:             continue
    25:         if ch in "([{":
    26:             depth += 1
    27:             buf.append(ch)
    28:             continue
    29:         if ch in ")]}":
    30:             depth -= 1
    31:             buf.append(ch)
    32:             continue
    33:         if ch == "," and depth == 0:
    34:             part = "".join(buf).strip()
    35:             if part:
    36:                 out.append(part)
    37:             buf = []
    38:             continue
    39:         buf.append(ch)
    40:     tail = "".join(buf).strip()
    41:     if tail:
    42:         out.append(tail)
    43:     return out
    44: 
    45: 
    46: def rewrite_calls(src: str) -> tuple[str, int]:
    47:     i, changed = 0, 0
    48:     out = []
    49:     while True:
    50:         j = src.find(".from_pretrained(", i)
    51:         if j == -1:
    52:             out.append(src[i:])
    53:             break
    54:         # 找前綴（AutoTokenizer / AutoModelForSequenceClassification / 變數等）
    55:         k = j - 1
    56:         while k >= 0 and (src[k].isalnum() or src[k] in "._"):
    57:             k -= 1
    58:         prefix = src[k + 1 : j]  # 不動它
    59:         # 尋找對應右括號
    60:         lp = j + len(".from_pretrained(")
    61:         pos = lp
    62:         depth = 1
    63:         in_str = False
    64:         esc = False
    65:         quote = ""
    66:         while pos < len(src):
    67:             ch = src[pos]
    68:             if in_str:
    69:                 if esc:
    70:                     esc = False
    71:                 elif ch == "\\":
    72:                     esc = True
    73:                 elif ch == quote:
    74:                     in_str = False
    75:             else:
    76:                 if ch in "\"'":
    77:                     in_str, quote = True, ch
    78:                 elif ch == "(":
    79:                     depth += 1
    80:                 elif ch == ")":
    81:                     depth -= 1
    82:                     if depth == 0:
    83:                         break
    84:             pos += 1
    85:         if pos >= len(src):  # 括號不配對：放棄改寫
    86:             out.append(src[i:])
    87:             break
    88: 
    89:         args_str = src[lp:pos]
    90:         tokens = split_top_level_commas(args_str)
    91: 
    92:         # 分出位置/關鍵字（保留原順序），並去除明顯重複的 KW
    93:         pos_args_raw = []
    94:         kw_args_order, seen_kw = [], set()
    95:         for t in tokens:
    96:             if "=" in t.split("=", 1)[0]:
    97:                 key = t.split("=", 1)[0].strip()
    98:                 if key in seen_kw:
    99:                     continue
   100:                 seen_kw.add(key)
   101:                 kw_args_order.append(t.strip())
   102:             else:
   103:                 pos_args_raw.append(t.strip())
   104: 
   105:         # 選擇最合理的第一個位置參數：優先 model_path / MODEL_NAME / MODEL_PATH
   106:         preferred = None
   107:         for cand in ("model_path", "MODEL_NAME", "MODEL_PATH"):
   108:             if cand in pos_args_raw:
   109:                 preferred = cand
   110:                 break
   111:         if preferred is None:
   112:             # 若只有 'main' 這種字面字串，且同時存在 revision=，就丟掉 'main'
   113:             cleaned = [p for p in pos_args_raw if p.strip("'\"") != "main"]
   114:             pos_args = cleaned or pos_args_raw or ["model_path"]  # 最後保守用 model_path
   115:         else:
   116:             pos_args = [preferred]
   117: 
   118:         # 確保 revision/trust_remote_code/local_files_only 若存在則保留，缺少可不補
   119:         # （我們不強行新增，以避免引用未宣告變數）
   120:         new_args = ", ".join(pos_args + kw_args_order)
   121: 
   122:         out.append(src[i : k + 1] + prefix + ".from_pretrained(" + new_args + ")")
   123:         i = pos + 1
   124:         changed += 1
   125: 
   126:     return "".join(out), changed
   127: 
   128: 
   129: p = Path("src/classifier.py")
   130: src = p.read_text(encoding="utf-8")
   131: new_src, n = rewrite_calls(src)
   132: if n and new_src != src:
   133:     bak = p.with_suffix(p.suffix + ".bak")
   134:     bak.write_text(src, encoding="utf-8")
   135:     p.write_text(new_src, encoding="utf-8")
   136:     print(f"fixed {n} call(s); backup at {bak}")
   137: else:
   138:     print("no change or nothing to fix")
--------------------------------------------------------------------------------
END FILE    .portfolio_hidden/.dev/fix_from_pretrained_order_v3.py
================================================================================
================================================================================
BEGIN FILE  .portfolio_hidden/.dev/generate_offline_report.py  (1884 bytes)
TAGS: legacy_candidate=no | sys_path_hack=no | duplicate_basename=no
--------------------------------------------------------------------------------
     1: #!/usr/bin/env python3
     2: from __future__ import annotations
     3: 
     4: import datetime as dt
     5: import json
     6: from pathlib import Path
     7: 
     8: 
     9: def main():
    10:     root = Path(__file__).resolve().parents[1]
    11:     mout = root / "data" / "output" / "matrix"
    12:     reports = root / "reports"
    13:     reports.mkdir(parents=True, exist_ok=True)
    14:     msum = mout / "matrix_summary.json"
    15:     data = json.loads(msum.read_text(encoding="utf-8"))
    16:     cases = data.get("cases", [])
    17:     by = {}
    18:     ok = 0
    19:     for c in cases:
    20:         by[c.get("action", "UNKNOWN")] = by.get(c.get("action", "UNKNOWN"), 0) + 1
    21:         ok += 1 if c.get("ok", True) else 0
    22:     rows = []
    23:     for c in cases:
    24:         atts = "<br/>".join(f"<code>{a}</code>" for a in (c.get("attachments") or []))
    25:         rows.append(f"<tr><td>{c.get('name')}</td><td>{c.get('action')}</td><td>{'✅' if c.get('ok', True) else '❌'}</td><td><code>{c.get('output')}</code></td><td>{atts}</td></tr>")
    26:     html = f"""<!doctype html><meta charset="utf-8">
    27: <title>Smart Mail Agent — 離線報告</title>
    28: <style>body{{font-family:system-ui,Roboto,"PingFang TC","Microsoft JhengHei",sans-serif;padding:24px}}
    29: table{{width:100%;border-collapse:collapse}}td,th{{border:1px solid #ddd;padding:8px}}th{{background:#f6f8fa;text-align:left}}
    30: code{{background:#f3f3f3;padding:2px 4px;border-radius:4px}}</style>
    31: <h1>Smart Mail Agent — 離線 Demo 報告</h1>
    32: <p>根目錄：<code>{root}</code>　產生時間：{dt.datetime.now():%Y-%m-%d %H:%M:%S}</p>
    33: <p>案例數：{len(cases)}　成功：{ok}/{len(cases)}　各動作：{" 、".join(f"{k}:{v}" for k, v in by.items())}</p>
    34: <table><thead><tr><th>name</th><th>action</th><th>ok</th><th>output</th><th>attachments</th></tr></thead>
    35: <tbody>{"".join(rows)}</tbody></table>"""
    36:     out = reports / "offline_demo_report.html"
    37:     out.write_text(html, encoding="utf-8")
    38:     print("[REPORT]", out)
    39: 
    40: 
    41: if __name__ == "__main__":
    42:     main()
--------------------------------------------------------------------------------
END FILE    .portfolio_hidden/.dev/generate_offline_report.py
================================================================================
================================================================================
BEGIN FILE  .portfolio_hidden/.dev/generate_spam_report.py  (1616 bytes)
TAGS: legacy_candidate=no | sys_path_hack=no | duplicate_basename=no
--------------------------------------------------------------------------------
     1: from __future__ import annotations
     2: 
     3: import json
     4: from pathlib import Path
     5: 
     6: ROOT = Path(__file__).resolve().parents[1]
     7: OUT = ROOT / "reports"
     8: OUT.mkdir(parents=True, exist_ok=True)
     9: DATA = ROOT / "data" / "output" / "spam_demo.json"
    10: 
    11: 
    12: def main():
    13:     if not DATA.exists():
    14:         print("[WARN] spam_demo.json 不存在，先跑: python tools/run_spam_demo.py")
    15:         return
    16:     obj = json.loads(DATA.read_text(encoding="utf-8"))
    17:     rows = obj.get("rows", [])
    18:     ok = sum(1 for r in rows if r["label"] == "legit")
    19:     sp = sum(1 for r in rows if r["label"] == "spam")
    20:     su = sum(1 for r in rows if r["label"] == "suspect")
    21:     html = ["<html><head><meta charset='utf-8'><title>Spam Report</title></head><body>"]
    22:     html.append(f"<h2>Spam Demo Report</h2><p>TS = {obj.get('ts')}</p>")
    23:     html.append(f"<p>legit={ok} , suspect={su} , spam={sp}</p>")
    24:     html.append("<table border='1' cellspacing='0' cellpadding='6'>")
    25:     html.append("<tr><th>name</th><th>label</th><th>score</th><th>hits</th><th>components</th></tr>")
    26:     for r in rows:
    27:         comp = r["rationale"]
    28:         hits = ", ".join(h["rule"] for h in comp.get("hits", [])) or "-"
    29:         components = f"rule={comp['rule_score']}, link={comp['link_score']}, header={comp['header_score']}, attach={comp['attach_score']}"
    30:         html.append(f"<tr><td>{r['name']}</td><td>{r['label']}</td><td>{r['score']}</td><td>{hits}</td><td>{components}</td></tr>")
    31:     html.append("</table></body></html>")
    32:     out = OUT / "spam_report.html"
    33:     out.write_text("\n".join(html), encoding="utf-8")
    34:     print("[REPORT]", out)
    35: 
    36: 
    37: if __name__ == "__main__":
    38:     main()
--------------------------------------------------------------------------------
END FILE    .portfolio_hidden/.dev/generate_spam_report.py
================================================================================
================================================================================
BEGIN FILE  .portfolio_hidden/.dev/gh_device_login.sh  (861 bytes)
TAGS: legacy_candidate=no | sys_path_hack=no | duplicate_basename=no
--------------------------------------------------------------------------------
     1: #!/usr/bin/env bash
     2: set -euo pipefail
     3: 
     4: # 1) 啟動裝置登入流程（終端機會顯示一組代碼：XXXX-XXXX）
     5: echo "[info] 先看終端機的『First copy your one-time code:』那行，複製代碼"
     6: gh auth login --hostname github.com --git-protocol https --device || true
     7: 
     8: # 2) 幫你在 Windows 開登入頁（若可用）
     9: powershell.exe /c start https://github.com/login/device 2>/dev/null || true
    10: explorer.exe "https://github.com/login/device" 2>/dev/null || true
    11: 
    12: echo
    13: echo "[next] 把剛剛複製的代碼貼到瀏覽器頁面，完成授權後回到這邊按 Enter 繼續"
    14: read -r _
    15: 
    16: # 3) 驗證登入狀態
    17: echo "[info] 檢查 gh 登入狀態…"
    18: gh auth status
    19: 
    20: echo "[ok] 登入成功。如果要繼續把 .env 寫到 GitHub Secrets，跑：make gh-secrets"
    21: echo "[ok] 觸發線上寄信測試：make ci-smtp  ；觀看執行：make ci-watch"
--------------------------------------------------------------------------------
END FILE    .portfolio_hidden/.dev/gh_device_login.sh
================================================================================
================================================================================
BEGIN FILE  .portfolio_hidden/.dev/git_setup_and_tag.py  (3753 bytes)
TAGS: legacy_candidate=no | sys_path_hack=no | duplicate_basename=no
--------------------------------------------------------------------------------
     1: #!/usr/bin/env python3
     2: # 檔案：tools/git_setup_and_tag.py
     3: # 用途：在目前 repo 內一鍵設定 git 用戶資訊、初始化 main 分支、建立首個提交、可選設定遠端並推送
     4: #
     5: # 以環境變數提供資訊（無交互）：
     6: #   SMA_GIT_NAME   例如：export SMA_GIT_NAME="Your Name"
     7: #   SMA_GIT_EMAIL  例如：export SMA_GIT_EMAIL="you@example.com"
     8: #   SMA_GIT_REMOTE （可選）例如：export SMA_GIT_REMOTE="git@github.com:your/repo.git"
     9: #   SMA_TAG        （可選）例如：export SMA_TAG="v0.1.0"
    10: #
    11: # 用法：
    12: #   python tools/git_setup_and_tag.py
    13: 
    14: from __future__ import annotations
    15: 
    16: import os
    17: import subprocess
    18: from pathlib import Path
    19: 
    20: 
    21: def sh(cmd: list[str], check: bool = True) -> subprocess.CompletedProcess:
    22:     return subprocess.run(cmd, check=check)
    23: 
    24: 
    25: def main() -> None:
    26:     name = os.environ.get("SMA_GIT_NAME")
    27:     email = os.environ.get("SMA_GIT_EMAIL")
    28:     remote = os.environ.get("SMA_GIT_REMOTE")
    29:     tag = os.environ.get("SMA_TAG")
    30: 
    31:     if not name or not email:
    32:         print("[ERR] 請先設定環境變數 SMA_GIT_NAME / SMA_GIT_EMAIL 再執行。")
    33:         print('      例：export SMA_GIT_NAME="Your Name"; export SMA_GIT_EMAIL="you@example.com"')
    34:         raise SystemExit(2)
    35: 
    36:     # 1) 確保 git repo
    37:     if not (Path(".git").exists()):
    38:         sh(["git", "init"])
    39: 
    40:     # 2) 設定使用者
    41:     sh(["git", "config", "user.name", name])
    42:     sh(["git", "config", "user.email", email])
    43: 
    44:     # 3) 若沒有提交，建立 main 與首個提交
    45:     # 檢查是否已有 commit
    46:     has_commit = subprocess.run(["git", "rev-parse", "HEAD"], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL).returncode == 0
    47:     if not has_commit:
    48:         # 設定預設分支為 main（僅空 repo 有效）
    49:         try:
    50:             sh(["git", "symbolic-ref", "HEAD", "refs/heads/main"])
    51:         except subprocess.CalledProcessError:
    52:             pass
    53:         sh(["git", "add", "-A"])
    54:         # 首次提交避免空提交
    55:         sh(["git", "commit", "-m", "chore: initial commit [sma]"])
    56: 
    57:     # 4) 設定遠端（可選）
    58:     if remote:
    59:         # 如果已存在 origin 就 set-url；否則 add
    60:         has_origin = (
    61:             subprocess.run(
    62:                 ["git", "remote", "get-url", "origin"],
    63:                 stdout=subprocess.DEVNULL,
    64:                 stderr=subprocess.DEVNULL,
    65:             ).returncode
    66:             == 0
    67:         )
    68:         if has_origin:
    69:             sh(["git", "remote", "set-url", "origin", remote])
    70:         else:
    71:             sh(["git", "remote", "add", "origin", remote])
    72: 
    73:         # 推 main
    74:         # 先確認目前分支名
    75:         res = subprocess.run(["git", "rev-parse", "--abbrev-ref", "HEAD"], capture_output=True, text=True, check=True)
    76:         cur = res.stdout.strip() or "main"
    77:         try:
    78:             sh(["git", "push", "-u", "origin", cur])
    79:         except subprocess.CalledProcessError:
    80:             print("[WARN] push 失敗，請檢查遠端權限或分支保護策略。")
    81: 
    82:     # 5) 打 tag（可選）
    83:     if tag:
    84:         # 若 tag 已存在，略過
    85:         exists = (
    86:             subprocess.run(
    87:                 ["git", "rev-parse", "-q", "--verify", f"refs/tags/{tag}"],
    88:                 stdout=subprocess.DEVNULL,
    89:                 stderr=subprocess.DEVNULL,
    90:             ).returncode
    91:             == 0
    92:         )
    93:         if not exists:
    94:             sh(["git", "tag", tag])
    95:             if remote:
    96:                 try:
    97:                     sh(["git", "push", "origin", tag])
    98:                 except subprocess.CalledProcessError:
    99:                     print("[WARN] 推送 tag 失敗，請檢查遠端權限。")
   100:         else:
   101:             print(f"[INFO] tag {tag} 已存在，略過。")
   102: 
   103:     print("[ok] git 設定與初始化完成。")
   104: 
   105: 
   106: if __name__ == "__main__":
   107:     main()
--------------------------------------------------------------------------------
END FILE    .portfolio_hidden/.dev/git_setup_and_tag.py
================================================================================
================================================================================
BEGIN FILE  .portfolio_hidden/.dev/imap_pass_sanitize.py  (990 bytes)
TAGS: legacy_candidate=no | sys_path_hack=no | duplicate_basename=no
--------------------------------------------------------------------------------
     1: #!/usr/bin/env python3
     2: # 檔案：tools/imap_pass_sanitize.py
     3: # 目的：移除 .env 內 IMAP_PASS 的所有空白字元（避免貼入時混入空格、換行）
     4: 
     5: from __future__ import annotations
     6: 
     7: import re
     8: from pathlib import Path
     9: 
    10: ROOT = Path(__file__).resolve().parents[1]
    11: ENV = ROOT / ".env"
    12: 
    13: 
    14: def main() -> int:
    15:     if not ENV.exists():
    16:         print(f"[ERR] 找不到 {ENV}")
    17:         return 2
    18: 
    19:     txt = ENV.read_text(encoding="utf-8")
    20:     m = re.search(r"^IMAP_PASS=(.*)$", txt, flags=re.MULTILINE)
    21:     if not m:
    22:         print("[MISS] .env 內沒有 IMAP_PASS=… 這一行")
    23:         return 3
    24: 
    25:     raw = m.group(1)
    26:     cleaned = re.sub(r"\s+", "", raw)
    27:     if cleaned == raw:
    28:         print("[OK] IMAP_PASS 沒有空白，不需更動")
    29:         return 0
    30: 
    31:     txt2 = txt[: m.start(1)] + cleaned + txt[m.end(1) :]
    32:     ENV.write_text(txt2, encoding="utf-8")
    33:     print("[FIX] 已移除 IMAP_PASS 的空白字元")
    34:     return 0
    35: 
    36: 
    37: if __name__ == "__main__":
    38:     raise SystemExit(main())
--------------------------------------------------------------------------------
END FILE    .portfolio_hidden/.dev/imap_pass_sanitize.py
================================================================================
================================================================================
BEGIN FILE  .portfolio_hidden/.dev/make_share_bundle.sh  (1320 bytes)
TAGS: legacy_candidate=no | sys_path_hack=no | duplicate_basename=no
--------------------------------------------------------------------------------
     1: #!/usr/bin/env bash
     2: set -euo pipefail
     3: 
     4: ROOT="$(pwd)"
     5: TEMP_DIR="$ROOT/.share_tmp"
     6: OUT_DIR="$ROOT/share_bundle"
     7: ARCHIVE="$ROOT/smart-mail-agent-full-$(date +%F-%H%M).tar.gz"
     8: 
     9: echo "[1/5] 準備目錄"
    10: rm -rf "$TEMP_DIR" "$OUT_DIR" "$ARCHIVE"
    11: mkdir -p "$OUT_DIR"
    12: 
    13: echo "[2/5] 複製專案（排除 .git / .venv / __pycache__ / tmp / logs/*.log / *.pkl）"
    14: # 若有 rsync 用 rsync；沒有就用 tar 解決
    15: if command -v rsync >/dev/null 2>&1; then
    16:   rsync -a \
    17:     --exclude ".git" \
    18:     --exclude ".venv" \
    19:     --exclude "__pycache__" \
    20:     --exclude "tmp" \
    21:     --exclude "logs/*.log" \
    22:     --exclude "*.pkl" \
    23:     ./ "$OUT_DIR/"
    24: else
    25:   mkdir -p "$TEMP_DIR"
    26:   tar -cf "$TEMP_DIR/src.tar" \
    27:     --exclude=".git" \
    28:     --exclude=".venv" \
    29:     --exclude="__pycache__" \
    30:     --exclude="tmp" \
    31:     --exclude="logs/*.log" \
    32:     --exclude="*.pkl" \
    33:     .
    34:   tar -xf "$TEMP_DIR/src.tar" -C "$OUT_DIR"
    35: fi
    36: 
    37: echo "[3/5] 處理 .env（自動遮蔽祕密；若沒有就略過）"
    38: if [ -f "$ROOT/.env" ]; then
    39:   sed -E 's/(OPENAI_API_KEY|SMTP_PASS|IMAP_PASS|GH_TOKEN)=.*/\1=***REDACTED***/' "$ROOT/.env" > "$OUT_DIR/.env"
    40: fi
    41: 
    42: echo "[4/5] 打包壓縮"
    43: tar -czf "$ARCHIVE" -C "$OUT_DIR/.." "$(basename "$OUT_DIR")"
    44: 
    45: echo "[5/5] 完成"
    46: echo "==> 產生：$ARCHIVE"
    47: echo "提示：直接把這個 .tar.gz 檔拖到聊天室上傳即可"
--------------------------------------------------------------------------------
END FILE    .portfolio_hidden/.dev/make_share_bundle.sh
================================================================================
================================================================================
BEGIN FILE  .portfolio_hidden/.dev/metrics_daily.py  (2427 bytes)
TAGS: legacy_candidate=no | sys_path_hack=no | duplicate_basename=no
--------------------------------------------------------------------------------
     1: #!/usr/bin/env python3
     2: from __future__ import annotations
     3: 
     4: import argparse
     5: import json
     6: import sys
     7: from collections import defaultdict
     8: from pathlib import Path
     9: from typing import Any
    10: 
    11: 
    12: def _iter_logs(log_dir: Path) -> list[Path]:
    13:     return sorted(log_dir.glob("sma-*.jsonl"))
    14: 
    15: 
    16: def main() -> int:
    17:     ap = argparse.ArgumentParser(description="Aggregate JSONL logs to daily CSV metrics")
    18:     ap.add_argument("--log-dir", default="logs")
    19:     ap.add_argument("--out-dir", default="data/output/metrics")
    20:     args = ap.parse_args()
    21:     log_dir = Path(args.log_dir)
    22:     out_dir = Path(args.out_dir)
    23:     out_dir.mkdir(parents=True, exist_ok=True)
    24:     files = _iter_logs(log_dir)
    25:     if not files:
    26:         print("no logs found", file=sys.stderr)
    27:         return 0
    28: 
    29:     metrics: dict[str, dict[str, dict[str, Any]]] = defaultdict(lambda: defaultdict(lambda: {"count": 0, "ok": 0, "fail": 0, "dur_sum": 0, "dur_cnt": 0}))
    30: 
    31:     for fp in files:
    32:         with fp.open("r", encoding="utf-8") as f:
    33:             for line in f:
    34:                 line = line.strip()
    35:                 if not line:
    36:                     continue
    37:                 try:
    38:                     obj = json.loads(line)
    39:                 except Exception:
    40:                     continue
    41:                 ev = obj.get("event") or {}
    42:                 ts = ev.get("ts") or ""
    43:                 day = ts[:10] if len(ts) >= 10 else "1970-01-01"
    44:                 intent = ev.get("intent") or "unknown"
    45:                 m = metrics[day][intent]
    46:                 m["count"] += 1
    47:                 if ev.get("ok") is True:
    48:                     m["ok"] += 1
    49:                 elif ev.get("ok") is False:
    50:                     m["fail"] += 1
    51:                 dur = ev.get("duration_ms")
    52:                 if isinstance(dur, int) and dur >= 0:
    53:                     m["dur_sum"] += dur
    54:                     m["dur_cnt"] += 1
    55: 
    56:     # output CSV per day
    57:     for day, intents in metrics.items():
    58:         ymd = day.replace("-", "")
    59:         out = out_dir / f"metrics-{ymd}.csv"
    60:         rows = ["date,intent,count,ok,fail,avg_duration_ms"]
    61:         for intent, m in sorted(intents.items()):
    62:             avg = (m["dur_sum"] / m["dur_cnt"]) if m["dur_cnt"] else 0
    63:             rows.append(f"{day},{intent},{m['count']},{m['ok']},{m['fail']},{int(avg)}")
    64:         out.write_text("\n".join(rows) + "\n", encoding="utf-8")
    65:         print(f"已輸出：{out}")
    66:     return 0
    67: 
    68: 
    69: if __name__ == "__main__":
    70:     raise SystemExit(main())
--------------------------------------------------------------------------------
END FILE    .portfolio_hidden/.dev/metrics_daily.py
================================================================================
================================================================================
BEGIN FILE  .portfolio_hidden/.dev/offline_verify.py  (3472 bytes)
TAGS: legacy_candidate=no | sys_path_hack=yes | duplicate_basename=no
--------------------------------------------------------------------------------
     1: #!/usr/bin/env python3
     2: # 檔案位置：tools/offline_verify.py
     3: # 模組用途：一鍵離線驗證（pytest -k "not online"）與六類動作 Demo 產物檢查
     4: 
     5: from __future__ import annotations
     6: 
     7: import json
     8: import os
     9: import subprocess
    10: import sys
    11: from pathlib import Path
    12: from typing import Any
    13: 
    14: ROOT = Path(__file__).resolve().parents[1]
    15: SRC = ROOT / "src"
    16: OUT = ROOT / "data" / "output"
    17: OUT.mkdir(parents=True, exist_ok=True)
    18: 
    19: 
    20: def _ensure_sys_path() -> None:
    21:     if str(SRC) not in sys.path:
    22:         sys.path.insert(0, str(SRC))
    23: 
    24: 
    25: def run_offline_tests() -> int:
    26:     env = os.environ.copy()
    27:     env["OFFLINE"] = "1"
    28:     env["PYTHONPATH"] = str(SRC)
    29:     cmd = ["pytest", "-q", "-k", "not online"]
    30:     p = subprocess.run(cmd, cwd=str(ROOT), env=env, text=True)
    31:     return p.returncode
    32: 
    33: 
    34: def demo_actions() -> dict[str, Any]:
    35:     _ensure_sys_path()
    36:     os.environ.setdefault("OFFLINE", "1")
    37:     from action_handler import handle
    38: 
    39:     cases = [
    40:         (
    41:             "業務接洽或報價",
    42:             {
    43:                 "subject": "API 串接報價",
    44:                 "content": "請提供報價與交期",
    45:                 "sender": "buyer@example.com",
    46:             },
    47:         ),
    48:         (
    49:             "請求技術支援",
    50:             {"subject": "登入錯誤", "content": "顯示 500 需要排查", "sender": "user@example.com"},
    51:         ),
    52:         (
    53:             "申請修改資訊",
    54:             {
    55:                 "subject": "更新聯絡方式",
    56:                 "content": "電話改為 0987xxxxxx",
    57:                 "sender": "alice@example.com",
    58:             },
    59:         ),
    60:         (
    61:             "詢問流程或規則",
    62:             {"subject": "退貨流程", "content": "不良品如何退貨？", "sender": "bob@example.com"},
    63:         ),
    64:         (
    65:             "投訴與抱怨",
    66:             {"subject": "體驗不佳", "content": "等待過久", "sender": "carol@example.com"},
    67:         ),
    68:         ("其他", {"subject": "一般詢問", "content": "請問出貨時間", "sender": "eve@example.com"}),
    69:     ]
    70:     results = {}
    71:     for label, payload in cases:
    72:         payload = dict(payload)
    73:         payload["predicted_label"] = label
    74:         res = handle(payload)
    75:         # 逐案寫檔，便於你檢視
    76:         out_path = OUT / f"demo_{res.get('action') or res.get('action_name', 'unknown')}.json"
    77:         out_path.write_text(json.dumps(res, ensure_ascii=False, indent=2), encoding="utf-8")
    78:         results[label] = {
    79:             "action": res.get("action") or res.get("action_name"),
    80:             "output": str(out_path),
    81:         }
    82:         # 若有附件路徑，檢查其存在性
    83:         for ap in res.get("attachments", []) or []:
    84:             apath = Path(ap)
    85:             results[label].setdefault("attachments", []).append(
    86:                 {
    87:                     "path": str(apath),
    88:                     "exists": apath.exists(),
    89:                     "size": apath.stat().st_size if apath.exists() else 0,
    90:                 }
    91:             )
    92:     # 總覽寫檔
    93:     (OUT / "offline_verify_summary.json").write_text(json.dumps(results, ensure_ascii=False, indent=2), encoding="utf-8")
    94:     return results
    95: 
    96: 
    97: def main() -> None:
    98:     print("[VERIFY] 開始離線測試")
    99:     code = run_offline_tests()
   100:     print(f"[VERIFY] pytest -k 'not online' 結束，exit={code}")
   101:     print("[VERIFY] 產出六類動作 Demo")
   102:     summary = demo_actions()
   103:     print("[VERIFY] 結果總覽：", json.dumps(summary, ensure_ascii=False, indent=2))
   104: 
   105: 
   106: if __name__ == "__main__":
   107:     main()
--------------------------------------------------------------------------------
END FILE    .portfolio_hidden/.dev/offline_verify.py
================================================================================
================================================================================
BEGIN FILE  .portfolio_hidden/.dev/one_paste_ship.py  (7692 bytes)
TAGS: legacy_candidate=no | sys_path_hack=no | duplicate_basename=no
--------------------------------------------------------------------------------
     1: #!/usr/bin/env python3
     2: # tools/one_paste_ship.py
     3: import fnmatch
     4: import os
     5: import shlex
     6: import subprocess
     7: import sys
     8: from datetime import datetime
     9: from pathlib import Path
    10: 
    11: ROOT = Path.cwd()
    12: VENV = ROOT / ".venv"
    13: BIN = VENV / ("Scripts" if os.name == "nt" else "bin")
    14: PY = str(BIN / "python") if (BIN / "python").exists() else sys.executable
    15: PIP = str(BIN / "pip") if (BIN / "pip").exists() else sys.executable + " -m pip"
    16: 
    17: EXCLUDE_DIRS = [
    18:     ".git/",
    19:     ".venv/",
    20:     "__pycache__/",
    21:     ".pytest_cache/",
    22:     "logs/",
    23:     "htmlcov/",
    24:     "diagnostics/",
    25:     "backup_dedup_",
    26:     "modules_legacy_backup_",
    27:     ".github/",
    28: ]
    29: EXCLUDE_GLOBS = [
    30:     "*.png",
    31:     "*.jpg",
    32:     "*.jpeg",
    33:     "*.gif",
    34:     "*.webp",
    35:     "*.svg",
    36:     "*.ico",
    37:     "*.ttf",
    38:     "*.otf",
    39:     "*.woff",
    40:     "*.woff2",
    41:     "*.zip",
    42:     "*.tar",
    43:     "*.gz",
    44:     "*.tgz",
    45:     "*.mp4",
    46:     "*.mov",
    47:     "*.pdf",
    48:     "sma-codeonly.tar.gz",
    49: ]
    50: DEFAULT_BRANCH = os.getenv("TARGET_BRANCH", "main")
    51: PASTE_FILE = ROOT / "ALL_CODE_FOR_PASTE.txt"
    52: 
    53: 
    54: def run(cmd, check=True, env=None, cwd=None, quiet=False):
    55:     if isinstance(cmd, str):
    56:         cmd = shlex.split(cmd)
    57:     p = subprocess.run(cmd, cwd=cwd, env=env, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True)
    58:     if not quiet:
    59:         sys.stdout.write(p.stdout)
    60:     if check and p.returncode != 0:
    61:         raise SystemExit(p.stdout or p.returncode)
    62:     return p
    63: 
    64: 
    65: def ensure_venv_and_tools():
    66:     if not VENV.exists():
    67:         print("==> creating venv")
    68:         run([sys.executable, "-m", "venv", str(VENV)])
    69:     print("==> upgrading pip")
    70:     run(shlex.split(f"{PIP} -q install -U pip"))
    71:     # 專案必備 + 開發工具
    72:     print("==> installing project reqs")
    73:     req = ROOT / "requirements.txt"
    74:     if req.exists():
    75:         run(shlex.split(f"{PIP} -q install -r {req}"), check=False)
    76:     print("==> installing dev tools")
    77:     run(shlex.split(f"{PIP} -q install -U pytest black isort flake8 python-dotenv"))
    78: 
    79: 
    80: def format_and_lint():
    81:     print("==> isort / black / flake8")
    82:     run([PY, "-m", "isort", "."])
    83:     run([PY, "-m", "black", "."])
    84:     run([PY, "-m", "flake8"])
    85: 
    86: 
    87: def run_offline_tests():
    88:     print("==> pytest -k 'not online'")
    89:     env = os.environ.copy()
    90:     env["OFFLINE"] = "1"
    91:     run([PY, "-m", "pytest", "-q", "-k", "not online"], env=env)
    92: 
    93: 
    94: def git_ls_files():
    95:     try:
    96:         out = run(["git", "ls-files", "-z"], quiet=True).stdout
    97:         files = [Path(p) for p in out.split("\x00") if p]
    98:     except Exception:
    99:         files = [p for p in ROOT.rglob("*") if p.is_file()]
   100:     return files
   101: 
   102: 
   103: def is_excluded(path: Path) -> bool:
   104:     rel = path.as_posix()
   105:     for d in EXCLUDE_DIRS:
   106:         if f"{d}" in rel:
   107:             return True
   108:     for g in EXCLUDE_GLOBS:
   109:         if fnmatch.fnmatch(rel, g):
   110:             return True
   111:     return False
   112: 
   113: 
   114: def is_text_file(path: Path) -> bool:
   115:     try:
   116:         b = path.read_bytes()
   117:     except Exception:
   118:         return False
   119:     if b"\x00" in b[:4096]:
   120:         return False
   121:     try:
   122:         b.decode("utf-8")
   123:         return True
   124:     except UnicodeDecodeError:
   125:         return False
   126: 
   127: 
   128: def ensure_readme_and_ignore():
   129:     gi = ROOT / ".gitignore"
   130:     gi.touch(exist_ok=True)
   131:     needed = [
   132:         ".venv/",
   133:         "logs/",
   134:         "__pycache__/",
   135:         ".pytest_cache/",
   136:         "htmlcov/",
   137:         ".coverage*",
   138:         "data/output/",
   139:         "sma-codeonly.tar.gz",
   140:         "backup_dedup_*/",
   141:         "modules_legacy_backup_*/",
   142:         "assets/fonts/*.ttf",
   143:     ]
   144:     cur = gi.read_text(encoding="utf-8").splitlines()
   145:     changed = False
   146:     for p in needed:
   147:         if p not in cur:
   148:             cur.append(p)
   149:             changed = True
   150:     if changed:
   151:         gi.write_text("\n".join(cur) + "\n", encoding="utf-8")
   152:         print("updated .gitignore")
   153: 
   154:     readme = ROOT / "README.md"
   155:     if not readme.exists():
   156:         readme.write_text(
   157:             "# Smart Mail Agent\n\n"
   158:             "Quickstart:\n"
   159:             "```bash\n"
   160:             "python -m venv .venv && . .venv/bin/activate\n"
   161:             "pip install -U pip && pip install -r requirements.txt\n"
   162:             'OFFLINE=1 PYTHONPATH=src pytest -q -k "not online"\n'
   163:             "```\n",
   164:             encoding="utf-8",
   165:         )
   166:         print("created README.md")
   167: 
   168: 
   169: def export_all_code(paste_path: Path = PASTE_FILE):
   170:     print(f"==> building {paste_path.name}")
   171:     files = []
   172:     for f in git_ls_files():
   173:         if not f.is_file():
   174:             continue
   175:         if is_excluded(f):
   176:             continue
   177:         if not is_text_file(f):
   178:             continue
   179:         try:
   180:             if f.stat().st_size > 800 * 1024:
   181:                 continue
   182:         except Exception:
   183:             pass
   184:         files.append(f)
   185: 
   186:     files.sort(key=lambda p: p.as_posix())
   187:     with open(paste_path, "w", encoding="utf-8", newline="\n") as out:
   188:         out.write(f"# ALL_CODE_FOR_PASTE\n# generated: {datetime.utcnow().isoformat()}Z\n")
   189:         out.write("# format: ===FILE: <relative path>\n")
   190:         for f in files:
   191:             rel = f.as_posix()
   192:             out.write(f"\n===FILE: {rel}\n")
   193:             out.write(f.read_text(encoding="utf-8"))
   194:             out.write("\n===END===\n")
   195:     print(f"wrote {paste_path}")
   196: 
   197: 
   198: def import_from_paste(paste_path: Path):
   199:     print(f"==> importing from {paste_path}")
   200:     if not paste_path.exists():
   201:         raise SystemExit(f"{paste_path} not found")
   202:     txt = paste_path.read_text(encoding="utf-8")
   203:     blocks = txt.split("\n===FILE: ")
   204:     created = 0
   205:     for blk in blocks[1:]:
   206:         header, _, body = blk.partition("\n")
   207:         rel = header.strip()
   208:         content, _, _end = body.partition("\n===END===\n")
   209:         dest = ROOT / rel
   210:         dest.parent.mkdir(parents=True, exist_ok=True)
   211:         dest.write_text(content, encoding="utf-8")
   212:         created += 1
   213:     print(f"restored {created} files")
   214: 
   215: 
   216: def git_commit_push(
   217:     message: str = "chore: interview-ready snapshot (offline green, formatted, export bundle)",
   218: ):
   219:     print("==> git add/commit/push")
   220:     run(["git", "fetch", "origin"])
   221:     cur = run(["git", "rev-parse", "--abbrev-ref", "HEAD"], quiet=True).stdout.strip()
   222:     if cur != DEFAULT_BRANCH:
   223:         run(["git", "checkout", DEFAULT_BRANCH])
   224:     run(["git", "pull", "--ff-only"])
   225:     run(["git", "add", "-A"])
   226:     st = run(["git", "diff", "--cached", "--name-only"], quiet=True).stdout.strip()
   227:     if not st:
   228:         print("no staged changes; skip commit")
   229:     else:
   230:         run(["git", "commit", "-m", message])
   231:     run(["git", "push", "-u", "origin", DEFAULT_BRANCH])
   232: 
   233: 
   234: def main():
   235:     import argparse
   236: 
   237:     ap = argparse.ArgumentParser(description="One-paste ship: format > lint > offline test > export > (optional) push")
   238:     ap.add_argument("--no-venv", action="store_true", help="不要建立/升級 venv（用現有環境）")
   239:     ap.add_argument("--format", action="store_true", help="只做 isort/black/flake8")
   240:     ap.add_argument("--test", action="store_true", help="只跑離線測試")
   241:     ap.add_argument("--export", action="store_true", help="輸出 ALL_CODE_FOR_PASTE.txt")
   242:     ap.add_argument("--import", dest="import_file", help="從 ALL_CODE_FOR_PASTE.txt 還原專案")
   243:     ap.add_argument("--push", action="store_true", help="完成後 git push 到 main")
   244:     ap.add_argument(
   245:         "--message",
   246:         default="chore: interview-ready snapshot (offline green, formatted, export bundle)",
   247:     )
   248:     args = ap.parse_args()
   249: 
   250:     if not args.no_venv:
   251:         ensure_venv_and_tools()
   252: 
   253:     if args.import_file:
   254:         import_from_paste(Path(args.import_file))
   255:         return
   256: 
   257:     ensure_readme_and_ignore()
   258:     format_and_lint()
   259:     run_offline_tests()
   260:     export_all_code(PASTE_FILE)
   261:     if args.push:
   262:         git_commit_push(args.message)
   263: 
   264: 
   265: if __name__ == "__main__":
   266:     main()
--------------------------------------------------------------------------------
END FILE    .portfolio_hidden/.dev/one_paste_ship.py
================================================================================
